<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【2.0】统一建模语言</title>
      <link href="/2022/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%902-0%E3%80%91%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/"/>
      <url>/2022/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%902-0%E3%80%91%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习设计模式之前，需要了解一下什么是<strong>统一建模语言（Unified Modeling Language,UML），用人话来说，对于现实生活中的建筑大楼有它的设计图，而统一建模语言是程序的设计图，只有看懂了设计图，才会设计实现程序</strong>。</p><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>如果要盖一栋楼，为了让不把它盖成一个狗窝，所以需要先画一些设计图，这些设计图就是楼房的蓝图。设计图是一种设计语言，也就是模型语言，是不同工程设计人员和生产人员直接沟通的语言。</p><p><strong>软件工程也需要使用模型来描述一个软件，使用户和开发人员都能够更好的理解开发的系统。</strong>建模是开发优秀软件的所有活动中最核心的部分之一，其目的是将结构和系统的行为联系起来，并对系统的结构进行可视化控制</p><p>随着软件系统的复杂度提高，好的建模语言需求越来越迫切，面向对象建模语言由此诞生，诞生初期软件建模增加到50多种，杂乱的建模语言让用户难以交流和使用</p><p>为了解决建模方法过多造成的种种问题，UML三位创始人，<strong>将所有建模语言统一起来也就形成了UML（统一建模语言）</strong></p><h1 id="UML的结构"><a href="#UML的结构" class="headerlink" title="UML的结构"></a>UML的结构</h1><p>UML是一种语言，也就意味着它有属于自己的表达规则。它不同于C#，JAVA等语言，而是一种分析设计语言，也就是一种建模语言，UML是由图形符号来达到建模语言，其主要结构如下：</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>在UML建模过程中，使用不同的视图从不同的角度来描述软件系统。UML包括5种视图：</p><ol><li>用户视图：以用户的观点表示系统的目标，它是所有视图的核心，该视图描述系统的需求</li><li>结构视图：表示系统的静态行为，描述系统的静态元素，如包，类与对象，以及它们之间的关系</li><li>行为视图：表示系统的动态行为，描述系统的组成元素（如对象）在系统运行时的交互关系</li><li>实现视图：表示系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系</li><li>环境视图：表示系统中物理元素的分布，描述系统中硬件设备以及它们之间的关系</li></ol><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>在UML 2.0中，提供13种图，与上述5种视图相对应</p><ul><li>用例图（Use Case Diagram）:又称为用况图，对应用户视图。在用例图中，<strong>使用用例来表示系统的功能需求</strong>，用例图用于表示多个外部执行者与系统用例之间以及用例与用例之间的关系。用例图与用例说明文档（Use Case     Specification）是常用的需求建模工具，也称为用例建模</li><li><strong>类图（Class     Diagram）</strong>:对应于结构视图。<strong>类图使用类来描述系统的静态结构，类图包含类和它们之间的关系</strong>，它描述系统内所声明的类，但没有描述系统运行时类的行为。</li><li>对象图（Object Diagram）:对应于结构视图。对象图是类图在某个时刻的一个实例，<strong>用于表示对象实例之间的关系</strong></li><li>包图（Package Diagram）:UML2.0新增图，对应于结构视图。<strong>包图用于描述包与包之间的关系</strong>，包是将多个元素组织在一起的机制，例如可以将多个类组织到一个包里</li><li>组合结构图（Composite     Structure Diagram）:UML2.0新增图，对应于结构视图。组合结构图将每一个类放在一个整体中，从类的内部结构来审视一个类。<strong>组合结构图用于表示一个类的内部结构，用于描述一些包含复杂成员或内部类的类结构</strong></li><li><strong>状态图（State     Diagram）</strong>:对应于行为视图。<strong>状态图用来描述一个特定对象的所有可能状态以及引起状态转移的事件</strong>。一个状态图包括一系列对象的状态以及状态和状态之间的转换</li><li>活动图（Activity Diagram）:对应于行为视图。活动图用来表示系统中的各种活动次序，它的应用比较广泛，既可以用来表示用例的工作流程，也可以描述类的某个方法的操作行为</li><li><strong>顺序图（Sequence     Diagram）</strong>:又称为时序图或者序列图，对应于行为视图。<strong>顺序图用于表示对象之间的交互，重点表示对象之间发送消息的时间顺序</strong></li><li>通信图（Communiccation）:在UML 1.x中称为协作图，对应于行为视图。通信图展示了一组对象，这些对象间的连接以及它们之间收发的消息。它与顺序图是同结构图，也就是它们包含了相同的信息，只是表达形式不同，两这个可以相互转换</li><li>定时图（Timing Diagram）:UML 2.0的新增图，对应于行为视图。定时图采用一种带数字刻度的时间轴来精确表示消息的顺序，而不是像顺序图那样只是指定消息的相对顺序</li><li>交互概览图</li><li>组件图</li><li>部署图</li></ul><h2 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h2><p>在UML中，模型元素包括事物以及事物之间的联系。事物是UML的重要组成部分。事物和事物之间的联系就是对应的模型元素。同一个模型元素可以在不同的UML图中使用，但是不论在那个UML图中，它所表达的意思是不变的</p><h2 id="通用机制"><a href="#通用机制" class="headerlink" title="通用机制"></a>通用机制</h2><p>UML提供的通用机制为模型元素提供的额外的注释，修饰和语义等，主要包括规格说明，修饰，公共分类个扩展机制四种。扩展机制运行用户对UML进行扩展</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类图是使用频率最高的UML图之一，<strong>在设计模式中，我们将使用类图来描述一个模式的结构，通过类图来分析每一个模式实例</strong></p><h2 id="类与类图"><a href="#类与类图" class="headerlink" title="类与类图"></a>类与类图</h2><p>类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性，操作，关系的对象集合的总称。在系统中，每个类具有一定的职责，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计的好的类一般只有一种职责。在定义类的时候，将类的职责分解成类的属性和操作（方法）。类的属性就即类的数据职责，类的方法即类的行为职责</p><p><strong>在软件系统运行时，类将被实例化成对象（Object），对象对应于某个具体的事物。类是对一组具体相同属性，表现相同行为的对象的抽象，对象是类的实例（Instance）</strong></p><p>类图（Class Diagram)通过出现在系统中的不同类来描述系统的静态结构，类图用来描述不同的类和它们之间的关系。在UML中。类使用具有类名称，属性，方法分隔的长方形来表示，其对应的代码为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> email;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyInfo</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其对应的类图为：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621144756496.png" alt="image-20220621144756496" style="zoom: 80%;" /></p><p>由上图可以看出，UML类图由三个部分组成：</p><ul><li><p><strong>类名</strong>：，每个类都必须有一个名字，类名是一个字符串。<strong>按照C#类名规则，开头要大写字母</strong></p></li><li><p><strong>属性（Attributes）:属性是指类的性质，即类的成员变量</strong>。类可以有任意多个属性，也可以没有属性</p><ul><li><p>UML规定属性的表示方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性 名称：类型 [默认值]</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>可见性表示该属性对类外的元素是否可见，包括公有（Public），私有（Private）和受保护（Protected）三种，在类图中对应的符号分别是“+”“-”和“#”表示.</strong></li><li><em>名称表示属性名<strong>，用一个字符串表示，</strong>按照C#命名规则，一般是属性第一个字母要小写*</em></li><li>类型表示定义属性的数据类型，可以是基本属性类型，也可以用户自定义类型</li><li>默认值是一个可选项，即属性的初始值</li></ol></li><li><p><strong>类的操作（方法）（Operations）</strong>：操作是类的任意一个实例对象都可以使用的行为，操作是类的方法成员</p><ul><li><p>UML规定操作的表示方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性 名称([参数列表])：[返回类型]</span><br></pre></td></tr></table></figure></li></ul><ol><li>可见性的定义与属性定义相同</li><li>名称即操作名称或者方法名称，用一个字符串表示</li><li>参数列表表示操作的参数，其语法与属性表示相同，参数个数是任意的，多个参数之间用逗号隔开</li><li>返回类型是一个可选项，表示方法的返回值类型，依赖具体编程语言，可以是基本数据类型，也可以是用户自定义类型，也可以是空类型（void）。如果是构造方法，则无返回类型</li></ol></li></ul><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系是类与类之间最常用的一种关系，它是一种结构化的关系，<strong>用于表示一类对象与另一类对象之间有联系</strong>，例如：车辆与轮胎，老师与学生等。</p><p>在UML图中，通过实线来链接有关联的对象，在<code>C#</code>等编程语言中表示关联关系，<strong>通常将一个类的对象作为另一个类的属性</strong>。<strong>在使用类图表示关联关系时，可以通过在关联线上标注角色名(字符串)，一般使用一个表示两者之间的关系的动词作为角色名（字符串）</strong>。角色名不是必须的，在有必要的情况下标注，可以更好的理解关系。</p><p>对应的代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621153839727.png" alt="image-20220621153839727"  /></p><p>对应的UML图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621153910479.png" alt="image-20220621153910479" style="zoom:80%;" /></p><p>关联关系可以分为以下几种类型：</p><ul><li><p><strong>双向关联</strong></p><p>默认情况下，关联是双向的，例如，顾客（Customer）购买商品（Product）并拥有商品；反之，卖出的商品总有某个顾客与之相关联。因此Customer类和Product类之间具有关联关系。</p><p>其代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621154104022.png" alt="image-20220621154104022" style="zoom:80%;" /></p><p>其 UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621154050982.png" alt="image-20220621154050982"  /></p></li><li><p><strong>单向关联</strong></p><p>类的关联关系也可以是单向的，用带箭头的实线来表示，例如：顾客（Customer）拥有地址（Address）</p><p>，则Customer类和Address类是单向关系。</p><p>其代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621154141366.png" alt="image-20220621154141366" style="zoom: 80%;" /></p><p>其 UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621154205119.png" alt="image-20220621154205119"  /></p></li><li><p><strong>自关联</strong></p><p>在系统中可能存在一些自关联的类，类的属性对象类型是自身。例如：一个节点类(Node)的</p><p>成员又是节点对象。</p><p>其代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621154230261.png" alt="image-20220621154230261" style="zoom:100%;" /></p><p>其 UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621154353368.png" alt="image-20220621154353368"  /></p></li><li><p><strong>多重性关联</strong></p><p>多重性关联关系又称为重数性关联关系（Multiolicity），表示一个类的对象与另一个类的对象链接的个数。在UML重多重性关联关系可以直接在关联直线上增加一个数字表示与之对应的另一个对象的个数。</p><p>| 表示方式 | 多重性说明                                                   |<br>| ———— | —————————————————————————————— |<br>| 1……1     | 表示另一个类的一个对象与一个该类对象有关系                   |<br>| 0……<em>     | 表示另一个类的一个对象与零个或者多个该类的对象有关系         |<br>| 1……</em>     | 表示另一个类的一个对象与一个或多个该类的对象有关系           |<br>| 0……1     | 表示另一个类的一个对象与零个或一个该类对象有关系             |<br>| m……n     | 表示另一个类的一个对象与最少m，最多n个该类的对象有关系（m&lt;=n） |</p><p>例如：一个窗体可以拥有多个Button，但是一个Button只能对应一个窗体。代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621161914228.png" alt="image-20220621161914228" style="zoom:80%;" /></p><p>UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621161929797.png" alt="image-20220621161929797"  /></p></li></ul><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p><strong>聚合关系（Aggregation）表示一个整体和部分的关系</strong>。通常在定义好一个整体类，从中分析整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。例如：计算机包括显示器，主机，键盘，鼠标等等。在聚合关系中，成员类是整体的一部分，即成员对象是整体对象的一部分，但是成员类的对象可以脱离整体独立存在。例如：汽车和发动机是聚合关系，但是发动机可以脱离汽车单独存在。</p><p><strong>在 UML 图中，这种关系用带空心菱形的直线表示</strong>，代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162325093.png" alt="image-20220621162325093" style="zoom: 80%;" /></p><p>UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162345390.png" alt="image-20220621162345390" style="zoom:80%;" /></p><blockquote><p>在代码中，Car定义了一个Engine类的成员变量，从语义上来说，Engine是Car的一部分，但是Engine对象可以脱离Car独立存在。因此，在类Car中不直接实例化Engine，而是通过构造方法等将在类外部实例化好的Engine对象已参数形式传入Car中，这种方式称为：注入（Injection）。</p></blockquote><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系也表示整体和部分之间的关系，但是组合关系中整体和部分拥有统一的生存期。一旦</p><p>整体对象不存在时，部分对象也将不存在，部分对象和整体对象有共同生死的关系。例如：消息界面的按钮，控件等等和界面是组合关系，界面不存在，则控件部分也不存在。成员类是整体类的一部分，而整体类的生存期控制成员类的生存期。<strong>在UML中，这种关系用带实心菱形的直线表示。</strong></p><p>例如：人的头（Head）与嘴巴（Mouth），嘴巴是头的部分，头不存在，则嘴巴不存在。UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162508287.png" alt="image-20220621162508287" style="zoom:80%;" /></p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系（Dependency）是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，<strong>在需要表示一个事物使用另一个事物时使用依赖关系</strong>。大多数的情况下，依赖关系体现在某个类方法使用另一个类的对象作为参数。</p><p><strong>在 UML 中，依赖关系用带箭头的虚线表示，由依赖方指向被依赖方。</strong></p><p>例如：驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为参数传递给被依赖的一方，代码示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162648222.png" alt="image-20220621162648222" style="zoom:80%;" /></p><p>UML 图示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162705231.png" alt="image-20220621162705231"  /></p><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系（Generalization）也就是继承关系，也称为“is-a-kind-of”关系，<strong>泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类</strong>。<strong>在UML中，泛化关系用带空心三角形的直线来表示</strong>。在代码实现时，使用面向对象的继承机制来实现泛化关系。</p><p>例如：Student类和Teacher类都是Person类的子类，Student类和Techer类继承了Person类的属性和方法，另外Student类增加了属性学号（studentNo）,Teacher类增加了属性教师编号（teacherNo）</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162806974.png" alt="image-20220621162806974" style="zoom:67%;" /></p><h3 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h3><p>现在很多面向对象编程，引入了接口的概念。<strong>在接口中，一般没有属性，而且所有操作都是抽象的，只有操作的声明，没有操作的实现。</strong>UML中用与类的表示法类似的方法表示接口。</p><p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系（Realiazation）。<strong>在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。</strong></p><p>在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。</p><p>例如：定义了一个交通工具接口Vehicle,其中有一个抽象操作move()，在类Ship和类Car中都实现了该move()操作，不过具体的实现细节可能会不一样。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621162933693.png" alt="image-20220621162933693" style="zoom:80%;" /></p><h1 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h1><p>顺序图是最常用的系统动态建模工具之一，也是使用频率最高的交互图，它用于表示对象之间的动态交互，而且以图形化的方式描述了对象间消息传递的时间顺序。</p><h2 id="顺序图的定义"><a href="#顺序图的定义" class="headerlink" title="顺序图的定义"></a>顺序图的定义</h2><p><strong>顺序图（Sequence Diagram）是一种强调对象间消息传递次序的交互图，又称为时序图</strong>或者序列图。</p><p>顺序图以图形化的方式描述了在一个用例或者操作的执行过程中对象如何通过消息互相交互，说明了消息如何在对象之间发送和接收以及发送的顺序。顺序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，还可以发送消息。</p><h2 id="顺序图组成元素与绘制"><a href="#顺序图组成元素与绘制" class="headerlink" title="顺序图组成元素与绘制"></a>顺序图组成元素与绘制</h2><p>在UML中，顺序图将交互关系表示为一个二维图，纵向是时间轴，时间沿竖线向下延申；横向轴表示了在交互过程中的独立对象，对象的活动用生命线来表示。<strong>顺序图由执行者（Actor）,生命线（Lifeline），对象（Object），激活（Activation）和消息（Message）等元素组成</strong>。</p><p>UML顺序图的组成元素说明如下：</p><ol><li><p>执行者是交互的发起人，使用与用例图一样的“小人”符号表示，在有些交互过程中无须使用执行者</p></li><li><p>生命线用一条纵向虚线表示</p></li><li><p>对象表示为一个矩形，其中对象名称标有下划线</p></li><li><p>激活是过程的执行，包括等待过程执行的时间。在顺序图中激活部分替换生命线，使用长条的矩形表示</p></li><li><p>消息是对象之间的通信，是两个对象之间的单路通信，是从发送者到接收者之间的控制信息流。消息在顺序图中由有标记的箭头表示，箭头从一个对象的生命线指向另一个对象的生命线。消息按时间顺序在途中从上到下排列。</p></li><li><p>一个复杂的顺序图可以划分为几个小块，每个小块称为一个交互片段（Interaction     Fragment）。每个交互片段由一个大方框包围，在方框左上角的间隔区内标注该交互片段的操作类型，该操作类型用操作符表示，常用的操作符包括：</p></li><li><ul><li>alt:多条路径，条件为真时执行</li><li>opt:任选，仅当条件为真时执行</li><li>par:并行，每一片段都并发执行</li><li>loop:循环，片段可以多次执行</li></ul></li></ol><p>例如：ATM的用户登录流程</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621163052414.png" alt="image-20220621163052414" style="zoom: 67%;" /></p><p>在顺序图中，有的消息对应于激活，表示它将会激活一个对象，这种消息被称为调用消息（Call Message）；如果消息没有对应激活框，表示它不是一个调用消息，不会引发其他对象活动，这种消息称为发送消息（Send Message）；如果对象的一个方法调用了自己的另一个方法时，消息是由对象发送给自身，这种消息被称为自身消息（Self Call Message）</p><p>顺序图中的消息还包括创建消息和销毁消息，创建消息用于使用New关键字创建另一个对象，而销毁消息用于调用对象的销毁方法将一个对象从内存中销毁。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621163130021.png" alt="image-20220621163130021" style="zoom:67%;" /></p><h1 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h1><p>对于系统中那些具有多种状态的对象，状态图是一种常用的建模手段。状态图用于描述对象的各种状态以及状态之间的转换。在设计模式中，使用状态图来描述某些模式中对象的状态以及状态间的转换。</p><h2 id="状态图的定义"><a href="#状态图的定义" class="headerlink" title="状态图的定义"></a>状态图的定义</h2><p>状态图（Statechart Diagram）用来描述一个特定对象的所有可能状态以及引起其状态改变的事件。我们通常用状态图来描述单个对象的行为，它确定了由事件序列引出的状态序列，但并不是所有的类都需要使用状态图来描述它的行为，只有那些具有重要交互行为的类，我们才会使用状态图来描述。一个状态图包括一系列的状态以及状态之间的转移。</p><p>状态图适用于描述在不同用例之间的对象行为，但并不适合于描述包括若干协作的对象行为，因为一个状态图只能用于描述一个类的对象状态，如果涉及多个不同类的对象，则需要使用活动图。</p><h2 id="状态图组成元素与绘制"><a href="#状态图组成元素与绘制" class="headerlink" title="状态图组成元素与绘制"></a>状态图组成元素与绘制</h2><p>在UML状态图中包括如下组成元素。</p><ol><li>状态（State）:又称为中间状态，用圆角矩形框表示。在一个状态图中可以有多个状态，每个状态包含两格：上格放置状态名称，下格说明处于该状态时对象可以进行的活动（Action）</li><li>初始状态（Initial State）：又称为初态，用一个黑色的实心圆圈表示。在一个状态图中只能够有一个初始状态</li><li>结束状态（Final State）：又称为终止状态或者终态，用一个实心圆外加一个圆圈表示。在一个状态图中可能有多个结束状态</li><li>转移（Transition）：用于从一个状态到另一个状态之间的连线和箭头说明状态的转移情况，并用文字说明引发这个状态变换的相应事件是什么。事件有可能在特定的条件下发生，在UML中这样的条件称为守护条件（Guard Condition），发生事件时的处理也称为动作（Action）。状态之间的转移可带有标注，由三部分组成（每一个部分都可以省略），其语法为：<code>事件名[条件]/动作名</code></li></ol><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621163228884.png" alt="image-20220621163228884" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621163246622.png" alt="image-20220621163246622" style="zoom:80%;" /></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>终于弄完了最开始的设计模式部分，说实话我是没打算发这部分的，但是考虑到部分伙伴可能就没接触过设计模式还是把它腾上来了。后面的文章我会跳过后面设计原则说明部分，直接开始设计模式实际实现和相关内容。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> UML </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】设计模式概述</title>
      <link href="/2022/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%901-0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E3%80%901-0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式去年我已经学过一遍了，所有内容都记录在我的<code>OneNote</code>笔记上了，现在遂打算把它们重新复习一遍，发到我的博客上，希望能有新的感悟，我会省去大量的定义尝试去用简单的语法和方法来说明每种设计模式的思路和方法实现。</p><p><strong>前排提醒：</strong></p><ul><li><strong>该设计模式使用的是<code>C#</code>作为示例语言</strong>，当然模式思想是通用的，前提是你能看到我的代码思想。</li><li>需要有一定的<code>C#</code>语言基础（<code>.NET</code>），例如：是否知道什么是类，属性，方法，接口，委托</li><li>需要有一定的 Visual Studio IDE使用基础</li></ul><blockquote><p>如下内容看个眼熟，理解即可，等到学习完全部具体的设计模式，再回看这里就明白了。</p></blockquote><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，<strong>每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案</strong>，这也是设计模式能被广泛应用的原因。</p><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，<strong>总共有</strong> <strong>23</strong> <strong>种设计模式</strong>。这些模式可以分为三大类：<strong>创建型模式（**</strong>Creational Patterns<strong>）、结构型模式（</strong>Structural Patterns<strong>）、行为型模式（</strong>Behavioral Patterns<strong>）</strong>。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>这些设计模式提供了一种<strong>在创建对象的同时隐藏创建逻辑的方式</strong>，而不是使用new运算符直接实例化对象；这使得程序在判断针对某个给定实例需要创建哪些对象更加灵活；</p><ul><li><strong>工厂模式</strong></li><li><strong>抽象工厂模式</strong></li><li><strong>单例模式</strong></li><li><strong>建造者模式</strong></li><li><strong>原型模式</strong></li></ul><h2 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h2><p>这些设计模式<strong>关注类和对象的组合</strong>；继承的概念被用来组合接口和定义组合对象获得新功能的方式</p><ul><li><strong>适配器模式</strong></li><li><strong>桥接模式</strong></li><li><strong>过滤器模式</strong></li><li><strong>组合模式</strong></li><li><strong>装饰器模式</strong></li><li><strong>外观模式</strong></li><li><strong>享元模式</strong></li><li><strong>代理模式</strong></li></ul><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>这些设计模式特别<strong>关注对象之间通信</strong>；</p><ul><li><strong>责任链模式</strong></li><li><strong>命令模式</strong></li><li><strong>解释器模式</strong></li><li><strong>迭代器模式</strong></li><li><strong>中介者模式</strong></li><li><strong>备忘录模式</strong></li><li><strong>观察者模式</strong></li><li><strong>状态模式</strong></li><li><strong>空对象模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板模式</strong></li><li><strong>访问者模式</strong></li></ul><h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><div class="table-container"><table><thead><tr><th>设计原则名称</th><th>设计原则简介</th></tr></thead><tbody><tr><td>单一职责原则  （Single  Responsibility Principle,SRP）</td><td>类的职责要单一，不能将太多的职责放在一个类中</td></tr><tr><td>开闭原则  （Open-Closed  Principle,OCP）</td><td>软件实体对拓展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上拓展其功能</td></tr><tr><td>里氏代换原则  （Liskov  Substitution Principle,LSP）</td><td>在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象</td></tr><tr><td>依赖倒转原则  （Dependency  Inversion Principle,DIP）</td><td>要针对抽象层编程，而不要针对具体类编程</td></tr><tr><td>接口隔离原则  （Interface  Segregation Principle,ISP）</td><td>使用多个专门的接口来取代一个统一的接口</td></tr><tr><td>合成复用原则  （Composite  Reuse Principle,CRP）</td><td>在复用功能时，应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系</td></tr><tr><td>迪米特法则  （Law of  Demeter,LoD）</td><td>一个软件实体对其他实体的引用越少越好，或者说如果两个类不必须彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互</td></tr></tbody></table></div><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这篇概述很水，我只是将我笔记复制过来，修改了一点点内容，其实我是打算解释一下六大原则的，这六大原则对于设计模式来说是核心思想，但是懒得用长篇大论来解释这些原则，希望可以在如上有限的文字中理解，如果实在不理解，也可以在后面的详细的每个设计模式中理解到。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖项属性</title>
      <link href="/2022/06/21/CSharp/WPF/%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/06/21/CSharp/WPF/%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我尝试写一部分 WPF 元素绑定的相关内容的时候，写到开头发现我不得不先解释说明一下依赖项属性的相关内容，遂停止元素绑定内容的记录，补写依赖项属性的相关内容。</p><h1 id="理解依赖项属性"><a href="#理解依赖项属性" class="headerlink" title="理解依赖项属性"></a>理解依赖项属性</h1><p>属性和事件是<code>.NET</code>抽象模型的核心部分，如果你懂得 VB 或者 WinForm 相关开发的话会十分了解这点。但是对于 WPF 来说，它在传统的属性基础上做了一层封装，将它变成了更加高级的依赖项属性。同时也不会和传统的属性发生冲突。</p><p>这种更高级的依赖项属性使用了效率更高的保存机制，并支持附加功能，例如：更高通知以及属性值的继承。</p><p>依赖项属性是<code>.NET</code>属性的新实现，在 WPF 技术特性中，是及其依赖于依赖项属性的实现，虽然在使用过程中，感觉和普通的属性一致。</p><h1 id="定义依赖项属性"><a href="#定义依赖项属性" class="headerlink" title="定义依赖项属性"></a>定义依赖项属性</h1><p>绝大部分的微软提供的属性都是依赖项属性，但是在某些情况下，我们需要自定义我们自己的依赖项属性，比如我们自定义的控件。</p><h2 id="定义依赖项属性-1"><a href="#定义依赖项属性-1" class="headerlink" title="定义依赖项属性"></a>定义依赖项属性</h2><p>需要注意的是：<strong>自定义的依赖项属性的类，必须继承于<code>DependencyObject</code></strong>，因为后续需要使用该类的方法来修改依赖项属性的值。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义了 Test 类，该类继承于 DependencyObject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义依赖项属性 InfoProperty</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty InfoProperty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建依赖项属性的命名规则是最后加上<code>Property</code>来表示其为依赖项属性</p></blockquote><h1 id="注册依赖项属性"><a href="#注册依赖项属性" class="headerlink" title="注册依赖项属性"></a>注册依赖项属性</h1><p>定义好依赖项属性后需要注册依赖项属性来使用该依赖项，注册依赖项需要两个步骤，<strong>第一个步骤是创建<code>FrameworkPropertyMetadata</code>对象来决定依赖项的一些基础属性，然后创建<code>DependencyProperty</code>对象来实现依赖项属性的初始化。</strong></p><p>因为我们需要使用依赖项属性，所以依赖项属性的注册必须在使用代码之前注册，所以<strong>需要在静态构造函数中定义</strong>。又因为为了确保<code>DependencyProperty</code>，即依赖项属性不会在后续的代码中被人更改，所以使用的是<code>readonly</code>关键字。</p><p>同样的，<strong>WPF 确保<code>DependencyProperty</code>不会被直接实例化，所以必须通过静态的<code>DependencyProperty.Register</code>来生成实例对象</strong>；代码示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义依赖项属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty InfoProperty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化注册依赖项属性</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化依赖项属性的相关参数和功能</span></span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义依赖项属性对象</span></span><br><span class="line">        InfoProperty = DependencyProperty.Register(<span class="string">&quot;Anfo&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Info),metadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FrameworkPropertyMetadata-对象"><a href="#FrameworkPropertyMetadata-对象" class="headerlink" title="FrameworkPropertyMetadata 对象"></a>FrameworkPropertyMetadata 对象</h2><p><strong>该对象规定了所注册依赖项的默认初始值，以及所支持的相关服务（布局影响，数据绑定等）</strong>，它的构造函数有多个重载，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FrameworkPropertyMetadata</span>(<span class="params"><span class="built_in">object</span> defaultValue</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FrameworkPropertyMetadata</span>(<span class="params"><span class="built_in">object</span> defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>defaultValue</code>：该依赖项属性的默认初始值</strong>‘</p></li><li><p><strong><code>FrameworkPropertyMetadataOptions</code>：该依赖项属性的所支持的服务功能，</strong>参数如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     未指定任何选项；依赖属性使用 Windows Presentation Foundation (WPF) 属性系统的默认行为。</span></span><br><span class="line">None = <span class="number">0</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响布局组合的测量过程。</span></span><br><span class="line">AffectsMeasure = <span class="number">1</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响布局组合的排列过程。</span></span><br><span class="line">AffectsArrange = <span class="number">2</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响父元素上的测量过程。</span></span><br><span class="line">AffectsParentMeasure = <span class="number">4</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响父元素上的排列过程。</span></span><br><span class="line">AffectsParentArrange = <span class="number">8</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     更改此依赖属性的值会影响呈现或布局组合的某一方面（不是测量或排列过程）。</span></span><br><span class="line">AffectsRender = <span class="number">16</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性的值将由子元素继承。</span></span><br><span class="line">Inherits = <span class="number">32</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性的值跨越分隔的树以实现属性值继承。</span></span><br><span class="line">OverridesInheritanceBehavior = <span class="number">64</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     不允许将数据绑定到此依赖属性。</span></span><br><span class="line">NotDataBindable = <span class="number">128</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性上的数据绑定的 System.Windows.Data.BindingMode 默认为 System.Windows.Data.BindingMode.TwoWay。</span></span><br><span class="line">BindsTwoWayByDefault = <span class="number">256</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性的值应由日记记录进程或在由 Uniform resource identifiers (URIs) 导航时进行保存或存储。</span></span><br><span class="line">Journal = <span class="number">1024</span>,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     此依赖属性值上的子属性不会影响呈现的任何方面。</span></span><br><span class="line">SubPropertiesDoNotAffectRender = <span class="number">2048</span></span><br></pre></td></tr></table></figure><blockquote><p>可以传入参数名称，也可以传入参数对应的数值</p></blockquote></li><li><p><strong><code>CoerceValueCallback</code>：该方法在<code>validateValueCallback</code>后执行，可以对依赖项属性进行验证</strong>，详细</p><p>可以查看下面的属性验证部分内容。</p><blockquote><p><code>validateValueCallback</code>是<code>DependencyProperty</code>类型的方法</p></blockquote></li><li><p><strong><code>propertyChangedCallback</code>：当属性值发生改变时会调用</strong></p></li></ul><h2 id="DependencyProperty-对象"><a href="#DependencyProperty-对象" class="headerlink" title="DependencyProperty 对象"></a>DependencyProperty 对象</h2><p><strong><code>DependencyProperty</code>对象的实例化需要通过静态方法<code>DependencyProperty.Register</code>来实现</strong>，该方法同样有多种重载，原型示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DependencyProperty <span class="title">Register</span>(<span class="params"><span class="built_in">string</span> name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>name</code>：你所定义的依赖项属性名称</strong>，该名称只会影响该对象的<code>Name</code>属性，不会对代码产生实际影响</li><li><strong><code>propertyType</code>：该依赖项属性的类型</strong>，即该依赖项属性的类型</li><li><strong><code>ownerType</code>：使用该依赖项属性的类型</strong>，即判断该类型对象是否支持该属性</li><li><strong><code>validateValueCallback</code>：</strong>详细查看下面的属性验证部分</li></ul><h1 id="添加属性包装器"><a href="#添加属性包装器" class="headerlink" title="添加属性包装器"></a>添加属性包装器</h1><p>在完成定义和注册依赖项属性后，<strong>需要将其包装成普通的属性</strong>，这样可以做到和普通属性一样的调用，即将其包装成传统的<code>.NET</code>属性，这样就完成依赖项属性的最后一步。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty InfoProperty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        InfoProperty = DependencyProperty.Register(<span class="string">&quot;Anfo&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Info),metadata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String Info</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(InfoProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (String)GetValue(InfoProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就以及拥有了一个功能完备的依赖项属性了，可以像使用其他依赖项属性一样使用它。</p><p>另外，需要注意的是，依赖项属性值的确定是根据优先规则来确定的，即使你并没有直接设置它的值，它也可能通过数值绑定，样式等提供获取，也可能是元素树中继承而来。<strong>如果你希望删除本地值设置，像从来没有设置过一样，需要使用另一个继承自<code>DependencyProperty</code>的方法<code>ClearValue()</code>来实现</strong>。</p><h1 id="WPF-使用依赖项属性的方式"><a href="#WPF-使用依赖项属性的方式" class="headerlink" title="WPF 使用依赖项属性的方式"></a>WPF 使用依赖项属性的方式</h1><p>WPF 的许多行为功能都需要使用依赖项属性，所有的功能都是<strong>通过每个依赖项属性都支持的两个关键行为进行工作的——更改通知和动态值识别</strong>。</p><h2 id="更改通知"><a href="#更改通知" class="headerlink" title="更改通知"></a>更改通知</h2><p><strong>即当属性值发生变化时所进行的相关操作</strong>。</p><p><strong>当属性值发生变化时，依赖项属性会触发受保护的名为<code>OnPropertyChangedCallback()</code>的方法，该方法通过了数据绑定和触发器来传递信息，并调用<code>PropertyChangedCallback()</code>回调方法。</strong></p><p>换句话所，当属性发生变化时，如果希望进行响应，有两种选择：</p><ul><li><strong>使用属性值创建绑定</strong></li><li><strong>使用触发器</strong></li></ul><p>但是对于通用方法触发一些代码，WPF 处于性能考虑并没有给出，相反的可以将代码定义在回调函数<code>PropertyChangedCallback()</code>来替代实现。</p><h2 id="动态值识别"><a href="#动态值识别" class="headerlink" title="动态值识别"></a>动态值识别</h2><p><strong>即判定依赖项属性值的赋值问题。</strong></p><p>本质上依赖项属性，依赖于多个对象来获取属性值，每个提供者的优先级不同。WPF 会通过一系列检索，获取最终的属性值，相关检索因素如下（<strong>优先级从低到高</strong>）：</p><ol><li><strong>默认值（即注册依赖项属性的时候<code>FrameworkPropertyMetadata</code>对象定义的初始值）</strong></li><li><strong>继承了原来的值</strong></li><li><strong>来自主题样式的值</strong></li><li><strong>来自项目样式的值</strong></li><li><strong>本地值（通过 XAML 或者 CS代码直接设置的值）</strong></li></ol><p>如上所示，通过设置优先级高的依赖项提供者，来改变依赖项属性的值。</p><blockquote><p>这样做的好处是可以节省内存，；例如：对于一个窗口的多个<code>Button</code>控件，如果每个<code>Button</code>都可以使用主题或者其父级的样式，就可以少存储一份单独的样式值</p></blockquote><p>当然，在进行上述的值确定后，还需要考虑其他的可改变属性值的提供者，总结来说，WPF 确定属性值的步骤如下：</p><ol><li><p><strong>确定基本值（即上面的步骤）</strong></p></li><li><p><strong>如果属性使用的表达式设置，则对表达式进行求值。</strong></p><blockquote><p>WPF 支持两种表达式：<strong>数据绑定和资源</strong></p></blockquote></li><li><p><strong>如果属性是动画的目标，则应用动画</strong></p></li><li><p><strong>运行<code>CoerceValueCallBack</code>回调函数来修正属性值</strong></p></li></ol><h1 id="共享依赖项属性"><a href="#共享依赖项属性" class="headerlink" title="共享依赖项属性"></a>共享依赖项属性</h1><p>尽管一些类具有不同的继承层次，但是可以通过<code>DependencyProperty.AddOwner()</code>来共享同一个依赖项属性。</p><p>代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty SizeProperty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Apple</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SizeProperty = DependencyProperty.Register(<span class="string">&quot;Size&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Apple),metadata);</span><br><span class="line">        TextBlock textBlock = <span class="keyword">new</span> TextBlock();</span><br><span class="line">        Control control = <span class="keyword">new</span> Control();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String Info</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(SizeProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (String)GetValue(SizeProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">static</span> DependencyProperty SizeProperty;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//共享Apple的依赖项属性</span></span><br><span class="line">        SizeProperty = Apple.SizeProperty.AddOwner(<span class="keyword">typeof</span>(Car));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String Size</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(SizeProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (String)GetValue(SizeProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="附加的依赖项属性"><a href="#附加的依赖项属性" class="headerlink" title="附加的依赖项属性"></a>附加的依赖项属性</h1><p><strong>附加属性被应用到的类并非定义附加属性的类</strong>，例如，<code>Grid</code>类定义的<code>Row</code>和<code>Column</code>属性是在其嵌套的元素中应用的。</p><p><strong>定义附加属性，需要使用<code>RegisterAttached()</code>方法</strong>，而不是<code>Register()</code>方法。代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Apple</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册依赖项属性</span></span><br><span class="line">        SizeProperty = DependencyProperty.RegisterAttached(<span class="string">&quot;Size&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Apple),metadata);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与普通依赖属性一样，可以设置其回调函数。</p><p><strong>当创建附加属性时，不需要定义<code>.NET</code>属性封装器，这是因为附加属性可以被用于任何依赖对象</strong>。例如：<code>Grid.Row</code>属性可以被用在任何对象上。</p><p>不使用<code>.NET</code>属性封装器，反而附加属性因为需要满足被所有对象调用，所以<strong>需要两个静态方法来设置和获取属性值，这样来替代属性封装器。</strong>代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetValue</span>(<span class="params">Car car</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">string</span>)car.GetValue(Apple.SizeProperty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params">Car car,<span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    car.SetValue(Apple.SizeProperty,<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然<strong>你也可以通过直接使用<code>GetValue</code>和<code>SetValue</code>方法来绕过这两个静态方法直接获取和设置值</strong>，代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car2.SetValue(Apple.SizeProperty, <span class="string">&quot;这是car2的属性值&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上示例完整<code>CS</code>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> :<span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明附加属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty SizeProperty;</span><br><span class="line"><span class="comment">//初始化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Apple</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置附加属性的相关服务</span></span><br><span class="line">        FrameworkPropertyMetadata metadata = <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="string">&quot;这是默认值哦&quot;</span>);</span><br><span class="line"><span class="comment">//注册附加属性</span></span><br><span class="line">        SizeProperty = DependencyProperty.RegisterAttached(<span class="string">&quot;Size&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(Apple),metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附加属性获取方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetValue</span>(<span class="params">Car car</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">string</span>)car.GetValue(Apple.SizeProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附加属性设置方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params">Car car,<span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        car.SetValue(Apple.SizeProperty,<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//空内容，只是单独表示一个要使用附加属性但自己没定义该附加属性的类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是调用验证附加属性的过程，我采用的是WPF的项目，写在了窗口初始化的事件里面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Window_Initialized</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义两个Car对象</span></span><br><span class="line">    Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">    Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">    <span class="comment">//查看两个对象附加属性的初始值</span></span><br><span class="line">    Console.WriteLine(Apple.GetValue(car1)+ Apple.GetValue(car2));</span><br><span class="line">    <span class="comment">//通过定义的附加属性静态方法设置 car1 对象的附加属性值</span></span><br><span class="line">    Apple.SetValue(car1, <span class="string">&quot;这是car1的属性值&quot;</span>);</span><br><span class="line">    <span class="comment">//查看两个对象现在的附加属性初始值</span></span><br><span class="line">    Console.WriteLine(Apple.GetValue(car1)+ Apple.GetValue(car2));</span><br><span class="line">    <span class="comment">//采用SetValue直接绕过定义的静态方法修改附加属性的值</span></span><br><span class="line">    car2.SetValue(Apple.SizeProperty, <span class="string">&quot;这是car2的属性值&quot;</span>);</span><br><span class="line">    <span class="comment">//查看两个对象的附加属性初始值</span></span><br><span class="line">    Console.WriteLine(Apple.GetValue(car1) + Apple.GetValue(car2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220621123310797.png" alt="image-20220621123310797"  /></p><h1 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h1><p><strong>在定义任何类型的属性的时候，都需要面对错误设置属性的可能性</strong>。对于传统的<code>.NET</code>可以直接在属性设置器中捕获验证这些问题。但是对于依赖项属性来说，它是通过静态方法<code>SetValue</code>来设置的，所以并不适用。</p><p>不过，<strong>WPF 对此提供了两种替代方法来阻止非法值</strong>：</p><ul><li><strong><code>ValidateValueCallback</code>：该回调函数可接受或拒绝新值。</strong>通常，该回调函数用于捕获违反属性约束的明显错误。作为<code>DependencyProperty.Register()</code>方法的一个参数。</li><li><strong><code>CoerceValueCallback</code>：该回调函数可将新值修改为更能被接受的值。</strong>该回调函数通常用于处理为相同对象设置的依赖项属性值相互冲突的问题。这些值本身可能是合法的，但是同时应用时它们时是相互冲突的。作为<code>FrameworkPropertyMetadata</code>对象的参数。</li></ul><p>当应用程序试图更改设置依赖项属性时，如下时这些内容的作用过程：</p><ol><li>首先，<code>CoerceValueCallback</code>方法有机会修改提供的值（通常使提供的值和其他属性值相容，即做一层映射），或者返回<code>DependencyProperty.UnsetValue</code>，来拒绝修改。【强制回调】</li><li>接下来激活<code>ValidateValueCallback</code>方法，该方法返回<code>true</code>接受一个值作为合法值，或者返回<code>false</code>来拒绝值。与上面方法不同的是，<strong>该方法不能访问设置属性的实际对象，这意味着不能检查其他属性</strong>。【验证回调】</li><li>最后，<strong>如果上面两个阶段都成功，则触发<code>PropertyChangedCallback</code></strong>。</li></ol><p>通俗来所，对于需要映射来兼容其他方法参数或者需要对参数进行约束，例如：对于<code>ScrollBar</code>有最大值和最小值，则需要通过<code>CoerceValueCallback</code>方法来判断最大值是否小于最小值做一次冲突验证。而对于<code>Margin</code>属性来说，如果传入参数为<code>-1</code>，则可以通过<code>ValidateValueCallback</code>来验证传入参数是否合法。最后两个都通过了，则触发<code>PropertyChangedCallback</code>。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>如果你只是想使用依赖项属性，则只需要查看如何定义注册使用，比葫芦画瓢即可，如果你想要了解它的工作原理，则需要理解去了解。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> WPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】初识Manim</title>
      <link href="/2022/06/15/Manim/%E5%88%9D%E8%AF%86Manim/"/>
      <url>/2022/06/15/Manim/%E5%88%9D%E8%AF%86Manim/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我了解到<code>Manim</code>是在去年春夏的时候的事情了，当时沉迷于游戏开发，涉及到3D数学方面的知识，然后就找到了<a href="https://space.bilibili.com/88461692/">3blue1brown </a>的相关视频，然后就了解到了他所开发使用的数学动画引擎工具，即<code>Manim</code>。</p><p><strong>前排提醒：学习<code>Manim</code>需要一定的Python基础</strong>。</p><blockquote><p>关于<code>Manim</code>所能实现的数学动画效果可以查看<a href="https://space.bilibili.com/88461692/">3blue1brown </a>的相关视频。</p></blockquote><h1 id="Mainm简述"><a href="#Mainm简述" class="headerlink" title="Mainm简述"></a>Mainm简述</h1><p><em>Manim was originally created by Grant Sanderson as a personal project and for use in his YouTube channel, <a href="https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw">3Blue1Brown</a>. As his channel gained popularity, many grew to like the style of his animations and wanted to use manim for their own projects. However, as manim was only intended for personal use, it was very difficult for other users to install and use it.</em></p><p><em>In late 2019, Grant started working on faster OpenGL rendering in a new branch, known as the shaders branch. In mid-2020, a group of developers forked it into what is now the community edition; this is the version documented on this website. In early 2021, Grant merged the shaders branch back into master, making it the default branch in his repository. The old version is still available as the branch <code>cairo-backend</code>.</em></p><blockquote><p>引用自 Mainm Community 的说明文档</p></blockquote><p>简单概括上面的来说，一开始<a href="https://space.bilibili.com/88461692/">3blue1brown </a>开发并自己使用该工具进行数学科普，随着被人们的了解，在2019年Grant 创建了新的分支来开发更快的 OpenGL 渲染；2020年由另一群开发人员开发了社区版；2021年，Grant 将新分支开发的 OpenGL 渲染分支合并到主分支上，将原来的旧分支仍作为分支<code>cairo-backend</code>。</p><h1 id="Manim版本"><a href="#Manim版本" class="headerlink" title="Manim版本"></a>Manim版本</h1><p>截至我所写本篇文章为止，主要存在三个版本的<code>Manim</code>：</p><ul><li><strong><code>ManimCE</code></strong>：<strong>manim的社区版本</strong>，在<code>pip</code>上被命名为manim</li><li><strong><code>ManimGL</code></strong>：<strong>是 3blue1brown 使用的当前版本的manim，它支持OpenGL的渲染和交互</strong>，并以<code>manimgl</code> pip命名。</li><li><strong><code>ManimCairo</code></strong>：是最初由 3blue1brown 使用的<strong>旧版本 manim</strong>，它在 pip 上不可用。</li></ul><p>某种程度下，更加推荐使用社区版，因为它的开发是为了更加稳定，便捷的方向而开发的；如果你希望使用完全OpenGL支持的可以使用<code>ManimGL</code>；对于老版本的 3blue1brown 的项目渲染使用 <code>ManimCairo</code>。</p><blockquote><p>需要注意的是：本篇是以<code>ManimGL</code>版本为运行版本，Win系统为前提，关于社区版的相关文档可以查看<a href="https://docs.manim.community/en/stable/index.html">Manim Community</a></p></blockquote><p>如果你希望判断，自己所使用的版本，可以尝试通过<strong>在引用文件的不同</strong>来判断：</p><div class="table-container"><table><thead><tr><th>版本</th><th>引用方式</th></tr></thead><tbody><tr><td>ManimCE（社区版）</td><td><code>from manim import *</code></td></tr><tr><td>ManimGL</td><td><code>from manimlib import *</code></td></tr><tr><td>ManimCairo</td><td><code>from manimlib.imports import *</code></td></tr></tbody></table></div><h1 id="ManimGL安装"><a href="#ManimGL安装" class="headerlink" title="ManimGL安装"></a>ManimGL安装</h1><p><strong>ManimGL 需要在 Python 3.7 或者更高版本上运行</strong>。关于其附属配置需求：</p><ul><li><p>安装<a href="https://ffmpeg.org/">FFmpeg</a>，并配置其环境变量到<code>PATH</code>中。</p></li><li><p>OpenGL（包含在python包<code>PyOpenGL</code>中）</p><blockquote><p>OpenGL的安装需要在python包中安装PyOpenGL即可</p></blockquote></li><li><p>安装<a href="https://www.latex-project.org/">LaTeX</a>，如果你的存储空间足够大推荐安装<a href="https://tug.org/texlive/">TexLive-full</a></p></li><li><p>安装<a href="https://git-scm.com/">Git</a></p></li></ul><blockquote><p>关于 LaTex 的相关说明，可以查看<a href="https://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/LaTex%E5%9F%BA%E7%A1%80(%E4%B8%8A">LaTex基础(上)</a>/)</p><p>关于 Git 的相关说明，可以查看 <a href="https://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A">Git与GitHub(上)</a>/)</p></blockquote><p>在完成上面的基础配置后，开始安装 <code>ManimGL</code>，在 Git 上运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/3b1b/manim.git</span><br><span class="line">cd manim</span><br><span class="line">pip install -e .</span><br><span class="line">manimgl example_scenes.py OpeningManimExample</span><br></pre></td></tr></table></figure><p>运行完成上述代码后，会在屏幕上显示如下图像并在几秒后自动关闭，则表示安装成功。</p><p><img src="https://cdn.helloseraphine.top/PicGo/image-20220613212012420.png" alt="image-20220613212012420" style="zoom:50%;" /></p><h1 id="Manim入门"><a href="#Manim入门" class="headerlink" title="Manim入门"></a>Manim入门</h1><h2 id="渲染图片"><a href="#渲染图片" class="headerlink" title="渲染图片"></a>渲染图片</h2><p>在完成上面的安装配置后，开始制作第一个入门场景。</p><p>首先<strong>在 Git 克隆的目录下创建新的 <code>.py</code> 文件</strong>，命名可以随意，例如：<code>start.py</code>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220615152502000.png" alt="image-20220615152502000" style="zoom: 67%;" /></p><p>然后在该文件下，粘贴如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 Manimlib 所有类</span></span><br><span class="line"><span class="keyword">from</span> manimlib <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Scene 的子类 SquareToCircle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareToCircle</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="comment"># 编写 construct 方法，这里面的内容将决定如何创建渲染画面</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个圆(Circle实例)</span></span><br><span class="line">        circle = Circle()</span><br><span class="line">        <span class="comment"># 将该圆填充为蓝色，透明度为50%</span></span><br><span class="line">        circle.set_fill(BLUE, opacity=<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 将该圆的线条设为深蓝色，线条宽度为4</span></span><br><span class="line">        circle.set_stroke(BLUE_E, width=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过 Scene 的 add() 方法，将这个圆绘制到画面上</span></span><br><span class="line">        self.add(circle)</span><br></pre></td></tr></table></figure><p>然后在控制台中运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle</span><br></pre></td></tr></table></figure><blockquote><p>注：控制台需要导航到刚刚所创建的 <code>.py</code> 文件目录下</p></blockquote><p>在运行如上命令后，会在屏幕的左上角弹出一个窗口，可以通过如下操作来进行相关操控：</p><ul><li>滚动鼠标中键（滚轮）实现<strong>上下移动画面</strong></li><li>按住键盘上<code>Z</code>键同时滚动鼠标中键来<strong>缩放画面</strong></li><li>按住键盘上<code>S</code>键同时移动鼠标来<strong>平移画面</strong></li><li>按住键盘上<code>D</code>键同时移动鼠标来<strong>改变三维视角</strong></li><li>按下键盘上<code>ESC</code>键来<strong>退出窗口</strong></li></ul><blockquote><p>注：如上操作需要在英文输入法下进行</p></blockquote><p>退出窗口后，再运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle -os</span><br></pre></td></tr></table></figure><p>运行命令后，等待程序运行完成后，会自动打开渲染后得到的图片（默认位于同级目录的子目录 <code>images/</code> 中）：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220615153452204.png" alt="image-20220615153452204" style="zoom: 50%;" /></p><h2 id="渲染动画"><a href="#渲染动画" class="headerlink" title="渲染动画"></a>渲染动画</h2><p>现在，对上面的代码进行部分改动来实现渲染动画：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> manimlib <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareToCircle</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br><span class="line">        circle = Circle()</span><br><span class="line">        circle.set_fill(BLUE, opacity=<span class="number">0.5</span>)</span><br><span class="line">        circle.set_stroke(BLUE_E, width=<span class="number">4</span>)</span><br><span class="line">        square = Square()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过 Scene 的 play() 方法播放了一个动画，ShowCreation 是呈现创建给出物体的动画过程。 </span></span><br><span class="line">        <span class="comment"># self.play(ShowCreation(square)) 即播放创建 square 的动画。</span></span><br><span class="line">        self.play(ShowCreation(square))</span><br><span class="line">        <span class="comment"># 通过 Scene 的 wait() 方法来停顿（默认1s）</span></span><br><span class="line">        self.wait()</span><br><span class="line">        <span class="comment"># 播放将 square 变化为 circle 的动画。</span></span><br><span class="line">        self.play(ReplacementTransform(square, circle))</span><br><span class="line">        <span class="comment"># 通过 Scene 的 wait() 方法来停顿（默认1s）</span></span><br><span class="line">        self.wait()</span><br></pre></td></tr></table></figure><p>这次运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle</span><br></pre></td></tr></table></figure><p>弹出的窗口会播放如下动画，如果想要保存这段动画，则运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl start.py SquareToCircle -ow</span><br></pre></td></tr></table></figure><p>同样的，不会再弹出窗口，等待程序运行完成后会自动打开该视频文件（默认存放在与 <code>start.py</code> 同级的 <code>videos/</code> 文件夹中）：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/SquareToCircle.mp4" width="100%"></video><blockquote><p>如果你的渲染后的动画效果只有后半截变成圆形的动画，丢失了前半截的动画，则查看BUG说明部分</p></blockquote><h1 id="启用交互"><a href="#启用交互" class="headerlink" title="启用交互"></a>启用交互</h1><p>支持交互是新版本的新特性，可以在代码的末尾加上如下一行来启用交互：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.embed()</span><br></pre></td></tr></table></figure><p>这时再执行 <code>manimgl start.py SquareToCircle</code>。</p><p>在前面的动画执行后，将会在命令行打开 iPython 终端。<strong>这时你将不能触碰动画窗口，而只能在终端中输入要运行的代码， 如果要和动画窗口进行互动，则要在终端中输入 <code>touch()</code> 或 <code>self.interact()</code></strong>。</p><p>如果你想要直接进入交互模式的话， 你可以直接运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manimgl</span><br></pre></td></tr></table></figure><h1 id="BUG说明"><a href="#BUG说明" class="headerlink" title="BUG说明"></a>BUG说明</h1><p><strong>如果出现了渲染丢失的问题，请将 Python 程序的显卡调用设置为独显调用，集成显卡会出现不可预知的错误。</strong></p><blockquote><p>此处以 NVIDIA 为示例</p></blockquote><ul><li><p><strong>进入 NVIDIA 的程序【控制面板】，选择【程序设置】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220615161459190.png" alt="image-20220615161459190" style="zoom: 60%;" /></p></li><li><p><strong>选择 Python 程序，为该程序首选独立显卡，最后应用即可</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220615161616293.png" alt="image-20220615161616293" style="zoom: 67%;" /></p></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到这里，就已经完成了 Manim的安装和基本处理过程的上手体验，后面将会开始正式的 Manim 的制作。</p>]]></content>
      
      
      <categories>
          
          <category> Manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manim </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo入门（下）</title>
      <link href="/2022/06/04/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/06/04/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分将着手Hexo的一些基本的配置和使用方面，关于Hexo的部署部分可以参考我的上篇文章。</p><h1 id="Hexo文件目录"><a href="#Hexo文件目录" class="headerlink" title="Hexo文件目录"></a>Hexo文件目录</h1><p>Hexo的安装/初始化目录如下图所示，可能部分文件存在不同，不需要担心，<strong>只需要关心我框出来的红色的文件部分</strong>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220604161631343.png" alt="image-20220604161631343" style="zoom:80%;" /></p><div class="table-container"><table><thead><tr><th>文件/文件夹名</th><th>说明</th></tr></thead><tbody><tr><td><code>public</code></td><td>我们最后生成的静态博客<code>.html</code>文件会在该目录下存在，如果你并为生成或者使用了<code>hexo clean</code>命令，则该文件夹不存在</td></tr><tr><td><code>scaffolds</code></td><td>模板文件夹，里面存在我们创建文章，分类等初始化的默认内容</td></tr><tr><td><code>source</code></td><td>文章以及一些主要内容的文件夹，该文件夹下的内容会被全部拷贝到生成的<code>public</code>文件夹里</td></tr><tr><td><code>themes</code></td><td>主题文件夹，我们下载使用的主题需要导入到该文件夹中，通过在该文件夹下创建命名为主题名称的文件夹即可</td></tr><tr><td><code>_config.yml</code></td><td>Hexo的配置文件</td></tr></tbody></table></div><blockquote><p>注：Hexo的配置文件和主题的配置文件不要混淆，如果你使用别人的主题则会存在一个对应的主题的配置文件</p></blockquote><h1 id="配置文件参数"><a href="#配置文件参数" class="headerlink" title="配置文件参数"></a>配置文件参数</h1><blockquote><p><strong>yaml文件的参数填写时一定要在<code>:</code>后加一个空格，再填写参数</strong></p></blockquote><p>在了解了Hexo 的文件目录后，我对一些常见的配置文件参数进行说明，以供参考。</p><h2 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h2><p>Site部分主要是网站一些基本说明参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site 【网站设置】</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这是一个主标题</span> <span class="comment">#【网站主标题】就是网站最上面标签上的文字</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;这是一个子标题&#x27;</span> <span class="comment">#【子标题】跟在主标题后面</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;这是一句描述&#x27;</span> <span class="comment">#【网站描述】不同主题可能会呈现位置效果不同</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment">#【网站关键词】如果希望百度等搜索引擎收录网站，可以设置自己网站的关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">我是作者名字</span> <span class="comment">#【作者名称】一般文章结束说明以及最后的版权归属会使用该名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#【网站语言】可以选择简体（zh-CN），繁体（zh-tw），英文（en）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> <span class="comment">#【时区】网站时间，如果是中国，则使用左边的参数即可</span></span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL部分参数的设置，涉及到Hexo最后部署后的呈现成功与否，参数说明如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://www.baidu.com/</span> <span class="comment">#【访问网站的网址】</span></span><br><span class="line"><span class="attr">root:</span> <span class="comment">#【根目录位置】</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><p><strong>如果你部署到GitHub上，则<code>url</code>的参数填写，GitHub提供的地址，<code>root</code>参数填写你的仓库名称，例如：<code>/仓库名称</code>；如果你使用了自定义的域名，则需要将这里<code>url</code>的参数改为你的自定义域名，<code>root</code>参数为空即可（前提是你的网站初始<code>index.html</code>文件就在仓库下，而不是被文件夹嵌套在里面）</strong>。</p><blockquote><p><strong>如果上述参数设置不正确，则会出现访问网站只有内容，而丢失样式</strong>，即排版不正常的情况出现</p></blockquote><h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><p><strong>Directory规定了相关文件生成/获取的路径</strong>，我们可以通过修改其参数来指定相关文件生成的目录，而不是默认的hexo安装目录下，参数说明如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">D:\DATA\TyporaMd\z_hexo_source</span> <span class="comment">#【数据源文件夹】你可以理解为你写文章的目录，默认为Source，此处我将它自定义到如上参数路径下，则在编译生成网站静态文件的时候就会从我指定目录下获取数据编译</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure><h2 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h2><p><strong>theme参数主要是指定网站的主题</strong>，传入主题名称即可，前提是网站主题已经导入到主题文件夹下，且和主题文件夹同名。参数说明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span> <span class="comment">#【主题的名称】</span></span><br></pre></td></tr></table></figure><h1 id="插件和主题的配置"><a href="#插件和主题的配置" class="headerlink" title="插件和主题的配置"></a>插件和主题的配置</h1><p>插件和主题的配置，可以在后面熟悉上手之后进行配置，可以选择不配置使用默认主题。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>网站的美化可以使用别人已经开发的主题来快速实现，主题可以通过Hexo官网获取<a href="https://hexo.io/zh-cn/">Hexo官网</a>，或者从Github，百度等其他渠道获取使用。</p><p>主题的下载安装可以根据主题的说明文档来，<strong>需要注意的是，主题需要在Hexo指定的主题文件夹下存放，且每个主题都需要是一个文件夹</strong>。</p><p>关于主题配置的实例，可以参考本站，本站使用的是<code>buttfly</code>主题，<a href="https://butterfly.js.org/posts/21cfbf15/">主题地址</a>，希望大家可以给源作者一个Star支持一下。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件也同理，找到需要的插件，查看插件的文档，对插件进行相关配置。</p><p>插件的使用，本站使用了如下插件：</p><ol><li>本地搜索感谢 <mark class="hl-label green">hexo-generator-search</mark>  提供支持</li><li>评论系统感谢 <mark class="hl-label green">waline</mark>  提供支持</li><li>网站统计感谢 <mark class="hl-label green">百度统计</mark>  提供支持</li><li>数学公式感谢 <mark class="hl-label green">mathjax</mark>  提供支持</li><li>番剧列表感谢 <mark class="hl-label green">hexo-bilibili-bangumi</mark>  提供支持</li><li>视频插件感谢 <mark class="hl-label green">hexo-tag-mmedia</mark>  提供支持</li><li>文章自动分类感谢 <mark class="hl-label green">hexo-auto-category</mark>  提供支持</li><li>游戏展示感谢 <mark class="hl-label green">hexo-steam-games</mark>  提供支持</li><li>电影书籍音乐展示感谢 <mark class="hl-label green">HEXO-DOUBAN-CARD</mark>  提供支持</li></ol><h1 id="文章编写和发布"><a href="#文章编写和发布" class="headerlink" title="文章编写和发布"></a>文章编写和发布</h1><p><em>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件</em></p><p>如上引用自Hexo官方说明，Hexo默认安装了<code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，所以<strong>默认支持使用<code>Markdown</code>进行写作</strong>，此处也使用<code>Markdown</code>写作来实例。</p><p>可以使用如下命令来创建一篇新文章：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一篇名称为 测试 的文章</span></span><br><span class="line">hexo new post 测试</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为layout默认为post，所以上述命令可以简写为</span></span><br><span class="line">hexo new 测试</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一篇名称为 测试 的草稿</span></span><br><span class="line">hexo new draft 测试</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一页名称为 测试 的独立页面</span></span><br><span class="line">hexo new page 测试</span><br></pre></td></tr></table></figure><p>例如，<strong>使用命令<code>hexo new 测试</code>，可以发现在<code>source</code>文件夹下，里的<code>_post</code>文件夹里生成了一个名称为<code>测试</code>的<code>.md</code>文件，该<code>.md</code>文件就可以直接使用<code>Markdown</code>语法来书写文章</strong>。</p><blockquote><p>如果你自定义了<code>source</code>文件夹的位置，则生成在自定义的<code>source</code>文件夹下<code>_post</code>文件夹里</p></blockquote><p>当你打开生成 的<code>测试.md</code>文件后，会发现它默认文件中生成了一部分<code>yaml</code>内容，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">测试</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-06-04 18:02:30</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>当然，你生成的文件中的内容或许没这么多，一般会有<code>title</code>，<code>tags</code>等参数，其他的参数是我通过修改模板文件来实现，生成新文章的时候自动预先生成相关参数。<strong>这些参数是对本篇文章的参数，它可以设置本篇文章的标题，文章标签，文章分类，文章封面图片，文章描述等等的参数。当然你也可以选择不填写这些参数，可以为空（标题除外）</strong>。</p><blockquote><p>关于模板文件可以查看下面的部分，此处不做过多赘述</p></blockquote><p>然后在上面<code>yaml</code>参数的下面，开始使用<code>Markdown</code>语法写我们的文章，现在使用如下内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一个一级标题</span></span><br><span class="line"><span class="section">## 这是一个二级标题</span></span><br><span class="line"><span class="section">### 这是一个三级标题</span></span><br><span class="line"><span class="section">#### 这是一个四级标题</span></span><br><span class="line"><span class="bullet">*</span> 这是一个无序序号</span><br><span class="line"><span class="bullet">*</span> 这也是一个无序序号</span><br><span class="line"><span class="bullet">*</span> 这也是一个无序序号</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 这是一个引用说明</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**这是黑体**</span></span><br><span class="line"><span class="emphasis">*这是斜体*</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 这是有序序号</span><br><span class="line"><span class="bullet">1.</span> 这也是有序序号</span><br><span class="line"><span class="bullet">1.</span> 这还是有序序号</span><br><span class="line"></span><br><span class="line">这是一个代码块</span><br><span class="line"><span class="code">```c</span></span><br><span class="line"><span class="code">printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">这是一个行内代码`</span><br></pre></td></tr></table></figure><p>将上述内容保存后，就可以<strong>使用如下命令实现文章编译</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>如果你之前已经编译过了，生成新文章或者重新编译的时候，我们一般<strong>使用如下命令清除之前的编译文件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令清除public文件夹，即删除所有已编译过的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后让Hexo重新编译新的静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者你可以使用 &amp; 符号来链接两个命令</span></span><br><span class="line">hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><p>上述执行<code>hexo g</code>编译完成后，如果没有报错，则可以<strong>使用如下命令来本地查看编译效果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然你也可以简写为</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>在本地查看效果无误后，<strong>使用如下命令推送到远程的GitHub仓库，来实现文章的更新</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>完成以上操作，则完成了文章的编写和推送更新发布，<strong>简述来说通过<code>hexo new 文章名称</code>创建文章文件，编写文章文件内容的，保存后，使用<code>hexo g</code>将其编译为静态文件，如果之前已经编译过一遍，一般通过使用<code>hexo clean</code>将之前编译的文件删除，再执行<code>hexo g</code>编译一份新的静态文件，然后使用<code>hexo s</code>来本地查看效果，使用<code>hexo d</code>将新编译的静态文件推送到远程仓库，这样就实现文章的更新</strong>。</p><h1 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h1><p>在前面的Hexo文件目录中说明了模板文件的位置，在Hexo安装目录下的<code>scaffolds</code>文件夹下，里面会存在三个文件，如下说明，通过修改这三个文件的<code>yaml</code>内容部分，这样生成的相关类别的文章会默认包含该参数内容。</p><div class="table-container"><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td><code>draft.md</code></td><td>草稿文件的模板</td></tr><tr><td><code>page.md</code></td><td>独立页面的模板</td></tr><tr><td><code>psot.md</code></td><td>一般文章的模板</td></tr></tbody></table></div><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="文章标签和分类"><a href="#文章标签和分类" class="headerlink" title="文章标签和分类"></a>文章标签和分类</h2><p>前面说明了，文章创建的时候自带的<code>yaml</code>参数可以修改其文章的属性，其中有一个给文章分类的参数，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">测试</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这是一个标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这又是一个标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这还是一个标签</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这是一个分类</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">这是一个子分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-06-04 18:02:30</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># 如果你希望文章可以属于好几个类别，而不是主分类-子分类，则使用如下参数</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">这是一个分类</span>,<span class="string">这是一个子分类</span>]</span><br></pre></td></tr></table></figure><h2 id="GitHub使用自定义域名"><a href="#GitHub使用自定义域名" class="headerlink" title="GitHub使用自定义域名"></a>GitHub使用自定义域名</h2><p>如果你希望使用自定义域名来访问自己在GitHub上部署的网站，则可以在GitHub Page下，填写自己的自定义域名，然后解析到GitHub上，需要注意的是，<strong>在你添加自定义域名的时候，会在你的仓库下创建一个<code>CNAME</code>的文件，该文件只有一行内容，就是你的自定义域名</strong>。</p><p><strong>因为每次使用<code>hexo d</code>上传到仓库文件的时候，Hexo的解决办法是将本地<code>public</code>文件夹下的文件去覆盖GitHub仓库，那就意味着你的<code>CNAME</code>文件将会被覆盖消失，那么你配置的自定义域名就会失效。</strong></p><p><strong>你可以通过将<code>CNAME</code>文件创建在你本地的<code>source</code>文件夹下，则再每次使用<code>hexo g</code>编译的时候，<code>source</code>文件夹下的内容都会复制到<code>public</code>文件夹里，这样上传到GitHub上进行覆盖的时候就始终存在<code>CNAME</code>文件。</strong></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>经过[[技术杂谈/Hexo入门（上）|Hexo入门（上）]]和Hexo入门（下）后就可以完全自主的使用Hexo来编写和更新自己的文章了，关于本站的Hexo主题使用说明和插件说明，为了防止我自己忘记，我会写一篇备忘录来记录，内容来源是原主题/插件开发者的说明文档。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo入门（上）</title>
      <link href="/2022/06/04/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/06/04/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我第二次给网站装修的时候，曾经考虑过使用<code>Hexo</code>，不过那个时候看到人家好看的模板需要一定的网页基础，遂就放弃了，随着我今天发现我的网站似乎<code>CSS</code>的<code>CDN</code>服务停止了，遂打算用<code>Hexo+Github+COS</code>来完成网站的布置和搬迁，这样一来可以剩下一笔费用，而且因为<code>Hexo</code>是纯静态的，所以加载速度也会很快。</p><p>以此文章记录和帮助需要帮助的伙伴。</p><h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo是一个轻量级的博客框架，它是通过生成静态网页来实现网站的建设，因为是<code>HTML</code>形式，所以它的访问速度是很快的，关于<code>Hexo</code>网站可以通过点击访问<a href="https://hexo.io/zh-cn/">Hexo官网</a>。</p><h1 id="Hexo的搭建"><a href="#Hexo的搭建" class="headerlink" title="Hexo的搭建"></a>Hexo的搭建</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>Hexo需要在电脑上安装<code>Node.JS</code>和<code>Git</code></strong>，如果你已经安装了这两个环境，则可以跳过这部分，直接到<code>Hexo</code>的部署。<strong>此处安装示例环境为<code>Windows</code>环境</strong>，其他系统请自行参考别的文章。</p><ul><li><a href="http://nodejs.org/">点我访问<code>Node.JS</code>官网</a>，进入官网下载符合自己平台的软件，<strong>版本建议使用<code>12.0</code>及以上的版本，可以无脑最新版</strong>。</li><li><a href="http://git-scm.com/">点我访问<code>Git</code>官网</a>，关于<code>Git</code>的安装和使用可以参考我这篇文章<a href="https://www.helloseraphine.top/index.php/archives/431.html">Git与GitHub(上)</a>，此处不过多赘述</li></ul><blockquote><p><strong>如果以上官网无法访问，可以尝试科学上网或者寻找其他镜像途径</strong></p></blockquote><p>在安装结束后，可以<strong>通过如下<code>CMD</code>命令来验证是否安装成功</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证Node.JS的版本</span></span><br><span class="line">node --version</span><br></pre></td></tr></table></figure><p>如果返回的是一串版本号，例如<code>18.1.0</code>，则证明安装成功。</p><p>在完成了上面的基础环境安装，使用如下代码安装<code>Hexo</code>，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>在完成如上准备后，就可以正式开启Hexo博客之路。</p><h2 id="建站预览"><a href="#建站预览" class="headerlink" title="建站预览"></a>建站预览</h2><p>现在<strong>寻找一个文件位置来存放<code>Hexo</code>网站相关根文件</strong>，使用如下代码来完成初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><blockquote><p>注：执行上述代码前，<strong>需要确保当前目录为安装根文件目录</strong>；如果不是，则使用<code>cd</code>命令切换至对应目录</p></blockquote><p>完成<code>Hexo</code>的初始化后，可以看到在对应的目录下，会生成如下的相关文件：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220519104258168.png" alt="image-20220519104258168" style="zoom:80%;" /></p><p><strong>如果初始化失败，则删除对应目录下的文件，切换网络重新执行如上命令</strong>即可。</p><p>初始化完成后，<strong>使用如下代码来在本地开一个端口</strong>，查看建站效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>如果命令执行报错，返回的错误是找不到命令之类的，需要在<code>Hexo</code>的根目录下使用该命令，或者你也可以将<code>安装目录\Hexo\node_modules\.bin</code>添加到环境变量中，关于如何设置环境变量，可以查看我的这篇文章<a href="https://www.helloseraphine.top/index.php/archives/476.html">环境变量那些事</a></p></blockquote><p>执行命令后，会<strong>显示一个访问地址，复制到浏览器上即可查看预览效果</strong>，如下图所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220519104626862.png" alt="image-20220519104626862" style="zoom: 67%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220519104737970.png" alt="image-20220519104737970" style="zoom: 45%;" /></p><p>按下<code>Ctrl+C</code>即可停止本地端口占用，即关闭了网站的访问预览。</p><p><strong>如果预览网站报错了，则尝试如下解决办法：</strong></p><ul><li><strong>有进程占用了默认4000端口，可以使用命令<code>hexo s -p 5000</code></strong></li><li><strong>或者是因为你的电脑没有配置<code>IIS</code>，可以通过【打开控制面板】，选择【程序和功能】，选择【打开或关闭Windows功能】，找到【Internet information services】选中即可。</strong></li></ul><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>可以通过官方的主题页面选择自己喜欢的主题（如果你不想自己开发的话），<a href="https://hexo.io/themes/">Hexo主题(点击访问)</a>，或者从<code>GitHub</code>等途径自行寻找相关主题，然后根据主题的要求来安装和使用主题。</p><p>需要注意的是：<strong>安装主题需要在<code>Hexo</code>根目录下，即<code>themes</code>里创建相关主题的文件夹即可</strong>。</p><p>主题配置完成后，可以使用上面的命令<code>Hexo s</code>来启动预览网站。</p><h1 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h1><p><code>Hexo</code>因为是生成的静态页面，所以可以部署在很多地方，例如：<code>Github</code> ，<code>Gitee</code>，相关对象存储或者服务器上，<strong>此处仅示例如何部署在：GitHub和腾讯云的COS上</strong></p><h2 id="部署到GitHubPages"><a href="#部署到GitHubPages" class="headerlink" title="部署到GitHubPages"></a>部署到GitHubPages</h2><blockquote><p>关于Git和GitHub的基本使用，可以参考<a href="https://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A">Git与GitHub(上)</a>/)</p></blockquote><p>Hexo为 GitHub Pages 的部署提供了便利的部署方式，可以通过下面的命令来实现部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者简写为</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><strong>在使用该命令部署到GitHub页面之前，需要</strong>我们<strong>在Hexo的配置文件</strong>中，<strong>提供一些必要的参数</strong>。</p><h3 id="添加配置文件参数"><a href="#添加配置文件参数" class="headerlink" title="添加配置文件参数"></a>添加配置文件参数</h3><p><strong>Hexo 的配置文件在安装/初始化目录下，名称为<code>_config.yml</code></strong>，打开文件找到如下部分：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220604152435494.png" alt="image-20220604152435494" style="zoom: 80%;" /></p><ul><li><strong><code>type</code>：在本方法下，填写<code>git</code></strong></li><li><strong><code>repo</code>：你所存放网页的Github仓库地址</strong></li><li><strong><code>branch</code>：分支名称，如果不懂的话填<code>main</code>即可</strong></li><li><strong><code>token</code>：访问GitHub账户的令牌，它可以验证是否有权限操作仓库</strong></li></ul><p>如上前三个参数，可以快速填写，我们需要填写第四个<code>token</code>参数，才能实现上传前的设置。</p><h3 id="token的获取"><a href="#token的获取" class="headerlink" title="token的获取"></a>token的获取</h3><ol><li><p>进入【个人账户的设置】中</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220604153054210.png" alt="image-20220604153054210" style="zoom:50%;" /></p></li><li><p>在页面的<strong>最下面找到并【选择<code>Developer settings</code>(开发者选项)】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220604153219875.png" alt="image-20220604153219875" style="zoom: 67%;" /></p></li><li><p>在新的页面找到并<strong>【选择<code>Personal access tokens</code>(个人访问令牌)】，然后【选择<code>Generate new token</code>(生成新令牌)】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220604153458147.png" alt="image-20220604153458147" style="zoom:80%;" /></p></li><li><p>在创建<code>token</code>的页面中<strong>，<code>Note(名称)</code>可以随便填，<code>Expiration(令牌期限)</code>可以选择<code>no expiration（不限制期限）</code>，下面的<code>Select scopes（权限范围）</code>全选即可。</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220604153920416.png" alt="image-20220604153920416" style="zoom: 67%;" /></p></li><li><p>最后<strong>【点击<code>Generate token</code>】就创建好<code>token</code>了，然后【复制给出的<code>token</code>值】，【填写到配置文件】中<code>token:</code>的部分</strong>就完成了部署前的配置。</p></li></ol><p>这个时候可以通过<strong>使用<code>hexo d</code>命令来测试</strong>上传部署到指定的GitHub仓库是否正常，<strong>如果最后反馈一行<code>INFO  Deploy done: git</code>，则表示上传部署成功</strong>。</p><h2 id="部署到腾讯云COS"><a href="#部署到腾讯云COS" class="headerlink" title="部署到腾讯云COS"></a>部署到腾讯云COS</h2><blockquote><p>感兴趣但是不了解的COS的可以查看这篇文章<a href="https://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%EF%BC%9F">关于网站搭建那些事（下）</a></p></blockquote><p>官方并没有对腾讯云的COS（对象存储）做直接的配置，所以我们需要下载其他开发者的插件，此处<strong>使用<code>hexo-deployer-cos</code>，项目地址[hexo-deployer-cos</strong>](<a href="https://github.com/sdlzhd/hexo-deployer-cos)，如果对你有帮助，可以给插件开发者点个`Star`。">https://github.com/sdlzhd/hexo-deployer-cos)，如果对你有帮助，可以给插件开发者点个`Star`。</a></p><p>在hexo安装的目录下，使用如下命令进行插件的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-cos --save</span><br></pre></td></tr></table></figure><p>安装成功后，在hexo 的配置文件中，添加如下部分内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">cos</span></span><br><span class="line">  <span class="attr">secretId:</span> <span class="string">yourSecretId</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">yourSecretKey</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">yourBucket</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">yourRegion</span></span><br></pre></td></tr></table></figure><p>关于上述的<code>secretID</code>等参数可以在创建COS存储桶的时候获取到，COS的创建可以访问<a href="https://cloud.tencent.com/product/cos">对象存储COS</a>来创建，关于COS的更多说明和处理，参见<a href="https://www.helloseraphine.top/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%EF%BC%9F">关于网站搭建那些事（下）</a>。</p><blockquote><p>注：对象存储是需要对存储空间和访问流量进行收费的</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>如上就完成了Hexo 的基本部署，以后如果你的博客更新都需要通过<code>hexo d</code>的命令来实现。</p><p>关于Hexo的文章更新，文章编写，插件，主题等配置可以参见<a href="https://www.helloseraphine.top/2022/06/04/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Hexo%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/">Hexo入门（下）</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-1.0】概要</title>
      <link href="/2022/05/23/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-1-0%E3%80%91%E6%A6%82%E8%A6%81/"/>
      <url>/2022/05/23/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-1-0%E3%80%91%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h1><p>关于R语言的一些入门基本操作和一些基础要点，已经在我的博客R语言栏目下发布过相关文章，文章导航：</p><ul><li><a href="https://helloseraphine.top/index.php/archives/76.html">【1.1】R语言入门</a></li><li><a href="https://helloseraphine.top/index.php/archives/99.html">【1.2】R基础语法</a></li><li><a href="https://helloseraphine.top/index.php/archives/104.html">【1.3】R基础运算</a></li><li><a href="https://helloseraphine.top/index.php/archives/115.html">【1.4】R数据类型</a></li><li><a href="https://helloseraphine.top/index.php/archives/145.html">【1.5】R逻辑语句</a></li><li><a href="https://helloseraphine.top/index.php/archives/146.html">【1.6】函数</a></li><li><a href="https://helloseraphine.top/index.php/archives/148.html">【1.7】R包</a></li></ul><p>以及IDE相关操作指南的文章导航：</p><ul><li><a href="https://helloseraphine.top/index.php/archives/126.html">RStudio IDE使用指南</a></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>因为下学期有R语言这门课程，所以我新开 NEW 部分的文章，作为新的笔记和相关文档说明，NEW系列的文章会更加偏向于实战部分，简单来说就是应用方面，而之前的笔记文章是偏向于概念上手方面。</p><p>关于 NEW 系列文章的说明如上所述，本文已经水完了（雾</p><p>下面推荐一首歌，出自迪士尼《后裔》系列，属于音乐剧：表现的是一对恋人其中一位对两者关系认知的纠结，表现她复杂的心理情绪。自行欣赏吧！！！</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/Snipaste_2022-02-20_23-08-14.jpg" alt="image-20220207233254612" style="zoom:100%;" /></p>]]></content>
      
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界毁灭后</title>
      <link href="/2022/05/23/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E4%B8%96%E7%95%8C%E6%AF%81%E7%81%AD%E5%90%8E/"/>
      <url>/2022/05/23/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E4%B8%96%E7%95%8C%E6%AF%81%E7%81%AD%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前打算把我鸽了很久的第一次游戏开发的Demo弄出来，不过实在懒得弄了，在昨天我们的一个小伙伴给我们分享了一个b站up的视频，<a href="https://www.bilibili.com/video/BV1Lu41117qM?spm_id_from=pageDriver">【互动游戏】世界毁灭一千年后，你能否重新拯救世界？</a>，我觉得这个视频很不错，就顺手做了这个游戏的Demo，下面是演示视频：</p><blockquote><p>前排提醒：全部素材和版权是原作者，即<a href="https://space.bilibili.com/29120845">清竹莫叶</a></p></blockquote><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_Video/GameDemo/game.mp4" width="100%"></video><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后附上游戏源码，以及本文PDF链接。</p><p>如果感兴趣的话，可以给我的项目<code>star</code>一下，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我的Unity自述</title>
      <link href="/2022/05/23/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/"/>
      <url>/2022/05/23/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>依次纪念我大学追求游戏开发的自己</strong>，我记得大概是20年10月份吧或者11月份，我正式开始了Unity的学习，我的游戏开发结束于21年暑假结束，在大三上，在我掌握并开发了一定的Unity游戏开发后，去学习了桌面软件开发，并且掌握了Winform和WPF开发技术，其中还有许多其他方面的东西。</p><h1 id="关于我如何自学的自述"><a href="#关于我如何自学的自述" class="headerlink" title="关于我如何自学的自述"></a>关于我如何自学的自述</h1><p>当然这一切都归功于Unity在学习游戏开发的过程中，我接触到了很多其他的东西，我看过很多教程，目前总结出来的自学流程：对于想要的学习的东西通过网络上查询了解概况，逞钱的伙伴可以直接买相关书籍，或者为了省钱的可以去学校图书馆借书，我很喜欢我们学校的图书馆，我曾经最多借书超过20本未还，当然借书多不代表能看得完，有些是需要长期来学习的，有些是短期来学习的，书籍是真的很好的东西，其次是教学视频，很多情况下我目前个人建议是不要过分依赖视频，视频教学可以让我们快速上手，但是对于教学内容来说全看视频制作者想讲什么或者视频制作者的见识，存在一定的局限性，综述来说：书籍 &gt; 网络上的教学视频，然后就是跟着做，在学的时候要记笔记，我从一开始使用微软的<code>OneNote</code>笔记到后来的<code>Markdown</code>语法笔记，例如：<code>Vnote</code>，<code>VsCode</code>再到现在的<code>Typora</code>。</p><p>如下是我笔记相关截图</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220206153904331.png" alt="image-20220206153904331" style="zoom:67%;" /></p><p>在学习完成相关书籍和教程后，认为自己可以了，就做一个相关的作品出来，如果相关的作品可以做出来就说明基本入门了，可以继续深入了，证明了你已经学会了基本的操作。对我而言这种方法是很不错的，因人而异吧。</p><p>如下是我学习Unity的时候笔记截图</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220206154152195.png" alt="image-20220206154152195" style="zoom:67%;" /></p><p><strong>现在我个人的学习习惯就是：看书 +记笔记 + 教学视频 + 各种查询 和 问问题，最后做出一个相关的作品</strong>。</p><h1 id="关于我开发过的游戏"><a href="#关于我开发过的游戏" class="headerlink" title="关于我开发过的游戏"></a>关于我开发过的游戏</h1><p>我曾经尝试开发过许多东西，大多数开发一半就弃坑了，或者其他原因，还有一些小东西忘记了。</p><h2 id="第一个游戏Demo"><a href="#第一个游戏Demo" class="headerlink" title="第一个游戏Demo"></a>第一个游戏Demo</h2><p>我记得我第一个开发的游戏Demo是一个简单小球吃食物的Deno，相关文章后面会更新，可以自行查看，这个已经没有留存相关文件和视频了，暂时跳过了。</p><blockquote><p>此处，欠第一个开发的游戏Demo</p></blockquote><h2 id="合成大西瓜Demo"><a href="#合成大西瓜Demo" class="headerlink" title="合成大西瓜Demo"></a>合成大西瓜Demo</h2><p>后面是一个合成大西瓜的游戏，那个时候我记得刚刚流行这个游戏，我就用Unity复刻了一下，如下是我唯一一个留存的视频，当时是出现了一个BUG记录了下来：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/%E5%90%88%E6%88%90%E5%A4%A7%E8%A5%BF%E7%93%9C.mp4" width="100%"></video><h2 id="3D跑酷游戏Demo"><a href="#3D跑酷游戏Demo" class="headerlink" title="3D跑酷游戏Demo"></a>3D跑酷游戏Demo</h2><p>后面做了一个跑酷游戏Demo，相关留存视频如下：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/%E8%B7%91%E9%85%B7%E6%B8%B8%E6%88%8F.mp4" width="100%"></video><h2 id="2D横版像素闯关游戏Demo"><a href="#2D横版像素闯关游戏Demo" class="headerlink" title="2D横版像素闯关游戏Demo"></a>2D横版像素闯关游戏Demo</h2><p>再后面是一个2D像素闯关的游戏Demo，类似于小时候4399那种游戏，当时的游戏背景很简单，公主被恶龙抓走了，勇者一路经过种种磨难，拯救公主的游戏闯关游戏，这个游戏我留存了部分源代码素材和相关的开发视频：</p><p>这一个视频是我开发刚刚实现UI界面和游戏人物相关控制的视频：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_1.mp4" width="100%"></video><p>这个是新增了部分动画，游戏向导以及部分优化的视频：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_2.mp4" width="100%"></video><p>这是加入了镜头跟随，界面UI，相关交过和关卡交互的基本雏形视频：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_3.mp4" width="100%"></video><p>这是UI优化，不过这个没改动很多，我当时想的是做6个关卡：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_4.mp4" width="100%"></video><p>这是新增角色攻击，拾取物品，跳跃，走路的动画：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_5.mp4" width="100%"></video><p>这是新增地图，相关交互和部分优化的视频，也是这个视频我发现我没有办法做完了，就把关卡砍到了4关：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_6.mp4" width="100%"></video><p>这是最后一个，增加了怪物，角色和怪物交互，到这个地方游戏的大概雏形了完成了后面就是拓展和优化了，一开始我是很想完成它的，然后投到4399上面去，后面我不记得怎么就弃坑了。</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Unity%E8%87%AA%E8%BF%B0/2D%E9%97%AF%E5%85%B3_7.mp4" width="100%"></video><h1 id="关于我对游戏开发的感悟"><a href="#关于我对游戏开发的感悟" class="headerlink" title="关于我对游戏开发的感悟"></a>关于我对游戏开发的感悟</h1><p>随着我对游戏开发的学习，这是一些游戏开发的基本要素可以点击我之前写的这个：<a href="https://helloseraphine.top/index.php/archives/59.html">浅谈游戏开发</a></p><p>游戏和普通的软件不太一样，它对于美工的要求很高，游戏背后的逻辑需要程序来支撑，而游戏的直观好坏美工有很大一部分，游戏开发的难度和广度都很大，它不仅仅是UI界面交互，背后是程序和数学，表面是美工和渲染，游戏开发对数学的要求比较高，就单单《元神》的二次元渲染线管就是国内顶尖的TA了，美工也分为技术美工和普通美工，一般的美工是画图建模之类的，技术美工是要考虑如何将一个效果来通过数学和程序来呈现出来，举一个简单的例子，人物边缘高亮，怎么来实现？需要技术美工提供算法来实现，而人物需要程序来驱动，人物的外表需要一般的美工来建模，游戏引擎负责统筹和输出。</p><p>如果真的对游戏开发很感兴趣，想做程序的话，推荐一本书：<strong>《3D数学基础：图形与游戏开发》</strong>，书的封面是这个样子：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220206162730036.png" alt="image-20220206162730036" style="zoom:80%;" /></p><h1 id="关于新人避坑"><a href="#关于新人避坑" class="headerlink" title="关于新人避坑"></a>关于新人避坑</h1><p>现在市面上的教程很多是坑人的，我的建议是书籍相对较好，当时也得看是什么人写的，说的难听一些，我曾经看到一本教程的书籍，就是把官方网站的教程，一模一样大致弄了下来，真的很没有意义，书籍传授的不仅仅是知识还有经验，他在写书的时候没有把自己的经验写进去怎么可能是一个认真的开发者？</p><h1 id="最后感谢一群小伙伴"><a href="#最后感谢一群小伙伴" class="headerlink" title="最后感谢一群小伙伴"></a>最后感谢一群小伙伴</h1><p>处于隐私问题，我只展示他们的相关网络昵称和头像</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220206163233496.png" alt="image-20220206163233496" style="zoom:77%;" /></p><p>我们并创造什么，是我的个人能力过于有限没有办法来和他们一起去调动创造一个游戏，他们也是没有开发游戏基础，以某种情况聚集到了一起，起码我们聊过游戏，想过游戏，感谢他们每一个人。</p><blockquote><p>其中一位人员的个人博客<a href="http://papercut.top/">Papercut的博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CamShar</title>
      <link href="/2022/05/23/CSharp/WPF/CamShar/"/>
      <url>/2022/05/23/CSharp/WPF/CamShar/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是半年前开发的一个相对完整的桌面应用软件，名称为：<strong>CamShar</strong>，是单词<strong>Campus</strong>（校园）和单词<strong>Share</strong>（分享）的组合，寓意为：校园共享。现在在博客上补上，之前发的由于数据库迁移删除了。</p><h1 id="想法来源"><a href="#想法来源" class="headerlink" title="想法来源"></a>想法来源</h1><p>这个软件的想法是我们大一的时候在聊天的时候想到的，由于每次考试周考试的时候，都需要去打印店打印相关资料和试卷之类的，甚至有的试卷和目前考试年份差的很远，这样对我们考试很没有帮助，我们希望提供一套解决方案，这样大家每次将自己的资料或者考试题目上传记录，每一级的人考试的时候都会事半功倍，也减少了挂科的风险。</p><h1 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h1><p>不过这个想法由于综合原因没有去实现，我和纸人（好友昵称）在去年国庆的时候决定去实现它，我采用的是WPF技术来实现桌面应用软件，纸人使用AndroidStudiio实现安卓端。如下是我留存的软件演示视频：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_Video/CamShar/CamShar.mp4" width="100%"></video><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>我之前录了1个多小时的视频来说明我的代码原理，不过后面不是很满意就没有处理，也就没有上传，这个软件是我WPF学习的作品，也是我做的相对用心的一个作品，整个软件开发周期是半个月，每天在我没课的时候就开始开发，一直到这个视频做出的晚上。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220206172624924.png" alt="image-20220206172624924" style="zoom:50%;" /></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>我尝试上传到GitHub上去，由于源代码中含有相关数据库，存储地址密钥等信息，一直没有处理，现在也懒得处理了，所以只将软件UI上传到GitHub上面，感兴趣的可以通过下面的链接下载。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> WPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算叶面积</title>
      <link href="/2022/05/23/CSharp/WinForm/%E8%AE%A1%E7%AE%97%E5%8F%B6%E9%9D%A2%E7%A7%AF/"/>
      <url>/2022/05/23/CSharp/WinForm/%E8%AE%A1%E7%AE%97%E5%8F%B6%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周三晚上我们上了一节关于叶面积的测定方法的实验课，在课上我想出了一种测定思路，我的想法是通过固定比例尺拍照转换为灰度图来遍历图像像素判断叶的像素，然后再通过比例尺算法计算叶的面积，从程序的角度来看是可行的，只要给定输入固定比例尺的图像，就可以批量输出结果。</p><p>本来我是没打算写这个程序的，不过昨晚学习学累了，就突然想到这个事情，我就想这弄一下吧，然后就弄出来了，程序基于Win平台，使用的是C#，Winform开发技术（主要是快）。至于WPF的美化版我懒得弄了。</p><h1 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h1><p>我早上吃完饭随手摘的银杏的叶子，然后放在一张A4纸上拍照，单击【选择图片】导入程序即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220422085545367.png" alt="image-20220422085545367" style="zoom:80%;" /></p><p>本方法精度取决于比例尺，所以如果想要大规模应用，需要固定相机和拍摄底的距离即可。</p><h1 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h1><ol><li>先判断是否导入了选定图片，导入成功则显示预览图，失败则提醒，二次验证是否规定了比例尺，两者具备则可以正常计算面积</li><li>计算面积前需要将图像转换为灰度图，然后根据算法统计叶子所占的像素，然后根据比例尺算出每个像素的面积，然后加和返回结果。</li></ol><h1 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">LeafArea</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预览图片</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> filePath = OpenFile();</span><br><span class="line">            <span class="keyword">if</span>(filePath == <span class="string">&quot;无&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retrunMes.ForeColor = Color.Red;</span><br><span class="line">                retrunMes.Text = <span class="string">&quot;错误，未指定图片&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Image img = Image.FromFile(filePath);</span><br><span class="line">                pictureBox1.Image = img;</span><br><span class="line">                retrunMes.ForeColor = Color.Green;</span><br><span class="line">                retrunMes.Text = <span class="string">&quot;加载图片成功&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算叶面积</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pictureBox1.Image == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">&quot;请选择图片&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pixel.Text == <span class="string">&quot;&quot;</span> || cm.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    MessageBox.Show(<span class="string">&quot;请填写比例设定&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Image bwImg = BlackWhiteChange(pictureBox1);     <span class="comment">//转化为灰度图</span></span><br><span class="line">                    pictureBox1.Image = bwImg;</span><br><span class="line">                    retrunMes.Text = <span class="string">&quot;计算叶面积中...&quot;</span>;</span><br><span class="line">                    retrunMes.Text = <span class="string">&quot;叶面积为&quot;</span> + CalculateArea(LeafPixel(bwImg)) + <span class="string">&quot;平方厘米&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择图片路径</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OpenFile</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            OpenFileDialog dialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">            dialog.Multiselect = <span class="literal">false</span>;<span class="comment">//禁止选择多个文件</span></span><br><span class="line">            dialog.Title = <span class="string">&quot;请选择文件夹&quot;</span>;</span><br><span class="line">            dialog.Filter = <span class="string">&quot;所有文件(*.*)|*.*&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> dialog.FileName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;无&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化灰度图</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Image <span class="title">BlackWhiteChange</span>(<span class="params">PictureBox pic</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> varH = pic.Image.Height;    <span class="comment">//获取图像高度</span></span><br><span class="line">            <span class="built_in">int</span> varW = pic.Image.Width;     <span class="comment">//获取图像宽度</span></span><br><span class="line">            Bitmap bitmap = <span class="keyword">new</span> Bitmap(varW,varH);  <span class="comment">//更具宽高创建灰度图对象</span></span><br><span class="line">            Bitmap rgbmap = (Bitmap)pic.Image;  <span class="comment">//RGB图像</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; varW; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; varH; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Color nowColor = rgbmap.GetPixel(i, j);     <span class="comment">//获取当前颜色像素</span></span><br><span class="line">                    <span class="built_in">int</span> r, g, b, <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">                    r = nowColor.R;</span><br><span class="line">                    g = nowColor.G;</span><br><span class="line">                    b = nowColor.B;</span><br><span class="line">                    <span class="keyword">value</span> = (r + g + b) / <span class="number">3</span>;      <span class="comment">//加权平均生成灰度图</span></span><br><span class="line">                    bitmap.SetPixel(i, j, Color.FromArgb(<span class="keyword">value</span>, <span class="keyword">value</span>, <span class="keyword">value</span>));     <span class="comment">//生成灰度图</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bitmap;      <span class="comment">//返回生成的灰度图</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算叶面积像素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LeafPixel</span>(<span class="params">Image img</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> num =<span class="number">0</span>;</span><br><span class="line">            Bitmap bitmap = (Bitmap)img;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;像素宽度&#123;0&#125;，长度&#123;0&#125;&quot;</span>, img.Width,img.Height);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; img.Width; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; img.Height; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Color nowColor = bitmap.GetPixel(i, j);     <span class="comment">//获取当前颜色像素</span></span><br><span class="line">                    <span class="built_in">int</span> r;</span><br><span class="line">                    r = nowColor.R;</span><br><span class="line">                    <span class="keyword">if</span> (r &lt; <span class="number">100</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num++;      <span class="comment">//计算叶面积占的像素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;所占像素为&#123;0&#125;&quot;</span>, num);</span><br><span class="line">            <span class="keyword">return</span> num;     <span class="comment">//返回所占像素值</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据像素和比例算面积</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> real = <span class="built_in">double</span>.Parse(cm.Text)/<span class="built_in">double</span>.Parse(pixel.Text);  <span class="comment">//计算一个像素是多少厘米</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;单像素面积为&#123;0&#125;&quot;</span>, real);</span><br><span class="line">            <span class="built_in">double</span> realone = real * real;    <span class="comment">//一个像素的面积</span></span><br><span class="line">            result = realone * num;     <span class="comment">//总像素面积</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;总面积为&#123;0&#125;&quot;</span>, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>程序不难，如果后续改进的话可以将遍历图片部分的算法更换其他灵活的算法，计算的速度应该可以翻几倍，因为<code>.NET</code>默认的遍历像素的算法比较耗时，如果采用锁定内存或者非安全代码来使用引用指针话速度会更快。</p><p>关于叶面积测定仪，我个人也想到了这种方法，不过这种方法是从单片机的角度来考虑的，相比较程序来说便携和快速的结果是最大的优势，但是对于大规模的计算来说，程序会相对较好，给定输入，返回输出。</p><p>关于纸质量测定法，我个人认为如果通过复印机的方式直接复印叶子的样子出来，然后剪切叶子的形状称量重量会相对精确一些，比较人手画的相对误差大。前提是排除了复印机墨的质量。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> WinForm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整活 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【10.0】C-文件</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%9010-0%E3%80%91C-%E6%96%87%E4%BB%B6/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%9010-0%E3%80%91C-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>程序中数据的输入可以从键盘读取，但是对于大量的数据，人工输入的效率过于低下，而且对于多次运行的工作极为不便。所以可以通过程序对文件进行读取，然后将结果保存到另一个文件中，这样可以大幅度提高效率。</p><h1 id="文件概述"><a href="#文件概述" class="headerlink" title="文件概述"></a>文件概述</h1><h2 id="文件的定义"><a href="#文件的定义" class="headerlink" title="文件的定义"></a>文件的定义</h2><p>文件指存储在外部存储介质中的有序数据集合，如系统头文件<code>stdio.h</code>，程序所生成的源文件<code>.c</code>文件，编译后产生的<code>.obj</code>目标文件，链接后生成的<code>.exe</code>执行文件。</p><h2 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h2><ol><li><p>从用户的角度来看，文件可以分为普通文件和设备文件</p><p>普通文件是驻留在存储介质上的有序数据集。。普通文件依据其存储内容可以分为程序文件，如源文件，头文件等，以及数据文件，存储待输入的原始数据和输出的结果数据文件。</p><p><strong>C语言将所有外部设备都看作文件，这就是设备文件，如显示器，打印机，键盘等，将它们对系统的输入，输出等同于对磁盘文件的读和写</strong>。通常将显示器作为标准输出文件，在屏幕上的显示即是向标准输出文件输出，<code>printf()</code>，<code>putchar()</code>称为标准输出函数即原因。键盘则作为标准输入文件，从键盘上输入即标准输入文件读入数据，因此<code>scanf()</code>，<code>getchar()</code>称为标准输入函数。</p></li><li><p><strong>虽然文件在计算中皆是用二进制 0，1 来表达与存储，但从文件的编码方式来看，文件可以分为 ASCII码文件和二进制码文件</strong>。一般文件的最基本存储单位为字节（8位二进制），文件即是由一个个字节按一定顺序构成的，但每个字节表达含义不同，则文件编码方式也不同。</p><p>ASCII码文件：也称为文本文件。在磁盘中存放的文件的每个字节都是对应字符的ASCII码。例如，对数值5678存储为对应字符5，6，7，8的ASCII码，形式为：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220218143616511.png" alt="image-20220218143616511" style="zoom: 80%;" /></p><p>ASCII码文件可在屏幕上按字符显示，因此方便阅读，如源程序文件，头文件便ASCII码文件。</p><p>二进制文件：文件在磁盘中存放的是对应数值的二进制形式。如数值5678存储的二进制表示为 0001011000101110 。二进制文件的优点在于节省存储空间，但是可读性较差。</p><p><strong>C语言在处理文件时，并不区分类型，都按字节处理，看成字符流。输入/输出字符流的开始和结束也只是由程序控制而不受物理符号（如回车符）的控制。因此也将这种文件称为流式文件或流文件，这是文件较为重要的一个概念。</strong></p></li></ol><h1 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h1><p>在C语言中，对文件的所有操作都是通过文件类型指针来进行的。文件类型指针是指向文件结构体变量的指针。所谓文件结构体变量是指<strong>文件处理时，在缓存区开辟的文件信息描述区，而该信息描述区是以一个结构体变量来描述和记录文件的当前状态（如文件名，文件大小等）。描述和记录文件状态的结构体变量称为文件结构体变量，其结构体类型由系统定义，名为<code>FILE</code>，包含在头文件<code>stdio.h</code>中</strong>，因此文件操作必须使用<code>#include &lt;stdio.h&gt;</code>命令。C语言便是通过操作指向文件结构体变量的指针来进行文件处理，有时也简称为指向文件的指针或者文件指针。</p><p><code>FILE</code>结构体类型的形式大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="type">short</span> _level;<span class="comment">//缓冲区满空程度 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> _flag;<span class="comment">//文件号</span></span><br><span class="line">   <span class="type">char</span> _fd;<span class="comment">//文件描述符</span></span><br><span class="line">   <span class="type">short</span> _size;<span class="comment">//缓存区的大小</span></span><br><span class="line">   <span class="type">char</span> *_buffer;       <span class="comment">//数据缓冲区首地址</span></span><br><span class="line">   <span class="type">int</span> _cleft;      <span class="comment">//缓冲区中剩下的字符</span></span><br><span class="line">   <span class="type">int</span> _mode;       <span class="comment">//文件的操作模式</span></span><br><span class="line">   <span class="type">char</span> *_curp;     <span class="comment">//指针当前位置</span></span><br><span class="line">   <span class="type">char</span> *_nextc;        <span class="comment">//下个字符的位置</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> _istemp;        <span class="comment">//临时文件指示</span></span><br><span class="line">   <span class="type">short</span> _token;        <span class="comment">//有效性标记</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同C语言系统<code>FILE</code>类型的定义会有少许不同。文件指针的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * 指针变量标识符;</span><br></pre></td></tr></table></figure><p>一般习惯写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * fp;</span><br></pre></td></tr></table></figure><p>通过指针<code>fp</code>指向某个具体文件来对文件进行操作。</p><blockquote><p><code>fp</code>是：file Pointer 的缩写</p></blockquote><h1 id="文件的打开，读写和关闭"><a href="#文件的打开，读写和关闭" class="headerlink" title="文件的打开，读写和关闭"></a>文件的打开，读写和关闭</h1><p><strong>在进行文件的读写之前需要先打开文件，读写完毕之后必须关闭文件，打开与关闭文件是必不可少的操作</strong>。打开文件即是建立文件指针与文件的关系，关闭则是释放指针与文件的联系，同时保证缓冲区中的数据写入文件。</p><h2 id="文件的打开函数fopen"><a href="#文件的打开函数fopen" class="headerlink" title="文件的打开函数fopen()"></a>文件的打开函数<code>fopen()</code></h2><p><code>fopen()</code>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">const</span> <span class="type">char</span> * mode)</span>;</span><br></pre></td></tr></table></figure><p>利用<code>fopen()</code>函数打开文件方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE * fp;</span><br><span class="line">fp=fopen(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;文件操作方式标识符&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">fp=fopen(<span class="string">&quot;myfile&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//以只写的方式打开文件myfile</span></span><br></pre></td></tr></table></figure><p><strong>调用函数时，系统会在缓冲区为文件开辟一个文件信息描述区，获得该文件信息描述区（文件结构变量）的地址，并将它赋值给指针<code>fp</code>，从而<code>fp</code>与文件联系起来，通过<code>fp</code>便可以实现对文件的各种操作。如果文件不能打开（打开文件失败），则<code>fopen()</code>函数返回空指针<code>NULL</code>（其值为0）.</strong></p><p>文件名可以包含文件路径，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp=fopne(<span class="string">&quot;C:\\test\nyfile&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述打开文件方式，为ANSIC规定方式。</p><blockquote><p>American National Standards Institute（ANSI——美国国家标准学会）</p></blockquote><p>文件操作方式标识符如下标：</p><div class="table-container"><table><thead><tr><th style="text-align:center">文件操作方式标识符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:center">“r”</td><td style="text-align:left">以只读的方式打开一个文本文件，只允许读数据</td></tr><tr><td style="text-align:center">“w”</td><td style="text-align:left">以只写的方式打开或建立一个文本文件，只允许写数据</td></tr><tr><td style="text-align:center">“a”</td><td style="text-align:left">以追加方式打开一个文本文件，并在文件末尾增加数据</td></tr><tr><td style="text-align:center">“rb”</td><td style="text-align:left">以只读方式打开一个二进制文件，只允许读数据</td></tr><tr><td style="text-align:center">“wb”</td><td style="text-align:left">以只写方式打开或建立一个二进制文件，只允许写数据</td></tr><tr><td style="text-align:center">“ab”</td><td style="text-align:left">以追加方式打开一个二进制文件，并在文件末尾写数据</td></tr><tr><td style="text-align:center">“r+”</td><td style="text-align:left">以读写方式打开一个文本文件，允许读和写</td></tr><tr><td style="text-align:center">“w+”</td><td style="text-align:left">以读写方式打开或者建立一个文本文件，允许读和写</td></tr><tr><td style="text-align:center">“a+”</td><td style="text-align:left">以读写方式打开一个文本文件，允许读，或者在文件末尾追加数据</td></tr><tr><td style="text-align:center">“rb+”</td><td style="text-align:left">以读写方式打开一个二进制文件，允许读和写</td></tr><tr><td style="text-align:center">“wb+”</td><td style="text-align:left">以读写方式打开或者建立一个二进制文件，允许读和写</td></tr><tr><td style="text-align:center">“ab+”</td><td style="text-align:left">以读写方式打开一个二进制文件，允许读，或在文件末尾追加数据</td></tr></tbody></table></div><p>需要注意的是：</p><ol><li><p><strong>以只读方式<code>r</code>打开文件时，该文件必须以及存在，否则出错，且只能进行读取操作。</strong></p></li><li><p><strong>以只写方式<code>w</code>打开文件时，如果文件不存在，则以指定的文件名新建文件，若打开的文件已经存在，则原文件内容消失，重写写入内容且只能进行写操作。</strong></p></li><li><p><strong>以追加方式<code>a</code>打开文件，若文件不存在则出错，若文件存在则向文件末尾追加新的信息</strong></p></li><li><p>如一个文件无法打开，或者打开出错，将无法进行正确读写操作，如果不对文件打开加以判断，则用户无法了解是否可以进行下一步操作，<strong>因此文件操作除打开，关闭这两个要素外，还需要打开判断</strong>。<strong>如果打开出错，<code>fopen()</code>函数将返回一个空指针<code>NULL</code></strong>，因此在程序中可以使用下面的语句进行判断是否打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;myfile&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">    getch();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getch()</code>函数是获取字符，但是不显示在屏幕上。</p><p><code>exit(1)</code>是系统级别的函数，表示异常退出，<code>exit(0)</code>表示正常退出。</p></blockquote></li><li><p>文本文件读入内存时，需要将ASCII码转换成二进制码，写入磁盘时，再把二进制码转换成ASCII码，因此文本文件的读写相比于二进制文件，需要花费转换时间。</p></li></ol><h2 id="文件的关闭函数fclose"><a href="#文件的关闭函数fclose" class="headerlink" title="文件的关闭函数fclose()"></a>文件的关闭函数<code>fclose()</code></h2><p>文件打开成功并操作完毕后，如不关闭文件，文件读写的数据可能丢失。<strong>因为文件的操作是通过缓冲区进行的，读写数据是先放入缓冲区，满时才写入文件，如操作后缓冲区未满，又未关闭文件，则缓冲区中的数据将丢失，因此必须使用文件关闭命令，将缓冲区的数据写入文件</strong>。文件关闭函数<code>fclose()</code>原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p><strong>如果关闭成功，则<code>fclose()</code>函数返回 0 ，否则返回 EOF（-1）</strong>。通过判断<code>fclose()</code>函数返回值可知晓文件是否正常关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((rNum=fclose(fp)!=<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error:fail in file close&quot;</span>);</span><br></pre></td></tr></table></figure><p>文件关闭不仅可以保存数据，同时还会释放文件结构体变量所占存储空间，可节省系统资源。</p><p>【关于EOF的说明】</p><p>以下内容来源于百度百科 <a href="https://baike.baidu.com/item/EOF/1017800?fr=aladdin">EOF</a></p><p><em>在C语言中，或更精确地说成C标准函数库中表示文件结束符（end of file）。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以<a href="https://baike.baidu.com/item/字符">字符</a>的<a href="https://baike.baidu.com/item/ASCII">ASCII</a>代码值的形式存放。我们知道，<a href="https://baike.baidu.com/item/ASCII代码">ASCII代码</a>值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。</em></p><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><p>除了打开，打开判断，关闭这三个文件操作要素外，对文件实际的改变操作是中间对文件的读和写。C语言提高多种文件读写函数，也包含在头文件<code>stdio,h</code>中，主要有：</p><ul><li><strong>文件字符读/写函数：<code>fgetc()</code>/<code>fputc()</code></strong></li><li><strong>文件字符串读/写函数：<code>fgets()</code>/<code>fputs()</code></strong></li><li><strong>文件格式化读/写函数：<code>fprintf()</code>/<code>fscanf()</code></strong></li><li><strong>文件数据块读/写函数：<code>fread()</code>/<code>fwrite()</code></strong></li></ul><p>所有读函数，都必须是读或读写方式打开文件；所有写函数，都必须是写或者读写的方式，或者追加方式打开文件。如果希望重建文件，则采用只写或者读写的方式打开文件，如果希望保留原文件内容，从后面开始新内容，则用追加或者读写方式打开文件。</p><ol><li><p><strong>文件字符读写函数</strong></p><ul><li><p><strong>文件读字符函数<code>fgetc()</code></strong>，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * fpoint)</span>;</span><br></pre></td></tr></table></figure><p><code>fgetc()</code>函数调用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=fgetc(fp);</span><br></pre></td></tr></table></figure><p>其中<code>c</code>为字符变量，也可以是数组字符元素等。<strong><code>fgetc()</code>函数每次从文件中读取一个字符，返回值为该字符的 ASCII 码，如返回值为 EOF ，则表示已到达文件结束位置。</strong></p><p><strong>打开文件后，<code>fgetc()</code>函数读取的是第一个字符，再调用<code>fgetc()</code>函数则依次读取下一关字符，如果读至结束则返回 EOF</strong> 。实际上，读写位置是由文件内部的位置指针控制的，打开时，位置指针指向第一个字节，并随着函数的调用后移，该位置指针由系统自动设置，不需要用户定义。</p></li><li><p><strong>文件写字符函数<code>fputc()</code></strong>，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c,FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">fputc(字符量,文件fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">fputc(c,fp);</span><br></pre></td></tr></table></figure><p><strong><code>fputc()</code>函数每次向文件写入一个字符，写入成功则返回字符的 ASCII 码值，写入失败则返回 EOF</strong>。</p></li></ul></li></ol><p>   【实例】显示<code>.txt</code>文件内容并写入新内容，再显示新内容</p><pre><code>【代码示例】<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(FILE *fp)</span>;      <span class="comment">//输出文件内容函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteNew</span><span class="params">(FILE *fp)</span>;        <span class="comment">//输入新内容函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">FILE *fp;       <span class="comment">//声明文件指针</span></span><br><span class="line"><span class="comment">//文件指针指向文件并设置打开失败输出</span></span><br><span class="line"><span class="comment">//a+ 允许读和追加</span></span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;txt.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">PutOut(fp);     <span class="comment">//输出原内容</span></span><br><span class="line">WriteNew(fp);   <span class="comment">//输入新内容</span></span><br><span class="line">PutOut(fp);     <span class="comment">//输出新内容</span></span><br><span class="line">fclose(fp);     <span class="comment">//关闭文件指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出原文件的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件的内容：\n&quot;</span>);</span><br><span class="line">rewind(fp);     <span class="comment">//将文件指针移动到开始处</span></span><br><span class="line"><span class="type">char</span> c = fgetc(fp);</span><br><span class="line"><span class="keyword">while</span> (c&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">c = fgetc(fp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加新内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteNew</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入新增内容:\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> x = getchar();</span><br><span class="line"><span class="keyword">while</span> (x!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">fputc(x, fp);</span><br><span class="line">x = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 【输出】 &lt;img src=&quot;https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220220164146907.png&quot; alt=&quot;image-20220220164146907&quot; style=&quot;zoom:80%;&quot; /&gt;</code></pre><ol><li><p><strong>文件字符串读写函数</strong></p><ul><li><p><strong>文件字符串读函数<code>fgets()</code></strong>，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">fgets(字符数组名,n,文件指针);</span><br></pre></td></tr></table></figure><p>其功能是从文件指针所指文件中读取一个长度为<code>n-1</code>的字符串，在最后一个字符之后加上字符串结束标志<code>\0</code>后，存入一个字符数组中。</p><p><strong>若<code>fgets()</code>函数执行成功，则返回字符数组首元素的地址，如果一开始就遇到文件尾或者数据错误，则返回<code>NULL</code></strong>。</p></li><li><p><strong>文件字符串写函数<code>fputs()</code></strong>，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">char</span> * <span class="built_in">string</span>,FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line"><span class="built_in">fputs</span>(字符串，文件指针);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Hello&quot;</span>,fp);</span><br></pre></td></tr></table></figure><p><strong>其功能是往文件中写入一个字符串，其中字符串可以是字符串常量，也可以是有赋值的字符数组。如果写入成功，则返回一个非负值，反之则返回 E0F （-1）。</strong></p></li></ul></li></ol><p>   【实例】读取文件前10个字符输出显示，然后从键盘输入字符串写入文件并显示</p><p>   【代码示例】</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE *fp)</span>;       <span class="comment">//关闭文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE *fp)</span>;        <span class="comment">//打开文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadFile</span><span class="params">(FILE *fp,<span class="type">int</span> num)</span>;        <span class="comment">//读取文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteFile</span><span class="params">(FILE *fp)</span>;       <span class="comment">//写入文件函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp=fopen(<span class="string">&quot;txt.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    OpenFile(fp);</span><br><span class="line">    ReadFile(fp,<span class="number">12</span>);</span><br><span class="line">    WriteFile(fp);</span><br><span class="line">    ReadFile(fp,<span class="number">20</span>);</span><br><span class="line">    CloseFile(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件关闭函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadFile</span><span class="params">(FILE * fp,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n读取文件内容： &quot;</span>);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">    fgets(c, num, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n文件内容读取完毕\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入要添加的内容: &quot;</span>);</span><br><span class="line">    fseek(fp, <span class="number">8</span>, SEEK_END);<span class="comment">//将指针移到文件最后</span></span><br><span class="line">    <span class="type">char</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(x, fp)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内容接收完毕\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   【输出】</p><p>   <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220220185220626.png" alt="image-20220220185220626" style="zoom:80%;" /></p><blockquote><p><a href="https://www.runoob.com/cprogramming/c-function-fseek.html">关于库函数<code>fseek()</code>的说明</a>或者查看下面的文件定义的说明</p></blockquote><ol><li><p><strong>文件格式化读写函数</strong></p><ul><li><p><strong>文件格式化读函数<code>fscanf()</code></strong>。</p><p><code>fscanf()</code>函数与<code>scanf()</code>函数功能类似，区别在于<code>scanf()</code>函数从标志输入文件（即键盘）读取，<code>fscanf()</code>函数则是从文件中读取。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE * fpoint,<span class="type">char</span> * format,[argument...])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line"><span class="built_in">fscanf</span>(文件指针，格式控制字符串，输入项列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%c%d&quot;</span>,&amp;c,&amp;a);</span><br></pre></td></tr></table></figure></li><li><p><strong>文件格式化写函数<code>fprintf()</code></strong>。</p><p><code>fprintf()</code>函数与<code>printf()</code>函数功能类似，区别在于<code>pritnf()</code>函数输出到标志输出文件（即显示器），<code>fprintf()</code>函数则输出到磁盘文件。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE * fpoint,<span class="type">char</span> * format,[argument...])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line"><span class="built_in">fprintf</span>(文件指针，格式控制字符串，输出项列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c%d&quot;</span>,c,a);</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>   【实例】读取指定数量字符，并写入文件其 ASCII 码值</p><p>   【代码示例】</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE *fp)</span>;        <span class="comment">//打开文件函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE *fp)</span>;       <span class="comment">//关闭文件函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpeFile</span><span class="params">(FILE *fp)</span>;        <span class="comment">//操作文件函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;txt.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    OpenFile(fp);</span><br><span class="line">    OpeFile(fp);</span><br><span class="line">    CloseFile(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: fail in opening myfile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件关闭函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CloseFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpeFile</span><span class="params">(FILE * fp)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n读取文件内容： &quot;</span>);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="type">char</span> a, b;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c%c&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c%c(前两个字符)&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n文件内容读取完毕\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在写入文件&quot;</span>);</span><br><span class="line">    fseek(fp, <span class="number">8</span>, SEEK_END);<span class="comment">//将文件指针移到最后</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入文件完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   【输出】</p><p>   <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220220193029544.png" alt="image-20220220193029544" style="zoom:80%;" /></p><blockquote><p>需要注意的是每次读取文件的时候，注意将文件指针使用<code>rewind()</code>函数移动到开始</p></blockquote><ol><li><p><strong>文件数据块读写函数</strong></p><p><strong>所谓数据块读写是指一次读取一组数据，</strong>如数组，结构体变量等。数据块读写函数调用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(buffer,size,count,fp);</span><br><span class="line">fwrite(buffer,size,count,fp);</span><br></pre></td></tr></table></figure><p><strong>其中<code>buffer</code>为输入或者输出数据首地址，为指针变量，<code>size</code>为数据块长度（字节数），<code>count</code>表示要读写的数据块的个数，<code>fp</code>为文件指针</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">fread(str,<span class="number">3</span>,<span class="number">5</span>,fp);</span><br></pre></td></tr></table></figure><p>即从<code>fp</code>所指的文件中每次读取 3 个字节，读取 5 次，存入数组<code>str</code>中。</p><p><strong><code>fread()</code>以及<code>fwrite()</code>函数的返回值都是整型，如果该整数和<code>count</code>相等，则表示读写是成功的，否则表示读写不正确。</strong></p></li></ol><p>   【实例】某超市把以下4种库存商品的信息写入 commodity.dat 文件中，并读出来进行检测。</p><div class="table-container"><table><thead><tr><th>商品编号</th><th>商品名称</th><th>商品价格</th><th>商品库存量</th></tr></thead><tbody><tr><td>1001</td><td>电视</td><td>4500</td><td>10</td></tr><tr><td>1002</td><td>空调</td><td>8000</td><td>15</td></tr><tr><td>1003</td><td>冰箱</td><td>5000</td><td>6</td></tr><tr><td>1004</td><td>洗衣机</td><td>6000</td><td>30</td></tr></tbody></table></div><p>   【代码示例】</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Commodity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;Commodity;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    Commodity commd[<span class="number">4</span>] = &#123;&#123;<span class="number">1001</span>,<span class="string">&quot;电视&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;, &#123;<span class="number">1002</span>,<span class="string">&quot;空调&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;, &#123;<span class="number">1001</span>,<span class="string">&quot;冰箱&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;, &#123;<span class="number">1001</span>,<span class="string">&quot;洗衣机&quot;</span>,<span class="number">4500</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">    Commodity commd2[<span class="number">4</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;commodity.dat&quot;</span>,<span class="string">&quot;ab+&quot;</span>);        <span class="comment">//打开文件指针</span></span><br><span class="line">    fwrite(commd, <span class="keyword">sizeof</span>(Commodity), <span class="number">4</span>, fp);    <span class="comment">//将缓冲区数据写入文件</span></span><br><span class="line">    rewind(fp);     <span class="comment">//指针指向文件开头</span></span><br><span class="line">    fread(commd2, <span class="keyword">sizeof</span>(Commodity), <span class="number">4</span>, fp);        <span class="comment">//将数据写入文件缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件中的内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d | %s | %d | %d \n&quot;</span>, commd2[i].id,commd2[i].name,commd2[i].num,commd2[i].price);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   【输出】</p><p>   <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220220200605907.png" alt="image-20220220200605907" style="zoom:80%;" /></p><h1 id="文件的定位"><a href="#文件的定位" class="headerlink" title="文件的定位"></a>文件的定位</h1><p>前面的实例中多次使用了<code>rewind()</code>函数，用来将文件位置指针返回到文件开头。所以，我们在操作文件时，应该先清楚文件位置指针在什么位置，根据位置来进行处理。<strong>文件定位函数便是操作文件位置指针用于判断以及其指定其位置的函数</strong>。</p><p><strong>文件定位函数包含在头文件<code>stdio.h</code>中</strong>。</p><ol><li><p><strong><code>rewind()</code>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">rewind(fp);</span><br></pre></td></tr></table></figure><p>不论当前指针位置在哪里，<code>rewind()</code>函数都将文件位置指针返回文件开头。</p></li><li><p><strong><code>fseek()</code>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE * fpoint,<span class="type">long</span> offset,<span class="type">int</span> origin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">fseek(fp,位移量，起始点);</span><br></pre></td></tr></table></figure><p><strong><code>fseek()</code>函数用于把文件位置指针移动到指定位置上。起始点有3个取值：</strong></p><ul><li><strong>0（<code>SEEK_SET</code>）表示文件开始位置；</strong></li><li><strong>1（<code>SEEK_CUR</code>）表示当前位置;</strong></li><li><strong>2（<code>SEEK_END</code>）表示文件末尾；</strong></li></ul><p><strong>位移量表示从起始点开始移动的字节数，为长整型。位移量为正表示文件指针向文件末尾移动，反之则向文件开头方向移动。</strong>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">8</span>,SEEK_END);</span><br></pre></td></tr></table></figure><p>表示移动文件位置指针到文件的末尾，共移动 8 个字节。</p></li><li><p><strong><code>ftell()</code>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line">loog <span class="title function_">ftell</span><span class="params">(FILE * fpoint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">loog n = ftell(fp);</span><br></pre></td></tr></table></figure><p><strong><code>ftell()</code>函数用于寻找位置指针的当前位置。返回值为位置指针当前位置相对于文件首的偏移字节数。如果调用出错，则返回<code>-1L</code></strong>。</p></li><li><p><strong><code>feof()</code>函数</strong></p><p><strong><code>feof()</code>函数用于判断文件位置指针是否在文件结束位置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE * stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用形式</span></span><br><span class="line">feof(fp);</span><br></pre></td></tr></table></figure><p><strong><code>feof()</code>函数返回值为 1 表示位置指针在文件末尾，否则返回 0 。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【9.0】C-结构体与共用体</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%909-0%E3%80%91C-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%909-0%E3%80%91C-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>C语言的数据类型分为基本数据类型和构造数据类型</strong>，之前的<code>int</code>,<code>float</code>等数据类型都是基本数据类型，都是C语言事先定义好的数据类型，编程时直接使用即可。<strong>C语言还允许用户自定义数据类型，称为构造数据类型，例如：数组，以及下面的结构体和共用体。</strong></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体(structure)是由不同数据类型的数据所组成的集合体，是构造数据类型，<strong>其特点是可以由不同的数据类型构成</strong>。</p><p>每一个结构体有一个名字，称为结构体名。一个结构体由若干成员组成，每个成员都有自己的名字，称为结构体成员名。结构体成员是组成结构体的要素，每个成员的数据类型可以不同。</p><p>简单来描述结构体来说如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">学号</th><th style="text-align:center">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">成绩</th></tr></thead><tbody><tr><td style="text-align:center">xxx</td><td style="text-align:center">xxx</td><td style="text-align:center">xxx</td><td style="text-align:center">xxx</td></tr></tbody></table></div><p>对于一个结构体来说就是头行，我们现在定义他的名称为：学生信息，那么组成学生信息的成员就是：学号，姓名，性别，成绩。这几个元素就是学生信息结构体的成员/元素。对于各种元素他们的类型是可以不同的。</p><h2 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h2><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">2</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">3</span>的名字;</span><br><span class="line">   ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>struct</code>是结构体类型标识符，是关键词。结构体名由标识符组成，称为结构体类型名，由用户指定。大括号<code>&#123;&#125;</code>中的结构体成员表，称为结构体。</strong></p><p>【实例】对于上面的举例表格的结构体实现如下：</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//结构体名<span class="title">studentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;<span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> sex;<span class="comment">//性别</span></span><br><span class="line">    <span class="type">float</span> score;<span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【说明】</p><p>如上定义的<code>studentInfo</code>是一种自定义的新数据类型，系统不会对它分配实际的存储空间，只是一种自定义数据模板。</p><p>声明结构体需要注意以下几点：</p><ol><li><p><strong>结构体声明描述了结构体的组织形式，在程序编译时并不为它分配存储空间</strong>。只是规定了一种特定的数据结构类型以及它所占用的存储空间。</p></li><li><p><strong>结构体成员可以是任意类型</strong>。所以，结构体可以嵌套使用，即一个结构体可以称为另一个结构体的成员，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//学生信息结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;<span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> sex;<span class="comment">//性别</span></span><br><span class="line">    <span class="type">float</span> score;<span class="comment">//分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">birthday</span>;</span><span class="comment">//出生日期</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> year;<span class="comment">//年份</span></span><br><span class="line">    <span class="type">int</span> mouth;<span class="comment">//月份</span></span><br><span class="line">    <span class="type">int</span> day;<span class="comment">//日份</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>结构体声明可以在任意位置</strong>，如果声明在自定义函数内，则只可以在自定义函数内调用，如果声明在自定义函数外，则可以在从声明点到最后范围内调用。<strong>一般情况下，是在源文件的开头对结构体进行声明</strong>。</p></li><li><p>结构体成员名可以与程序中其他变量同名，系统会自动识别它们，两种不会混淆。</p></li></ol><h2 id="结构体变量的定义"><a href="#结构体变量的定义" class="headerlink" title="结构体变量的定义"></a>结构体变量的定义</h2><p>结构体变量定义一般采用下面三种形式：</p><ol><li><p><strong>先声明结构体类型再定义变量</strong>，其定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span> <span class="title">test</span>;</span><span class="comment">//结构体定义</span></span><br></pre></td></tr></table></figure><p><strong>在定义了结构体变量后，系统会为结构体变量分配存储空间。</strong></p><p>若程序规模比较大，可将对结构体类型的声明集中放到一共文件中（以<code>.h</code>为后缀的头文件）。若其他源文件需要用到此结构体类型，则可以用<code>#include</code>命令将该头文件包含到本文件中，便于修改和使用。</p></li><li><p><strong>在声明结构体类型同时定义结构体变量</strong>，其定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">2</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">3</span>的名字;</span><br><span class="line">   ···</span><br><span class="line">&#125;结构体变量名表;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>//结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;a,b,c;<span class="comment">//定义三个studentInfo类型的结构体变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong>直接定义结构体变量，不出现结构体名</strong>，其定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>//注意：此处结构体名没了</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">2</span>的名字;</span><br><span class="line">    数据类型 成员<span class="number">3</span>的名字;</span><br><span class="line">   ···</span><br><span class="line">&#125;结构体变量名表;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>//结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;a,b,c;</span><br></pre></td></tr></table></figure></li></ol><p>结构体变量定义需要注意：</p><ol><li>结构体数据类型的定义描述了结构体的类型的模式，不分配存储空间；而结构体变量定义则是在编译时为结构体变量分配存储空间。</li><li>结构体变量中的成员可以单独使用，其作用和地位与一般变量一致</li><li><strong>结构体变量占用存储空间的大小是各成员所需内存量的总和，在程序中可以用<code>sizeof()</code>函数来实现，即<code>sizeof(结构体名)</code></strong>。需要注意的是：有时与<code>sizeof()</code>函数计算出来的值不是完全一样的，这个实际的内存量，不仅与所定义的结构体类型有关，还与计算机系统以及编译系统有关。通常系统为结构体变量分配内存大小，会大于或等于所有成员所占用内存字节数的总和。</li></ol><h2 id="用typedef定义数据类型"><a href="#用typedef定义数据类型" class="headerlink" title="用typedef定义数据类型"></a>用<code>typedef</code>定义数据类型</h2><p><strong>关键字<code>typedef</code>用于为系统固有的或者自定义数据类型定义一个别名</strong>。数据类型的别名通常使用大写字母，这不是强制性的，只是为了与已有数据类型区分。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTNUM;<span class="comment">//定义int类型的别名为INTNUM</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    INTNUM a = <span class="number">2</span>;<span class="comment">//使用别名声明并定义变量值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：2</p><p>同样的也可以使用<code>typedef</code>来定义结构体数据类型，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">info</span>;</span><span class="comment">//将结构体类型关键字定义为info</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h2><p>在定义结构体变量后，如果需要引用结构体变量，需要注意的是不可以将结构体整体作为输入和输出，只能对具体成员进行输入输出，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是错误的,S是结构体变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,S);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是正确的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,S.num);</span><br></pre></td></tr></table></figure><p>也就是说，访问结构体成员变量的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用格式</span></span><br><span class="line">结构体名.成员名称</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果结构体嵌套结构体类型，则调用就一直 . 下去就行</span></span><br><span class="line">结构体名.嵌套结构体.嵌套结构体成员名称</span><br></pre></td></tr></table></figure><blockquote><p>结构体变量不能进行整体输入和输出，当时允许相同结构体类型的结构体变量赋值，例如：<code>S1=S2</code>。</p></blockquote><h2 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h2><p>可以在定义结构体变量的同时初始化，语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">strust 结构体类型名 结构体变量名 = &#123;初始化数据&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">strust Student <span class="built_in">std</span>=&#123;<span class="string">&quot;小明&quot;</span>,<span class="number">2</span>,<span class="number">98</span>&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><strong>初始化数据与数据之间用逗号隔开</strong></li><li>初始化数据的数量要和结构体成员对应且相等</li><li>初始化数据对应的数据类型一致</li></ol><p>结构体变量初始化代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">a</span>=</span>&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h1><p>一个结构体变量中可以存放一组数据，即excel表中“一行”数据。如果数据有很多行，即对应很多个对象，这时就可以使用结构体数组来表示。结构体数组的元素是一个结构体类型的变量。</p><h2 id="结构体数组的定义"><a href="#结构体数组的定义" class="headerlink" title="结构体数组的定义"></a>结构体数组的定义</h2><p>结构体数组必须先定义，后引用。代码格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">s</span>[10];</span><span class="comment">//声明结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;s[<span class="number">10</span>];<span class="comment">//声明结构体数组</span></span><br></pre></td></tr></table></figure><h2 id="结构体数组的初始化"><a href="#结构体数组的初始化" class="headerlink" title="结构体数组的初始化"></a>结构体数组的初始化</h2><p>结构体数组也可以在初始化的同时进行初始化，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudnentInfo</span> <span class="title">stfinfo</span>[10]=</span>&#123;&#123;<span class="number">1</span>,<span class="string">&quot;test&quot;</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="string">&quot;test1&quot;</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="string">&quot;test2&quot;</span>,<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上述示例代码是对结构图数组前三个元素进行初始化。</p><h2 id="结构体数组的引用"><a href="#结构体数组的引用" class="headerlink" title="结构体数组的引用"></a>结构体数组的引用</h2><p>【实例】求下表成绩平均值</p><div class="table-container"><table><thead><tr><th>姓名</th><th>性别</th><th>成绩</th></tr></thead><tbody><tr><td>张三</td><td>1</td><td>98</td></tr><tr><td>李四</td><td>1</td><td>80</td></tr><tr><td>小明</td><td>0</td><td>68</td></tr></tbody></table></div><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> <span class="title">info</span>;</span><span class="comment">//重定义类型名称</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Avg</span><span class="params">(info a[<span class="number">10</span>])</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    info a[<span class="number">10</span>] = &#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>, <span class="number">98</span>&#125;, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">1</span>, <span class="number">80</span>&#125;, &#123;<span class="string">&quot;小明&quot;</span>, <span class="number">0</span>, <span class="number">68</span>&#125;&#125;;<span class="comment">//初始化结构体数组数据</span></span><br><span class="line">    Avg(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Avg</span><span class="params">(info a[<span class="number">10</span>])</span>&#123;<span class="comment">//自定义函数，计算平均值</span></span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + a[i].num;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;三位同学的平均分为：%f&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220209122926651.png" alt="image-20220209122926651" style="zoom:80%;" /></p><h1 id="结构体指针变量"><a href="#结构体指针变量" class="headerlink" title="结构体指针变量"></a>结构体指针变量</h1><p>结构体指针变量是指向结构体变量的指针，该指针变量的值是结构体变量的起始地址。</p><h2 id="指向结构体变量的指针"><a href="#指向结构体变量的指针" class="headerlink" title="指向结构体变量的指针"></a>指向结构体变量的指针</h2><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>,<span class="string">&quot;小明&quot;</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> *<span class="title">p</span>;</span><span class="comment">//声明结构体指针变量</span></span><br><span class="line">    p = &amp;a;<span class="comment">//将结构体a的地址传给指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生的姓名为%s&quot;</span>, (*p).name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的可以在声明就初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span> *<span class="title">p</span>=</span>&amp;a;</span><br></pre></td></tr></table></figure><p>C语言规定了两种用于访问结构体成员的运算符，一种是成员运算符，也就是<code>.</code>；另一种是指向运算符，也称为箭头运算符，其语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">结构体指针变量名-&gt;成员名</span><br><span class="line">    </span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">p-&gt;name;</span><br><span class="line"><span class="comment">//上面等价于下面</span></span><br><span class="line">(*p).name;</span><br></pre></td></tr></table></figure><h2 id="指向结构体数组的指针"><a href="#指向结构体数组的指针" class="headerlink" title="指向结构体数组的指针"></a>指向结构体数组的指针</h2><p>定义一个结构体数组S s[30]，若要定义结构体指针变量p.将其指向结构体数组，方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">p</span>=</span>s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">p</span>=</span>&amp;s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>*<span class="title">p</span>;</span></span><br><span class="line">p=s;</span><br></pre></td></tr></table></figure><p>它们都是获取了结构体数组<code>s</code>的首地址，如下图，可以通过改变指针的指向位置来实现不同元素的访问。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220209160431876.png" alt="image-20220209160431876" style="zoom:40%;" /></p><p>例如：使用<code>p-&gt;sC</code>引用的是<code>s[0].sC</code>的值，同样的使用<code>(p+1)-&gt;sC</code>引用的是<code>s[1].sC</code>的值。</p><h2 id="结构体变量和结构体指针变量作为函数参数"><a href="#结构体变量和结构体指针变量作为函数参数" class="headerlink" title="结构体变量和结构体指针变量作为函数参数"></a>结构体变量和结构体指针变量作为函数参数</h2><p>与其他普通的数据类型一样，既可以定义结构体类型的变量，数组，指针，也可以将结构体类型作为函数参数的类型和返回值的类型。将一个构造体变量的值传递给另一个函数，有如下三种方法：</p><ol><li><p>用结构体的单个成员作为函数参数，向一个结构体传递结构体的单个成员</p><p>用单个结构体成员作为函数实参，与其他普通数据类型的变量作函数实参完全一样，都是值传递调用，在函数内部对其进行操作，不会引起结构体成员值的变化。</p></li><li><p>用结构体变量作为函数参数，向函数传递结构体的完整结构</p><p>用结构体变量作为函数实参，向函数传递是结构体的完整结构，即将整个结构体成员的内容复制给被调函数。在函数内可用成员运算符引用其结构体成员。因为这种传递方式也是值传递调用，所以，在函数内对形参结构体成员值的修改不会影响相应实参结构体成员的值</p></li><li><p>用结构体指针或者结构体数组作为函数参数，向函数传递结构体的地址。</p><p>用指向结构体的指针变量或结构体数组作为函数实参的实质是向函数传递结构体的地址，因为是地址调用，所以在函数内部对形参的成员值的修改会影响到实参结构体成员的值。</p></li></ol><p>【实例】如下学生成绩信息表</p><div class="table-container"><table><thead><tr><th>学号</th><th>高数成绩</th><th>英语成绩</th></tr></thead><tbody><tr><td>101</td><td>87</td><td>80</td></tr><tr><td>102</td><td>59</td><td>69</td></tr><tr><td>103</td><td>97</td><td>83</td></tr></tbody></table></div><p>要求在主函数中输入学生信息，编写一个自定义函数，将高数成绩为59分的同学成绩改为60，然后将修改后的学生信息在主函数中输出。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentInfo</span>//声明结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> mathScore;</span><br><span class="line">    <span class="type">int</span> englishScore;</span><br><span class="line">&#125;info;<span class="comment">//并重命名关键词为info</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fix</span><span class="params">(info *a)</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    info s[<span class="number">3</span>] = &#123;&#123;<span class="number">101</span>, <span class="number">87</span>, <span class="number">80</span>&#125;, &#123;<span class="number">102</span>, <span class="number">59</span>, <span class="number">69</span>&#125;, &#123;<span class="number">103</span>, <span class="number">97</span>, <span class="number">83</span>&#125;&#125;;<span class="comment">//结构体数组初始化</span></span><br><span class="line">    Fix(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fix</span><span class="params">(info *a)</span>&#123;<span class="comment">//自定义函数:查询并修改等于59分数的值</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;<span class="comment">//记录一共修改了几处</span></span><br><span class="line">    <span class="type">int</span> mark = <span class="number">0</span>;<span class="comment">//记录是否发生修改标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;mathScore==<span class="number">59</span>)<span class="comment">//判断是否要修改</span></span><br><span class="line">        &#123;</span><br><span class="line">            a-&gt;mathScore = <span class="number">60</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;englishScore==<span class="number">59</span>)<span class="comment">//判断是否要修改</span></span><br><span class="line">        &#123;</span><br><span class="line">            a-&gt;englishScore = <span class="number">60</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num&gt;mark)<span class="comment">//根据标记，判断是否修改过值，如果修改过，输出修改后的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;学号：%d\n&quot;</span>, a-&gt;num);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;高数成绩：%d\n&quot;</span>, a-&gt;mathScore);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;英语成绩：%d\n&quot;</span>, a-&gt;englishScore);</span><br><span class="line">        &#125;</span><br><span class="line">        a++;<span class="comment">//移动指针到下一个结构体元素</span></span><br><span class="line">        mark = num;<span class="comment">//修正标记回正</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共修改 %d 处&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220209170839824.png" alt="image-20220209170839824" style="zoom:80%;" /></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>这是一种常见的线性数据结构，它是动态进行内存分配的一种结构，链表根据需要开辟存储空间。</p><p>在没学习链表之前，如果存储数量较多同类型数据时，通常会使用数组。比如要存储一个班级相关成绩的信息。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score[<span class="number">40</span>];</span><br></pre></td></tr></table></figure><p><strong>在使用数组的时候，总有一个问题困扰我们：数组应该有多大？</strong></p><p>在大多数情况下，我们并不能确定要使用多大的数组，所以一般情况下，我们将数组定义的足够大。这样，程序在运行时就申请了固定大小的足够大的存储空间。即使知道该班级的学生数，但是如果因为某种特殊原因人数有增加或者减少，又必须重新修改程序，扩大和缩小数组的存储空间。<strong>这种分配固定大小的内存分配方法称为静态内存分配</strong>。这种内存分配方法存在比较严重的缺陷：在大多数情况下会浪费大量的内存空间，在少数情况下，当定义数组不够大时，还可能出现下标越界错误，甚至导致严重后果。</p><p>这时候动态分配内存的链表就可以解决如上问题：</p><p><strong>动态内存分配是指在程序执行过程中根据需要动态地分配或者回收存储空间的内存分配方法</strong>。动态内存分配不像数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序需求临时分配，且分配的大小就是程序要求的大小。</p><p>链表数据集合中的每个数据存储在称为结点的结构体中，一个结点通过该结点中存储的另一个结点的存储地址（指针）来访问另一个结点，如果按照这种方法把所有结点依次串联起来，称为链表。</p><p>链表是由结点组成的数据集合，而结点存储空间的建立与撤销是采用动态内存分配与撤销函数在程序运行时完成的。因此，链表是一种动态数据结构。</p><h2 id="链表的类型及定义"><a href="#链表的类型及定义" class="headerlink" title="链表的类型及定义"></a>链表的类型及定义</h2><p>链表是用一组任意的存储单元存储线性表元素的一种数据结构。</p><p><strong>链表又分为单链表，双向链表和循环链表等。</strong></p><p>链表一般采用图形方式直观描述结点之间的连接关系。这种描述链表逻辑关系的结构图形称为链表图。</p><ol><li><p><strong>单链表</strong></p><p>单链表是最简单的一种链表，其数据元素是单项排列的，如下图</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220209182734259.png" alt="image-20220209182734259" style="zoom:80%;" /></p><p>从上图可以看出，单链表有一个“头指针”变量，图中用<code>h</code>表示，它存放一个地址，该地址指向单链表中的第一个元素。单链表中每个元素称为结点，每个结点都包括两部分：一部分数据域——存放用户要用的实际数据；另一部分是指针域——存放下一个结点的地址，用指针变量表示。单链表中最后一个结点的指针域位空（NULL），表面单链表到此结束。</p><p>空链表表示单链表中没有结点信息，它用一个值NULL的指针变量表示。</p><p><strong>单链表中各元素在内存中可以不是连续存放的。要查找某一元素，必须先找到上一个元素，根据它的指针域找到下一个元素的存储地址。如果不提供头指针，则整个链表都无法访问。</strong></p><p>单链表的数据结构可以用结构体来实现，一个结构体变量可以包含若干成员，这些成员可以是数值类型，字符类型，数组类型，也可以是指针类型。利用指针类型成员存放下一个结点的指针。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码实现了一个数据域为<code>int</code>类型变量的结点类型，成员变量<code>next</code>是一个指针变量，一般称为后继指针，该指针所指向的数据类型是该结构体类型。</p><p>或者可以利用<code>typedef</code>给这个自定义的数据类型起个名字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br></pre></td></tr></table></figure><p>一个单链表就是由内存中若干个<code>Node</code>类型的结构体变量构成的。在实际应用时，单链表的数据域不限于单个的整型，实型或者字符型，它可能由若干个成员变量组成。在单链表中，知道指向某个结点的指针，很容易得到该结点的后继结点的位置，但是要得到该结点的直接去前驱结点位置，则须从头指针出发进行搜索。</p></li><li><p><strong>循环单链表</strong></p><p>循环链表如下图，它的特点是最后一个结点的指针域存放着第一个结点的存储地址，这样一来，链表中所有的结点构成一个环，从每个结点都能搜索到其直接前驱和直接后继结点。</p><p>循环单链表的优点是从任何一个结点出发，都能到达其他任何结点。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220209202106504.png" alt="image-20220209202106504" style="zoom:80%;" /></p></li><li><p><strong>双向链表</strong></p><p>如果为每个结点增加一个指向直接前驱结点的指针域，就可以构成双向链表 。双向链表可以沿着求前驱和求后继两个方向搜索结点。</p><p>双向链表的结点数据结构实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//后继结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">previous</span>;</span><span class="comment">//前驱结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="处理动态链表的函数"><a href="#处理动态链表的函数" class="headerlink" title="处理动态链表的函数"></a>处理动态链表的函数</h2><p>   链表结构是动态分配存储空间的，即在需要时才开辟一个结点的存储空间。动态分配和释放存储空间需要用到以下几个库函数：</p><ol><li><p><code>malloc()</code>函数。函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其作用是在内存的动态存储区中分配一个长度为<code>size</code>的连续空间。其参数是一个无符号整型数，返回值是一个指向所分配的连续存储区域的起始地址的指针。还有一点必须注意的是，当函数未能成功分配存储空间（如内存不足）就会返回一个<code>NULL</code>指针。所以在调用该函数时应该检测返回值是否为<code>NULL</code>并执行相应的操作。</p><blockquote><p><code>malloc</code>全称：memory allocation（内存分配）</p></blockquote></li><li><p><code>calloc()</code>函数。函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>其作用是在内存的动态区存储中分配<code>n</code>个长度为<code>size</code>的连续空间。函数返回一个指向分配域起始地址的指针；如果分配不成功（如内存空间不足），返回<code>NULL</code>。</p><p>用<code>calloc()</code>函数可以为一维数组开辟动态存储空间，<code>n</code>为数组元素个数，每个元素长度为<code>size</code>。</p><blockquote><p><code>calloc</code>全称：clear allocation（内存清空）</p></blockquote></li><li><p><code>free()</code>函数。</p><p>由于内存区域是有限的，不能无限制的分配下去，而且一个程序要尽量节省资源，所以当所分配的内存区域不在需要时，就要释放它，以便其他的变量或者程序使用。这时要用到<code>free()</code>函数。函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure><p>其作用是释放由<code>p</code>指向的内存区，这部分内存区能被其他变量使用。<code>p</code>是调用<code>calloc()</code>或者<code>malloc()</code>函数返回的指针值，<code>free()</code>函数无返回值。</p></li></ol><h2 id="动态链表的基本操作"><a href="#动态链表的基本操作" class="headerlink" title="动态链表的基本操作"></a>动态链表的基本操作</h2><ol><li><p><strong>单链表的建立</strong>（含头结点的尾插法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10<span class="comment">//定义单链表的长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>//结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"><span class="comment">//自定义创建单链表函数</span></span><br><span class="line">NODE * <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    NODE *head;     <span class="comment">//单链表的头指针</span></span><br><span class="line">    NODE *p;        <span class="comment">//指向当前要插入列表的结点</span></span><br><span class="line">    NODE *r;        <span class="comment">//指向单链表最后一个结点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为头结点申请存储空间并检测是否分配成功</span></span><br><span class="line">    <span class="keyword">if</span> ((head=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE)))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;      <span class="comment">//头结点的指针域设置为空</span></span><br><span class="line">    r = head;<span class="comment">//将r的指针指向head的地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p结点总指向当前处理结点</span></span><br><span class="line">        <span class="keyword">if</span> ((p=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE)))==<span class="literal">NULL</span>)<span class="comment">//创建新结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);       <span class="comment">//从键盘读入数据，存入当前结点的数据域</span></span><br><span class="line">        r-&gt;next = p;        <span class="comment">//将r的指针指向的指针域指向p,形成单链表</span></span><br><span class="line">        r = p;<span class="comment">//再将r指向最新的尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将未结点赋NULL表示最后一个</span></span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义遍历输出单链表元素数值的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(NODE *L)</span>&#123;</span><br><span class="line">    NODE *p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    NODE *h;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整数，建立单链表\n&quot;</span>, N);</span><br><span class="line">    h = createList(N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;单链表内容如下：\n&quot;</span>);</span><br><span class="line">    printList(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220217142850646.png" alt="image-20220217142850646" style="zoom:80%;" /></p></li><li><p><strong>单链表的查找运算</strong></p><p>对单链表进行查找的思路为：从单链表中第一个结点开始依次向后扫描，检测其数据域是否是所要查找的数值，如果是要查找的值着查找成功，反之则继续查找至单链表的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义查找方法,传入单链表和要查找的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">locate</span><span class="params">(NODE *L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    NODE *p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;<span class="comment">//记录位置</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=x)<span class="comment">//判断是否为空链表以及值是否相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;<span class="comment">//如果不符合，index+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p=<span class="literal">NULL</span>)<span class="comment">//如是空链表则直接返回0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">//反之将记录位置返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>单链表的插入操作</strong></p><p>单链表的插入：假设在一个单链表中存在两个连续结点p,q(其中p为q的直接前驱)，若我们需要在p于q之间插入一个新结点s,那么需要先为s分配存储空间并完成数据域的赋值，然后让p的指针指向存储s的地址，将s的指针指向q的地址，这样就完成了插入操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表插入操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(NODE *L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    NODE *s, *p, *q;</span><br><span class="line">    <span class="keyword">if</span> ((s=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE)))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = x;    <span class="comment">//将要插入元素的值赋值给s</span></span><br><span class="line">    p = L-&gt;next;        <span class="comment">//p指向链表的第一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)     <span class="comment">//如果p的指针不是空，则继续遍历单链表元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;      <span class="comment">//直到最后一个元素，则q是最后一个元素</span></span><br><span class="line">        p = p-&gt;next;    </span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = q-&gt;next;      <span class="comment">//将新插入的指针域获取原指针域指向</span></span><br><span class="line">    q-&gt;next = s;        <span class="comment">//将原来的指针域指向新指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>单链表的删除操作</strong></p><p>删除结点只需要让前驱结点指向后继结点即可，如下示意图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220217173742005.png" alt="image-20220217173742005" style="zoom: 50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单链表元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteList</span><span class="params">(NODE *L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    NODE *q, *p;</span><br><span class="line">    p = L;</span><br><span class="line">    q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q!=<span class="literal">NULL</span> &amp;&amp; q-&gt;data!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表中没有要删除的元素&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除一个元素后的单链表如下：\n&quot;</span>);</span><br><span class="line">        printList(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈，队列和链表都属于线性结构。线性结构的特点是，在数据元素的非空有限集中：</p><ol><li>存在唯一的一个被称为“第一个”的数据元素</li><li>存在唯一的一个被称为“最后一个”的数据元素</li><li>除第一个之外，集合中的每个数据元素均只有一个前驱</li><li>除最后一个之外，集合中每个数据元素都只有一个后继</li></ol><p><strong>栈和队列都是操作受限制的特殊线性表。</strong></p><p><strong>栈是一种只允许在表头进行插入和删除的特殊线性表，其操作的原则是后进先出，故栈又称为后进先出表，称为LIFO（Last In First Out）表。</strong></p><p><strong>队列是删除操作只在表头进行，插入操作只在表尾进行的特殊线性表，其操作原则是先进先出，简称FIFO（First In First Out）。</strong></p><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><p><strong>共用体，有的也称为联合体（Union），是将不同类型的数据组织在一起共同占用同一段内存的一种构造数据类型</strong>。同样都是将不同类型的数据组织在一起，但与结构体不同的是，共用体是从同一起始地址开始存放成员的值，即让所有成员共享同一段存储空间。共用体与结构体的类型定义方法相似，只是关键字变为<code>union</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> 共用体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 成员名称;</span><br><span class="line">    数据类型 成员名称;</span><br><span class="line">    数据类型 成员名称;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共用体数据类型和结构体数据类型都属于构造数据类型，都可以由程序员根据实际需要来定义，其不同之处在于，共用体的所有成员共同占用一段内存，<strong>共用体变量所占用内存空间大小取决于其他成员中占内存空间最多的那个成员变量</strong>；而结构体的每个成员各自占用一段内存，结构体变量所占用的内存空间大小取决于所有成员占用内存空间的大小总和。</p><p>【实例】查看共用体和结构体占用情况</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tests</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">test</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tests</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共用体占用内存：%lld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结构体占用内存：%lld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220217190935208.png" alt="image-20220217190935208" style="zoom:67%;" /></p><blockquote><p>利用<code>sizeof()</code>函数测得的值一般会大于或者等于成员所需的内存量总和</p></blockquote><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>枚举，即“一个一个列举”之意，当某些变量仅由有限个数据值组成时，通常使用枚举类型表示。枚举数据表示描述的是一组整型值的集合。<strong>声明枚举类型需要使用关键字<code>enum</code>。</strong>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,…&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span>&#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;;</span><br></pre></td></tr></table></figure><p><strong>枚举类型如果做不做的规定，默认从0开始对应到枚举元素上</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        sun,</span><br><span class="line">        mon,</span><br><span class="line">        tue,</span><br><span class="line">        wed,</span><br><span class="line">        thu,</span><br><span class="line">        fri,</span><br><span class="line">        sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span> <span class="title">a</span>;</span></span><br><span class="line">    a = sun;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：0</p><p>如果想要自定义的，可以使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        sun,</span><br><span class="line">        mon=<span class="number">2</span>,</span><br><span class="line">        tue,</span><br><span class="line">        wed,</span><br><span class="line">        thu,</span><br><span class="line">        fri,</span><br><span class="line">        sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">weekday</span> <span class="title">a</span>;</span></span><br><span class="line">    a = mon;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：2</p><blockquote><p>上述代码中<code>sun</code>实际对应0，而<code>mon</code>规定是2，后面的<code>tue</code>则是3，<code>wed</code>是4…依次类推</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【8.0】C-指针</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%908-0%E3%80%91C-%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%908-0%E3%80%91C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>兜兜转转，终于到了指针，作为C语言最重要的功能。也是C语言最强大，最复杂的机制。</p><p>指针在C程序中应用非常广泛，从基本的数据结构，如链表和树，到大型程序中常用的数据索引和复杂数据结构的组成，都离不开指针的使用。之所以说指针时C最强大的机制，在于<strong>指针可以使程序员直接按地址直接访问指定的存储空间，也可以在权限许可范围内对存储空间的数据进行任意解释和操作</strong>。</p><blockquote><p><strong>Pointer</strong>是指针的英文单词</p></blockquote><h1 id="变量的地址和指针"><a href="#变量的地址和指针" class="headerlink" title="变量的地址和指针"></a>变量的地址和指针</h1><p>在程序中，当我们定义一个变量时，首先要定义变量的数据类型，<strong>数据类型决定了一个变量在内存中所占用的存储空间的大小</strong>。其次要定义变量名。<strong>C语言的编译系统会根据变量的类型在适当的时候为指定的变量分配存储空间</strong>。例如，在Visual C++环境下，一个<code>int</code>类型数据占据4个字节的存储空间。</p><p>在计算机内部，所有的存储空间都要统一进行“编号”，即所有的存储空间都要有地址，<strong>每一存储空间具有唯一的内存地址</strong>。系统为每一个已定义的变量分配一定的存储空间，使变量名与内存的一个地址相对应，<strong>为一个变量进行赋值操作，实质就是要将变量的值存入系统为该变量分配的存储空间中，即变量的值要存入变量名对应的内存地址中</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j,k;</span><br></pre></td></tr></table></figure><p>编译程序可能会为它们在内存中做如下图形式的分配。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121233931059.png" alt="image-20220121233931059" style="zoom:80%;" /></p><p>也就是说变量<code>i</code>占据以2000开始的4字节，<code>j</code>占据从2004开始的<code>4</code>字节，<code>k</code>占据从2008开始的<code>4</code>字节。在确定了变量的地址之后，就可以通过变量名对内存中变量对应的地址进行操作。对编程者来说，可以使用变量名进行程序设计。程序运行时需要进行计算时，要根据地址取出变量所对应的存储空间中存放的值，参与各种运算，计算结果最后还要存入变量名对应的存储空间中。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br><span class="line">j = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>语句<code>i=10</code>是将整数值10存入从2000开始的地址单元，语句<code>j=20</code>是将整数值20存入2004开始的地址单元。而</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = i + j;</span><br></pre></td></tr></table></figure><p>则是将2000中存放的值和2004中存放的值取出来相加，然后放入2008开始的单元中去。这个赋值语句执行完毕后的情况如下图所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121235125248.png" alt="image-20220121235125248" style="zoom:80%;" /></p><p><strong>通过变量名获取变量的地址，再从变量的地址对应的存储空间中取值，或将某值存入变量地址对应的存储空间中的过程，称为直接寻址访问</strong>。</p><p><strong>如果将变量<code>i</code>的地址存放在另一个变量<code>p</code>中，通过访问变量<code>p</code>，间接达到访问变量<code>i</code>的目的，这种方式称为变量的间接访问。保存其他变量地址的变量就称为指针变量</strong>。因此，我们可以认为：<strong>指针是用于指向其他变量的变量</strong>。</p><p>要取出变量<code>i</code>的值10，既可以通过使用变量<code>i</code>直接访问，也可以通过变量<code>i</code>的地址间接访问。</p><p>间接访问变量<code>i</code>的方法是：从地址为3000的存储空间中，先找到变量<code>i</code>在存储空间中的地址2000，再从地址为2000的单元中取出<code>i</code>的值10，这种对应关系如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220122000408286.png" alt="image-20220122000408286" style="zoom:80%;" /></p><p><strong>所谓指针变量，就是专门用来保存指针的一类变量，它的值是其他变量的地址，该地址就是某个变量在存储空间中对应的存放位置</strong>。这种间接存取关系反应了指针的特性。</p><blockquote><p><strong>要注意区分“值”和“地址”</strong></p></blockquote><p>指针用于存放其他数据的地址，指针可以指向变量，利用指针可以引用变量；指针还可以指向数组，利用指针可以访问数组中的所有元素；指针还可以指向函数，存放函数的入口地址，利用指针调用函数；指针还可以指向结构体（欠结构体，后面有），引用结构体变量的成员。</p><h1 id="指针变量的定义"><a href="#指针变量的定义" class="headerlink" title="指针变量的定义"></a>指针变量的定义</h1><p>指针变量与一般变量一样，必须先声明后使用。定义一个指针变量需要解决两个问题：一是声明指针变量的名字，二是声明指针变量指向的数据类型，即指针变量所指的变量的数据类型。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型声明符 *指针变量名</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> *a;<span class="comment">//声明了整型指针变量</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>指针变量名前面的符号<code>*</code>在声明/定义时不可以省略，它是把其后变量声明为指针类型的标志。</p></li><li><p>其他类型的变量允许和指针变量在同一个语句中定义。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,*p;</span><br></pre></td></tr></table></figure></li><li><p><strong>指针变量定义中的数据类型是指针指向的目标数据类型，而不是指针变量的数据类型。指针变量的数据类型由<code>*</code>声明为指针类型</strong>。</p></li></ol><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><h2 id="取地址运算符"><a href="#取地址运算符" class="headerlink" title="取地址运算符"></a>取地址运算符</h2><p><strong><code>&amp;</code>运算符是取地址运算符，它是单目运算符，其功能是返回其后所跟操作数的地址</strong>，其结合性为从右向左，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>,*p;</span><br><span class="line">p=&amp;i;</span><br></pre></td></tr></table></figure><p>将变量<code>i</code>的地址赋值给<code>p</code>。这个赋值语句可以理解为<code>p</code>接收<code>i</code>的地址，如下图所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220122134457031.png" alt="image-20220122134457031" style="zoom:80%;" /></p><blockquote><p>注意区分取地址运算符<code>&amp;</code>与双目运算符<code>&amp;</code>（按位与）</p></blockquote><h2 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h2><p><strong><code>*</code>运算符是指针运算符</strong>，也称为间接运算符，它也是单目运算符。<strong>其功能是取该指针变量所指向的存储单元的值</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>,*p,y;<span class="comment">//声明和定义x=10，指针类型p,和整型变量y</span></span><br><span class="line">p=&amp;x;<span class="comment">//指针类型p取得x变量的地址</span></span><br><span class="line">y=*p;<span class="comment">//将指针类型p指向的地址的值，即10赋值给y变量</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><h3 id="指针变量的初始化"><a href="#指针变量的初始化" class="headerlink" title="指针变量的初始化"></a>指针变量的初始化</h3><p>指针变量的初始化，就是在定义指针变量的同时为其赋初值。由于指针变量是指针类型，所赋初值应是一个地址值。其一般格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 指针变量名=地址<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中地址形式有多种，例如：&amp;变量名，数组名，其他的指针变量等。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取一般变量地址</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p=&amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> *p=a;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>不能用未声明的变量给指针变量赋初值，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">int</span> i;</span><br></pre></td></tr></table></figure></li><li><p>当用一个变量地址为指针变量赋值时，该变量的数据类型必须与指针变量指向的数据类型一致。</p></li><li><p><strong>除0之外，一般不把其他整数作为初值赋给指针变量。程序运行期间，变量的地址是由计算机分配的，当用一个整数作为指针变量赋初值后，可能会造成难以预料的后果。当用0对指针赋初值时，系统会将该指针变量初始化为一个空指针，不指向任何对象。</strong></p></li></ol><h3 id="使用赋值语句赋值"><a href="#使用赋值语句赋值" class="headerlink" title="使用赋值语句赋值"></a>使用赋值语句赋值</h3><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">指针变量=地址;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> *p,i;</span><br><span class="line">p=&amp;i;</span><br></pre></td></tr></table></figure><p>另外，指针变量和一般变量一样，存放在它们之中的值可以改变，也就是说可以改变它们的指向，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,*p;</span><br><span class="line">p=&amp;a;</span><br><span class="line">p=&amp;b;</span><br></pre></td></tr></table></figure><p>通过指针访问它所指向的一个变量是以间接访问的形式进行的，所以比直接访问一个变量要费时间，而且不直观，因为通过指针要访问哪一个变量，取决于指针的值（即指向），例如<code>*p1=*p2;</code>实际上是将<code>p2</code>的变量的值赋值给<code>p1</code>变量的值。由于指针是变量，可以通过改变指向来间接访问不同的变量，这给编写者以灵活性，使程序代码编写更加间接灵活。</p><blockquote><p><strong><code>数据类型 *</code>+<code>变量名</code>表示指针类型，<code>*</code>+<code>变量名</code>表示取指针的值</strong>。</p></blockquote><h2 id="空指针与void指针"><a href="#空指针与void指针" class="headerlink" title="空指针与void指针"></a>空指针与<code>void</code>指针</h2><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p><strong>空指针就是不指向任何对象的指针，表示该指针没有指向任何存储空间</strong>。构造空指针有下面两种方法：</p><ul><li><p>赋0值，这是唯一的允许不经转换就赋予指针的数值。</p></li><li><p>赋<code>NULL</code>值，<code>NULL</code>值等于0，即两者等价，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>引入空指针的目的就是为了防止使用指针出错</strong>。</p><p><strong>空指针常常用来初始化指针，避免野指针的出现</strong>。</p><p>对指针变量赋0或者NULL值与不赋值是不同的。指针变量赋0值后，该指针被初始化为空指针，空指针是不可以使用的。<strong>而指针变量未赋值时，可以是任意值，可能指向任何地方，该指针被形象的称为野指针</strong>。不要使用野指针，否则可能会出现意外错误。</p><p>为了避免上述错误的发生，<strong>习惯的做法是定义指针变量时立即将其初始化为空指针，在使用指针之前再给指针变量赋值</strong>，也就是在指针有了具体指向之后再使用指针。</p><h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a><code>void</code>指针</h3><p>C语言规定，<strong>指针变量可以定义为<code>void</code>类型</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p;</span><br></pre></td></tr></table></figure><p>这里<code>p</code>仍然是一个指针变量，且有自己的内存空间，但不指定<code>p</code>指向哪种类型的变量。在这种情况下，应该注意：</p><ol><li><p><strong>任何指针都可以赋值给<code>void</code>指针</strong>。</p></li><li><p><strong><code>void</code>指针赋值给其他类型指针需要进行类型转换</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *t=(<span class="type">int</span> *)p;<span class="comment">//需要强制类型转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>void</code>指针不能参与指针运算，除非进行转换</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> *c;</span><br><span class="line">    c++;<span class="comment">//编译出错，原因是不知道c的指向的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h1><p>在函数之间可以传递变量的值，同样也可以传递地址（指针）。<strong>函数与指针的相关关系：指针作为函数的参数，函数的返回值为指针以及指向函数的指针</strong>。</p><h2 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h2><p>问题从编写一个两个数交换的问题出手。</p><p>【实例】编写<code>swap</code>函数，实现交换两个整型变量的值。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换前a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    Swap(a, b);<span class="comment">//交换函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);<span class="comment">//输出交换后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220123004855594.png" alt="image-20220123004855594" style="zoom:80%;" /></p><p>【说明】从输出结果来看就可以知晓，对于调用函数来说，是实现了数的交换，但是只是形参的交换，而实参<code>a</code>,<code>b</code>并没有发生交换。这与我们想要的结果相差甚远，怎么办？</p><p>以指针为参数的函数就可以解决这个问题了，虽然全局函数也可以实现，但是对于程序来说，每次都需要全局函数的对于程序的可维护，可读性有一定的影响。</p><p>【实例】以指针为参数的交换<code>swap</code>函数，实现两数的交换。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换前a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = *a;</span><br><span class="line">    *a = *b;<span class="comment">//获取传入值的存储空间并赋值</span></span><br><span class="line">    *b = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后a的值为%d,b的值为%d\n&quot;</span>, *a, *b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220123142514403.png" alt="image-20220123142514403" style="zoom:80%;" /></p><p>但是如果将上面的代码进行简单的调整，得到的结果又是不同的，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换前a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数交换后a的值为%d,b的值为%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *x;</span><br><span class="line">    x = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后a的值为%d,b的值为%d\n&quot;</span>, *a, *b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220123142933842.png" alt="image-20220123142933842" style="zoom:80%;" /></p><p>调整后的代码<code>a=b</code>，只是在形参<code>a</code>和<code>b</code>指针的地址发生了交换，而对于地址指向的存储空间内容没有发生交换，也就是说仅仅是交换了形参<code>a</code>和<code>b</code>之间存储的变量地址。对于调整前的代码来说<code>*a=*b</code>，意味着将指针<code>a</code>指向的变量的存储空间的值修改成指针<code>b</code>指向的存储空间的值，也就是说修改了指针指向地址的存储空间，也就实现了原变量的值交换。</p><p><strong>“指针变量所指向单元的存储空间的值”和“指针变量存储的地址值是根本不同的。前者指的是指针指向单元的值，而后者指的是指针变量的值。</strong></p><h2 id="指针作为函数的返回值"><a href="#指针作为函数的返回值" class="headerlink" title="指针作为函数的返回值"></a>指针作为函数的返回值</h2><p>除了可以将基本类型作为函数返回值类型之外，还可以将地址作为函数返回值，<strong>当把地址作为函数的返回值时，该函数称为指针函数</strong>。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 函数名(形参列表)&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>函数名前面的<code>数据类型 *</code>表示该函数的返回类型为某数据类型的指针</strong>。</p><p>【实例】输入若干数值，判断并获取最大值，且值的范围在$100$~$0$之间。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">Max</span><span class="params">()</span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *max;</span><br><span class="line">    max = Max();<span class="comment">//返回指针赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d&quot;</span>, *max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> * <span class="title function_">Max</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> max;<span class="comment">//静态局部变量，防止方法执行完毕内存被释放，值不存在</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n&lt;<span class="number">100</span> &amp;&amp; n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;max)&#123;</span><br><span class="line">            max = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;max;<span class="comment">//返回指针值，即地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220124152521719.png" alt="image-20220124152521719" style="zoom:80%;" /></p><blockquote><p>如果函数返回指针，注意不要返回局部变量的地址，因为局部变量在执行完成函数后被释放了，返回的是野指针。</p></blockquote><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>在定义一个函数之后，编译系统为每个函数确定一个入口地址，当调用该函数时，系统会从入口地址开始指向该函数。存放函数的入口地址的指针就是一个指向函数的指针，简称函数指针</strong>。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 (*指针变量名)();</span><br></pre></td></tr></table></figure><p><strong>类型标识符是函数的返回值的类型。需要注意的是，由于C语言中，括号的优先级比<code>*</code>高，因此，<code>* 指针变量名</code>外部必须使用括号，否则指针变量名首先与后面的括号结合，就是前面说明的“返回指针的函数”</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">P</span><span class="params">()</span>;<span class="comment">//函数返回值类型为指针的函数，该指针指向整型</span></span><br><span class="line"><span class="type">int</span> (*p)();<span class="comment">//指向函数的指针，该函数返回值类型为整型</span></span><br></pre></td></tr></table></figure><p>与变量指针一样，必须给函数指针赋值，才能指向具体的函数。由于函数名代表了该函数的入口地址，因此，一个简单的方法就是直接使用函数名来为函数指针赋值，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">函数指针名=函数名;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fun</span><span class="params">()</span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="type">int</span> (*F)();<span class="comment">//指向函数的指针声明</span></span><br><span class="line">F=Fun;<span class="comment">//指向函数指针的地址指向Fun函数</span></span><br></pre></td></tr></table></figure><p>函数指针经定义和赋值之后，在程序中就可以引用该指针，目的是调用被指针指向的函数，可以通过这种方式增加对函数调用的方式。</p><p>【实例】使用函数指针，计算两个数的和</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*P)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">//声明函数指针</span></span><br><span class="line">    P = Plus;<span class="comment">//指针指向函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的和为:%d&quot;</span>,P(<span class="number">3</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220124161442567.png" alt="image-20220124161442567" style="zoom:80%;" /></p><p>【实例】关于函数指针的一些用法</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;  <span class="comment">//加法函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">//减法函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">//乘法函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> (*P)(<span class="type">int</span>, <span class="type">int</span>))</span>;  <span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的和为:%d\n&quot;</span>,Fun(<span class="number">3</span>,<span class="number">2</span>,Plus));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的差为:%d\n&quot;</span>,Fun(<span class="number">3</span>,<span class="number">2</span>,Sub));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;俩者的积为:%d\n&quot;</span>,Fun(<span class="number">3</span>,<span class="number">2</span>,Mul));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> (*P)(<span class="type">int</span>,<span class="type">int</span>))</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> P(a, b); <span class="comment">//自定义函数调用函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;  <span class="comment">//加法函数</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;   <span class="comment">//减法函数</span></span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;   <span class="comment">//乘法函数</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220124162921494.png" alt="image-20220124162921494" style="zoom:80%;" /></p><p>这样在调用函数的时候，可以直接传入指定函数，就可以执行函数。</p><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><h2 id="一维数组的指针表示"><a href="#一维数组的指针表示" class="headerlink" title="一维数组的指针表示"></a>一维数组的指针表示</h2><h3 id="定义指向一维数组的指针变量"><a href="#定义指向一维数组的指针变量" class="headerlink" title="定义指向一维数组的指针变量"></a>定义指向一维数组的指针变量</h3><p>在C语言中，指针和数组有紧密的联系，其原因在于，凡是由数组下标完成的操作都可以用指针来实现。我们以及知道，在数组中可以通过数组的下标来确定唯一数组元素在数组中的顺序和存储地址，这种方式也称为下标表示法。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,x;</span><br><span class="line">x=a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>对于数组的引用可以使用指针表示法来实现。由于每个数组元素相当于一个变量，因此指针变量既然可以指向一般变量，同样也可以指向数组中的元素，也就是可以用指针来访问数组中的元素。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *c=&amp;a[<span class="number">2</span>];<span class="comment">//获取指定元素的地址指针</span></span><br></pre></td></tr></table></figure><p>由于一维数组的数组名是一个地址常量，程序运行时，它的值是一个一维数组第一元素的地址。所以可以通过数组名把数组的首地址赋值给指针变量，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure><p>输出结果：1，输出的是数组<code>a</code>的首地址，即第一个元素的值。</p><p>由此可知，<code>&amp;a[0]</code>，<code>a</code>，<code>*p</code>指向同一单元，是数组<code>a</code>的首地址。</p><h3 id="通过指针引用数组元素"><a href="#通过指针引用数组元素" class="headerlink" title="通过指针引用数组元素"></a>通过指针引用数组元素</h3><p>C语言规定：<strong>如果指针变量<code>p</code>已指向数组中的一个元素，这<code>p+1</code>指向同一数组中的下一个元素</strong>。</p><p>引入指针变量后，现在可以通过两种方式来访问数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规方式</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> c=a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针方式</span></span><br><span class="line"><span class="type">int</span> *p,a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//声明指针p和数组</span></span><br><span class="line">p=a;<span class="comment">//指针指向数组首地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p++);<span class="comment">//输出指针指向数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：1，2，3</p><h3 id="数组中的指针运算"><a href="#数组中的指针运算" class="headerlink" title="数组中的指针运算"></a>数组中的指针运算</h3><ol><li><p>加减算术运算</p><p>对于指向数组的指针变量，可以加上或者减去一个整数<code>n</code>。设<code>p</code>是指向数组<code>a</code>的指针变量，则<code>p+n</code>，<code>p-n</code>，<code>p++</code>，<code>p--</code>等运算都是合法的。<strong>指针变量加减整数的意义是将指针指向的位置向前或者向后移动<code>n</code>个位置，这里加减的单位不是以字节为单位，而是以指向的数据类型所占用的字节数为单位。</strong></p><p>【实例】指针算术运算示例</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, *p, y = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d    &quot;</span>, i, a[i]);    <span class="comment">//常规方法遍历输出数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = a;  <span class="comment">//指针指向数组首地址</span></span><br><span class="line">    y = *++p;   <span class="comment">//变量值赋值为指针向后移动一位的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ny=%d  &quot;</span>, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针值为：%d&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220127001930767.png" alt="image-20220127001930767" style="zoom:80%;" /></p></li><li><p>两个指针变量之间的运算</p><p>两个指针变量之间的加减运算是不合法的，也是无意义的，但是<strong>指针变量之间可以进行关系运算</strong>。</p><p>假设指针<code>p</code>和指针<code>q</code>指向同一数组的元素，那么：</p><ul><li><code>p&lt;q</code>：当<code>p</code>所指的元素在<code>q</code>所指的前面时，表达式值为1；反之则为0；</li><li><code>p&gt;q</code>：当<code>p</code>所指的元素在<code>q</code>所指的后面时，表达式值为1；反之则为0；</li><li><code>p==q</code>：当<code>p</code>和<code>q</code>指向同一元素时，表达式值为1；反之则为0；</li><li><code>p!=q</code>：当<code>p</code>和<code>q</code>不指向同一元素时，表达式值为1；反之则为0；</li></ul><p><strong>指针变量还可以与<code>0</code>或者<code>NULL</code>比较</strong>。</p><p><strong>设<code>p</code>为指针变量，则<code>p==0</code>或者<code>p==NULL</code>表面是空指针，它不指向任何变量；</strong><code>p!=0</code>或者<code>p!=NULL</code>表示<code>p</code>指针不是空指针。</p><p>【实例】指针变量间的关系运算</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, *y, *x;</span><br><span class="line">    x = a;</span><br><span class="line">    y = a;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x&lt;p\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d\n&quot;</span>, x,*x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d&quot;</span>, y,*y);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x&gt;p\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d\n&quot;</span>, x,*x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;地址为：%p 值为：%d&quot;</span>, y,*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ny指针是空指针&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ny指针不是空指针&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220127005945082.png" alt="image-20220127005945082" style="zoom:80%;" /></p></li></ol><h2 id="二维数组的指针表示"><a href="#二维数组的指针表示" class="headerlink" title="二维数组的指针表示"></a>二维数组的指针表示</h2><h3 id="用二维数组名表示数组元素"><a href="#用二维数组名表示数组元素" class="headerlink" title="用二维数组名表示数组元素"></a>用二维数组名表示数组元素</h3><p>如果有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[M][N];</span><br></pre></td></tr></table></figure><p>则<strong>将二维数组中的元素<code>a[i][j]</code>转换为唯一线性地址的一般公式为：线性地址$= a+i \times M + j$</strong>。</p><p>其中：<code>a</code>为数组的首地址，<code>M</code>和<code>N</code>分别为二维数组行和列的元素个数。</p><p>如下代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>],*p;</span><br><span class="line">p=a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//指针变量指向数组a的第一个元素</span></span><br></pre></td></tr></table></figure><p>则二维数组<code>a</code>的数据元素在内存中的存储顺序以及地址关系如下图所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220127155652235.png" alt="image-20220127155652235" style="zoom:75%;" /></p><p>对于数组元素<code>a[i][j]</code>，用数组名<code>a</code>的表示形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*(a+i) 取出指向i层首地址的地址</span></span><br><span class="line"><span class="comment">//*(a+i)+j 将该地址在该层移动j个单位，即指向第i层的第j个元素</span></span><br><span class="line"><span class="comment">//*(*(a+i)+j) 取出指针指向地址的值，即取出第i层的第j个元素的值</span></span><br><span class="line">*(*(a+i)+j);</span><br></pre></td></tr></table></figure><blockquote><p>数组名是一种常量指针</p></blockquote><p>【实例】关于数组指针相关问题理解</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//定义了一维数组c,二维数组a,三维数组x</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;,c[<span class="number">2</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,x[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;&#125;,&#123;&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="comment">//获取一维数组首地址的值，因为数组名是常量指针，默认指向首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;一维数组：%d\n&quot;</span>, *c);</span><br><span class="line">    <span class="comment">//获取二维数组第一层的第二个元素</span></span><br><span class="line">    <span class="comment">//*a指的是首层地址，+1是在该层的基础上移动一个单位，即首层第二个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组：%d\n&quot;</span>, *(*a+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//a[1]以及指明了数组第二层首元素的地址，*取其值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组：%d\n&quot;</span>, *a[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//*x取首层元素首地址，**x取首层元素首层元素的地址，***x取首层元素首层元素首层元素的值</span></span><br><span class="line">    <span class="comment">//因为是三维数组，所以嵌套三层才能确定具体元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;三维数组：%d\n&quot;</span>, ***x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220127165316574.png" alt="image-20220127165316574" style="zoom:80%;" /></p><h3 id="用指针表示二维数组元素"><a href="#用指针表示二维数组元素" class="headerlink" title="用指针表示二维数组元素"></a>用指针表示二维数组元素</h3><p>根据下图可知，可以通过对指针的加减来实现对二维数组元素的指向。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220127172259536.png" alt="image-20220127172259536" style="zoom:70%;" /></p><p>对于如下代码，指针指向数组元素<code>a[x][y]</code>的公式为：</p><script type="math/tex; mode=display">p+M \times N +y</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[M][N];</span><br><span class="line"><span class="type">int</span> *p=a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>a[0]</code>和<code>*a</code>指的是同一个地址</strong>，即首层首元素地址。</p></blockquote><p>【实例】利用指针输出二维数组元素值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;,*p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第%d层第%d个元素的值为：%d\n&quot;</span>, i+<span class="number">1</span>, j+<span class="number">1</span>, *(p + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220127173247410.png" alt="image-20220127173247410" style="zoom:80%;" /></p><p><strong>在C语言中，可以将一个二维数组理解为若干个一维数组构成的一维数组</strong>。所以对于<code>a[3][3]</code>数组来说，可以分解为三个一维数组：<code>a[0][0]</code>，<code>a[0][1]</code>，<code>a[0][2]</code>……<code>a[2][0]</code>，<code>a[2][1]</code>，<code>a[2][2]</code>，即可以看作由<code>a[0][0]</code>，<code>a[1][0]</code>，<code>a[2][0]</code>三个行首元素数组。</p><p><strong>行指针是一种特殊的指针变量，它们专门用于指向一维数组</strong>。定义一个行指针一般的格式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型关键字 (*行指针名)[M]</span><br></pre></td></tr></table></figure><p>其中<code>M</code>规定了行指针所指一维数组的长度，而类型关键字则指明了一维数组的类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[M];</span><br></pre></td></tr></table></figure><p>定义了行指针<code>p</code>，可以使用该行指针指向二维数组单行元素为<code>M</code>个的整型数组。</p><p>【实例】使用行指针输出二维数组中全部的元素值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>(*p)[<span class="number">3</span>],a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;<span class="comment">//声明行指针</span></span><br><span class="line">    p = a;<span class="comment">//行指针指向首行数组首地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(*p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>对<code>p</code>层加减操作是改变层数的指向，对<code>*p</code>的操作是改变的元素的指向</strong>。</p></blockquote><p>【关于指针指向多维数组的个人看法】</p><p>C语言底层就是将多维数组，例如二维数组，看成两个一维数组，这就意味着，对于二维数组<code>a</code>，之前说过数组是一个常量指针，那么<code>a</code>是指向第一个一维数组的指针，也就是说<code>a</code>存储的是一个地址，这也就是为什么如果使用普通指针指向二维数组<code>a</code>，例如：<code>*a</code>获取的只是第一个一维数组的地址，而<code>**a</code>才是获取第一个一维数组第一个元素的首元素的值。</p><h2 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h2><p>C语言没有字符串变量，对字符串的访问有两种方法。</p><ol><li><p>使用字符数组来存放一个字符串，然后采用字符数组来完成操作。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">12</span>]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br></pre></td></tr></table></figure></li><li><p>使用字符指针指向一个字符串</p><p>如果把字符数组的首地址赋给一个指针变量，那么这个指针变量指向这个数组，就可以对齐完成数组操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字符串常量对字符指针进行初始化，此时指针变量指向字符串的首地址。</span></span><br><span class="line"><span class="type">char</span> *str=<span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure></li></ol><p>【实例】编写程序完成字符串的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello world&quot;</span>;<span class="comment">//初始化字符串指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第三个字符是：%c\n&quot;</span>, str[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *str++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202135336254.png" alt="image-20220202135336254" style="zoom:80%;" /></p><blockquote><p>虽然没有定义数组<code>str</code>，但是字符串在内存中的存储方式为数组，即<code>str[2]</code>=<code>*(str+2)</code></p></blockquote><h1 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h1><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><ol><li><p><strong>指针数组的定义</strong></p><p>如果数组中每个元素的数据类型为指针类型，则这种数组称为指针数组，它是指针的集合。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型 * 数组名[常量表达式];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];<span class="comment">//表示定义一个由10个指针变量构成的指针数组。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针数组在字符串中的使用</strong></p><p>指针数组常用来表示一组字符串，这时指针数组的每个元素被赋予每个字符串的首地址。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str[<span class="number">7</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>当然也可以使用一个二维数组来表示上面的信息，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> week[<span class="number">7</span>][<span class="number">10</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>它们在内存的存储结结构如下所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202145531918.png" alt="image-20220202145531918" style="zoom:80%;" /></p><p>该数组一共占用70个字节。</p><p>如果采用指针数组来表示，由于指针数组的每个元素都是指针，因此指向每个元素的首地址，通过首地址访问该字符串。相对于二维数组可以节省内存空间。如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202150211185.png" alt="image-20220202150211185" style="zoom:80%;" /></p><p>【实例】编写程序，用星期的英文名来初始化字符指针数组，输入整数，当数为0~6时，输出对应星期的英文名，否则显示错误信息。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(<span class="type">char</span> *p[], <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *weekday[<span class="number">7</span>] = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);</span><br><span class="line">    PutOut(weekday,value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">(<span class="type">char</span> *p[],<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;=<span class="number">0</span> &amp;&amp; value&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p[value]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输出格式不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202152854487.png" alt="image-20220202152854487" style="zoom:80%;" /></p></li></ol><h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><p>一个指针可以指向任何一种数据类型，包括指向一个指针。当指针变量<code>p</code>中存放另一个指针<code>q</code>的地址时，则称为指针型指针，也称为多级指针。指针型指针（二级指针）的语法格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型标识符 ** 指针变量名;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> ** p;</span><br></pre></td></tr></table></figure><p>由于指针变量的类型是被指针所指的变量的类型，因此，上述定义中的类型标识符应为：被指针类型的指针指向的指针所指的变量的类型。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;<span class="comment">//初始化整型变量x=2</span></span><br><span class="line"><span class="type">int</span> *p;<span class="comment">//声明指针p</span></span><br><span class="line"><span class="type">int</span> **q;<span class="comment">//声明二级指针q</span></span><br><span class="line">p=&amp;x;<span class="comment">//定义指针p指向变量x</span></span><br><span class="line">q=&amp;p;<span class="comment">//定义二级指针q指向指针p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**q);<span class="comment">//输出二级指针所指向指针指向的值</span></span><br></pre></td></tr></table></figure><p>对于输出值：<code>**q</code>=<code>*(*q)</code>=<code>*p</code>=<code>x</code></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202154439120.png" alt="image-20220202154439120" style="zoom:80%;" /></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>指针很重要，万物皆指针！！！</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【7.0】C-预处理命令</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%907-0%E3%80%91C-%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%907-0%E3%80%91C-%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>预处理是在进行编译的第一遍扫描（扫描语法和词法）之前所做的工作，是C语言的一个重要功能，它由预处理程序负责完成。</p><p>前面的代码已经多次使用<code>#</code>开头的预处理命令，例如：<code>#include &lt;stdio.h&gt;</code>等，在源程序中这些命令都放在函数之外，而且一般都放在源文件的前面。</p><p>C语言提供了多种预处理命令，如宏定义，文件包含，条件编译等。<strong>C语言的预处理命令均是以<code>#</code>开始，末尾不加分号</strong>。合理的使用预处理指令可以使得程序便于阅读，修改和调试。</p><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p><strong>在C语言源程序中允许用一个标识符来表示一个字符串，称为宏。被定义为宏的标识符称为宏名。在编译预处理时，对程序中所有出现的宏名，都用宏定义的字符串去替换，这称为宏替换或者宏展开</strong>。</p><p>宏定义是由源程序中的宏定义命令完成的，宏替换是由预处理程序自动完成的。</p><p>宏定义是C语言提供的三种常用预处理命令中的一种，使用宏定义可以防止出错，并且可以提高程序的可移植性和可读性。宏分为不带参数和带参数两种。</p><h2 id="不带参数的宏定义"><a href="#不带参数的宏定义" class="headerlink" title="不带参数的宏定义"></a>不带参数的宏定义</h2><p>不带参数的宏定义语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 字符串</span></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>其中<code>#</code>表示这是一条预处理命令。<code>define</code>为宏定义命令。标识符就是所谓的符号常量，也称为宏名。字符串可以是参数，表达式，格式串等。</p><p>预处理工作也称为宏展开，就是将宏名替换为字符串。掌握宏的关键就是“换”。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>它的作用就是指定标识符<code>PI</code>来代替常量3.14。在编写程序的时候，所有的3.14都可以使用<code>PI</code>来表示，而对于源程序编译的时候，将由预处理程序进行宏替换，即将<code>PI</code>的部分再替换回3.14，然后再进行编译。</p><p>关于宏定义的说明：</p><ol><li><p><strong>宏名习惯上用大写字母表示，以便于与变量区别</strong>，不过你也可以使用小写</p></li><li><p>使用宏可以提高程序的拓展性和易读性。</p></li><li><p><strong>预处理是在编译之前进行的处理，而编译的工作之一就是语法检查，也就是说，预处理不做语法检查</strong>。</p></li><li><p>宏定义不是语句，<strong>在句末不必加分号，如果加上分号，则连分号一起替换</strong>。</p></li><li><p><strong>宏定义必须写在函数外，默认其作用域为：从宏定义命令开始到程序结束。</strong></p><p><strong>如果要终止其作用域可以使用<code>#undef</code>命令</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//很多代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="comment">//又是很多代码</span></span><br></pre></td></tr></table></figure><p>表示该宏定义只在<code>main</code>函数中有效。</p></li><li><p>宏定义允许嵌套，在宏定义的字符串中可以使用已定义的宏名。在宏展开时由预处理程序层层替换。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3,14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C 2*PI</span></span><br><span class="line"><span class="comment">//以上宏定义的不限制顺序，例如下面的和上面的结果是一致的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C 2*PI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3,14</span></span><br></pre></td></tr></table></figure></li><li><p>宏定义不分配存储空间，变量定义才分配存储空间。</p></li><li><p>宏定义以回车符结束，如果宏定义超过一行，可以在行末加反斜杠<code>\</code>来续行。</p></li><li><p>宏定义中也可以没有替换的字符串，这种宏定义常作为条件编译检测的一个标志。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG</span></span><br></pre></td></tr></table></figure><p>【关于宏定义无字符串的意义】</p><p>【说明】<strong>这部分解释需要学会下面的条件编译命令再看</strong></p><p>比如：<code>#define USEHDMI</code>表示定义<code>USEHDMI</code>这个宏，但内容是空的，这样的宏一般不会用于替换<br>-用途：在程序中会这样用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">ifdef</span> USEHDMI</span></span><br><span class="line">... <span class="comment">//宏被定义时的处理程序</span></span><br><span class="line">\<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">... <span class="comment">//宏未被定义时的程序</span></span><br><span class="line">\<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样假设我们在使用HDMI接口时会在头文件中写：<code>#define USEHDMI</code>，或写<code>#define USEHDMI 1</code>也是一样的，否则用默认模式可注释此句或写：<code>#undef USEHDMI</code>，即可实现程序增加处理HDMI接口的部分，或者去除。</p><blockquote><p>以上解释出自<a href="https://zhidao.baidu.com/question/1365904455539906219.html">c++程序中宏定义只有宏名没有字符串是怎么一回事</a></p></blockquote></li><li><p><strong>字符，字符串和注释中永远不做宏处理</strong>，即如果在其中包含宏字符，不会进行宏替换处理。</p><blockquote><p>需要注意的是，变量和宏名不可以相同</p></blockquote><p>【实例】验证宏名和字符串</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI %f\n&quot;</span>, PI);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121162246646.png" alt="image-20220121162246646" style="zoom:80%;" /></p></li></ol><h2 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h2><p>C语言允许宏带有参数。宏定义中的参数称为形参，宏调用中的参数称为实参。对于带参数的宏，在调用中，不仅要宏展开，还要用实参去代替形参。</p><p>带参数的宏定义一般形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(参数列表) 字符串</span></span><br></pre></td></tr></table></figure><p>在字符串中可以含有多个形参。</p><p>带参数宏调用的一般形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏名(实参列表)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S(a,b) a*b</span></span><br><span class="line">area=S(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//第一步替换为area=a*b,第二部替换为area=3</span></span><br></pre></td></tr></table></figure><p>【实例】利用带参数的宏定义求三个数的最小值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Min(a,b) (a&lt;b)?a:b  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z, min;   <span class="comment">//声明三个数值和最小值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数值&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    min = Min(x, y);</span><br><span class="line">    min = Min(min, z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小值为;%d&quot;</span>, min);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121164749966.png" alt="image-20220121164749966" style="zoom:80%;" /></p><p>关于带参数的宏定义需要注意以下几点：</p><ol><li><p><strong>宏名和参数的括号间不能有空格</strong>。</p></li><li><p>宏替换只做替换，不做计算，不做表达式求解。</p></li><li><p>在宏定义中形参是标识符，而宏调用中的实参可以是表达式。</p></li><li><p>在带参数宏定义中，形参不分配存储空间，因此不必进行类型声明，而宏调用中的实参有具体的值，要用它们去替换形参，因此必须进行类型声明。</p></li><li><p>带参数的宏和带参数函数很相似，但有本质上的不同：</p><p>函数调用在编译后程序运行时进行，占用运行时间（分配内存，保留现场，值传递，返回值）；宏替换在编译前进行，不分配内存，不占用运行时间，只占用编译时间。</p><p>在函数中，形参和实参是两个不同的量，各有自己的作用域，调用时要把实参传递给形参，进行“值传递”；而在带参数宏中，只是符号替换，不存在值传递。</p><p>函数只有一个返回值，利用宏可以设法得到多个返回值；</p><p>宏展开使源程序边长。</p></li><li><p>宏定义也可以用来定义多个语句，在宏调用时，把这些语句替换到源程序中。</p></li></ol><h2 id="撤销宏定义命令"><a href="#撤销宏定义命令" class="headerlink" title="撤销宏定义命令"></a>撤销宏定义命令</h2><p>宏定义命令<code>#define</code>应该写在函数外面，通常写在一个文件开头，这样宏定义的作用范围是整个文件。<strong>可以使用命令<code>#undef</code>撤销已定义的宏，终止该宏定义的作用域</strong>。</p><p>【实例】撤销已定义的宏示例</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14<span class="comment">//宏定义PI=3.14</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;派值为;%f&quot;</span>, PI);</span><br><span class="line">    Test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI<span class="comment">//终止宏定义PI</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121170916060.png" alt="image-20220121170916060" style="zoom:80%;" /></p><h1 id="文件包含命令"><a href="#文件包含命令" class="headerlink" title="文件包含命令"></a>文件包含命令</h1><p><strong>文件包含是指一个源文件可以将另一个源文件的全部内容包含进来，即将另一个文件包含到本文件中</strong>。文件包含命令是以<code>#include</code>开头的预处理命令，在前面的部分使用各种C语言自带的函数时已经使用了文件包含命令。在C语言中，这个命令可以使得程序分为多个模块，被不同的程序员编写。有些公用的符号常量或宏定义等可以单独组成一个文件，在其他文件的开头用文件包含命令包含该文件即可使用。这样可以避免在每个文件开头编写这些公用量，从而节省时间，减少出错。</p><p>文件包含命令语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名&quot;</span></span></span><br><span class="line"><span class="comment">//格式2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>格式1：系统先在本程序文件所在的磁盘和路径下寻找包含文件，若找不到，再按系统规定的路径搜索包含文件</strong>。</p><p><strong>格式2：系统仅按规定的路径搜索包含文件：在包含文件目录中查找（包含目录是由用户在设置环境是设置的），而不在源文件目录去查找。</strong></p><p>需要注意的是：</p><ol><li><strong>一个<code>#include</code>命令只能包含一个文件，若有多个文件要包含，则需要用多个<code>#include</code>命令</strong>。</li><li>为了避免寻找包含文件时出错，如果是包含系统头文件通常使用格式2，其他情况使用格式1</li><li><strong>由于被包含文件的内容全部出现在源程序清单中，所以其内容必须是C语言的源程序清单，否则编译时会出错</strong>。</li><li>文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。</li><li>文件包含命令还有一个很重要的功能：能将多个源程序清单合并成一个源程序进行编译。</li></ol><p>【实例】包含多个文件合并编译</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(a,b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutOut</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出结果为：\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件3：主入口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;2.1.c&quot;</span><span class="comment">//载入文件1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;2.2.c&quot;</span><span class="comment">//载入文件2</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    PutOut();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Plus(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121183257670.png" alt="image-20220121183257670" style="zoom:80%;" /></p><h1 id="条件编译命令"><a href="#条件编译命令" class="headerlink" title="条件编译命令"></a>条件编译命令</h1><p><strong>一般情况下，源程序中所有的行都参加编译，但有时希望其中的部分内容只有在满足一定的条件下才进行编译，即对一部分内容指定编译条件，这就是条件编译</strong>。条件编译命令将决定哪些代码被编译，哪些不被编译。可将表达式的值或某个特定宏是否被定义作为编译条件。</p><p>条件编译有三种语法格式，代码如下：</p><ul><li><p>格式一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>      </span></span><br></pre></td></tr></table></figure><p>其功能是，<strong>如果标识符已使用<code>#define</code>命令定义则对程序段1进行编译，否则对程序段2进行编译</strong>。如果没有程序段2，则可以写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br></pre></td></tr></table></figure></li><li><p>格式二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> 标识符</span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br></pre></td></tr></table></figure><p><strong>与格式一不同的是由<code>#ifdef</code>变为<code>#ifndef</code>，它的功能是，如果标识符未被<code>#define</code>命令定义，则对程序段1进行编译，否则对程序段2进行编译</strong>。</p><p>【实例】进行条件编译命令</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> PI</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, PI);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI未定义&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121210007943.png" alt="image-20220121210007943" style="zoom:80%;" /></p></li><li><p>格式三：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>        </span></span><br></pre></td></tr></table></figure><p>其功能是，<strong>如果常量表达式的值为真（非0），则对程序段1进行编译，反之则对程序段2进行编译。</strong>因此可以使程序在不同条件下完成不同的功能。</p><p>【实例】测试格式三</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c 1 <span class="comment">//c的值非0时，执行加法，反之执行减法</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a加b的和为：%d&quot;</span>, a + b);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a和b的差为：%d&quot;</span>,a-b);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220121211515511.png" alt="image-20220121211515511" style="zoom:80%;" /></p><blockquote><p>对于预处理命令里的标识符或者变量，和代码中定义的不通用，且名称不可重复</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 宏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6.0】C-函数</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%906-0%E3%80%91C-%E5%87%BD%E6%95%B0/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%906-0%E3%80%91C-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数是组成C语言的基本单位，为了提高程序设计的质量和效率，C系统提高了大量的标准函数。例如前面部分提到的<code>printf()</code>，<code>scanf()</code>等函数。同样的，我们可以根据我们的实际需求来定义我们的函数。</p><p>【关于<code>Function</code>(函数)翻译问题】</p><p>如果你学过或者接触过现代的一些计算机语言，获取你会了解到一个词——“<strong>方法</strong>”。不论是函数也好，方法也罢，都是出自这个次——<code>Function</code>，就个人经验而言，这是个翻译的历史遗留问题，早起计算机进入我国的时候，那个时候没有相关的经验和相关书籍的参考，再加上一开始的计算机是数学领域发展起来的，就通俗的直译为——函数，由于现代计算机的发展和大量的经验，对于程序员来说，函数这个词非常的抽象，没有办法形成——望文知意，经过本土化，翻译为方法更复合实际，所以你如果接触过相对现代一些的教程都是说是方法而不是函数。</p><p>当然还有另一个说法，是对于面向过程编程语言，称为函数，而面向对象编程语言，称为方法。</p><p>（PS：面向对象编程是在面向对象过程编程的基础上发展而来的）</p><p>以上两种解释没有谁对谁错，此处仅做说明，以防初学者出现歧义。</p><h1 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h1><h2 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h2><p>在前面的所有示例中，一个程序中只有一个<code>main()</code>函数。对于复杂的程序，如果只有一个<code>main()</code>函数，将会影响程序的可读性，也不能体现程序的结构化设计的思想。因此，需要将某种特定功能的代码定义为函数，一个程序由<code>main()</code>函数和若干函数组成，每个函数在程序中形成即相对独立又相互联系的模块。<strong><code>main()</code>函数可以调用其他函数，其他函数也可以相互调用</strong>。</p><p>一个简单的函数代码示例：</p><p>【实例】实现两数加法运算。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">()</span>;<span class="comment">//声明函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Plus(x, y));<span class="comment">//调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="comment">//函数定义</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p><strong>从用户使用的角度来说，C语言的函数可以分为库函数和用户自定义函数</strong>。库函数是系统提供的，用户不必自己定义而可以直接使用。<strong>库函数由系统预定义在相应的文件中，使用时需要在程序的开头把该函数所在的头文件包含进来</strong>。例如，为了调用<code>printf()</code>，<code>scanf()</code>函数，需要调用<code>#include &lt;stdio.h&gt;</code>包含<code>stdio.h</code>头文件；为了调用<code>sqrt()</code>，<code>log()</code>函数，需要调用<code>#include &lt;math.h&gt;</code>包含<code>math.h</code>头文件。</p><p>使用库函数需要注意以下几个问题：</p><ul><li>函数的功能</li><li>函数参数的数目和顺序，以及每个参数的意义以及类型</li><li>函数的返回值的意义以及类型</li><li>需要使用的包含文件</li></ul><blockquote><p>常用的标准函数库参考<a href="https://www.runoob.com/cprogramming/c-standard-library-stddef-h.html">C 标准库</a></p></blockquote><p>有关问题底层大全等可以查询<a href="https://docs.microsoft.com/zh-cn/documentation/">微软文档</a>。</p><h1 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h1><h2 id="函数定义的格式"><a href="#函数定义的格式" class="headerlink" title="函数定义的格式"></a>函数定义的格式</h2><p><strong>函数由函数名，形参列表和函数体组成</strong>。函数名是用户为函数起的名字，用来标识唯一一个函数；函数的形参列表用来接受调用函数传递的数据，形参列表可以为空，此时函数名后的括号不可以省略；函数体是函数实现自身功能的一组语句。</p><ol><li><p><strong>无参数函数的定义格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名称()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型声明符指定函数值的类型，即函数返回值的类型。如果一个函数没有返回值，该函数的返回值类型为<code>void</code></strong>。函数名称的命名规则与变量的名称规则相同。</p></li><li><p><strong>有参数函数的定义格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名称(形参列表声明)&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，类型声明符号指定函数返回值的类型，可以是任何有效类型，如果省略类型声明符号，系统默认函数的返回值为<code>int</code>类型。如果函数只是执行相关操作而不需要返回值，则可以使用<code>void</code>。</p><p>有参函数在函数名称后的括号内必须有形式参数表，用于调用函数和被调用函数之间的数据传递，故必须对其进行类型声明，这由形式参数声明部分完成。一般情况下，函数执行需要多少原始外部数据，就有多少个形参数据，<strong>形参之间用逗号隔开</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="comment">//定义自定义函数</span></span><br><span class="line">    <span class="keyword">return</span> a + b;<span class="comment">//返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>空函数</strong></p><p>C语言中可以有空函数，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名()\</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数，什么工作都不做。在主函数调用该函数，可以暂时表示某功能，后期扩充的时候填充该函数。</p></li></ol><h2 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h2><p>在调用有参函数时，主调函数和被调函数之间往往有数据传递关系。<strong>在定义函数时函数名后面小括号内的变量为形式参数（简称形参）</strong>，函数调用时用于接收主调函数传来的数据。在调用函数时，<strong>主调函数的函数调用语句的函数名后面小括号的参数称为实际参数（简称实参）</strong>。</p><p>【实例】编写函数求三个整数中的最小值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxV</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        max = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        max = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max&lt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        max = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d&quot;</span>, MaxV(x,y,z));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116221916755.png" alt="image-20220116221916755" style="zoom:80%;" /></p><p>【实例】求三个实数的平均值</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Age</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span>&#123;</span><br><span class="line">    <span class="type">float</span> x = (a + b + c) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">6</span>;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> z = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%f&quot;</span>, Age(x,y,z));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116222636066.png" alt="image-20220116222636066" style="zoom:80%;" /></p><blockquote><p>如果你把形参的类型改为<code>int</code>类型，则返回的值为4</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>通常是系统通过函数调用使主函数从被调函数得到一个确定的值，这就是函数的返回值。<strong>在C语言中，是通过<code>return</code>语句来实现的</strong>。<code>return</code>语句一般有以下3种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 表达式;</span><br><span class="line"><span class="keyword">return</span> (表达式);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><code>return</code>语句有双重作用：<strong>它使得函数从被调函数中退出，返回到调用的代码处，并向调用函数返回一个确定的值</strong>。</li><li>一个函数中可以用有多个<code>return</code>语句，执行到哪一个<code>return</code>语句，哪个<code>return</code>语句就起作用。</li></ol><h1 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h1><p>所谓函数的调用，是指一个函数（主调函数）暂时中断本函数的运行，转去执行另一个函数（被调函数）的过程。被调函数执行完成后，返回调用函数中断处继续调用函数的运行，则是一个返回过程。<strong>函数的一次调用必定伴随着一个返回过程，在函数的调用和返回这个过程中，两个函数之间发生信息的交换</strong>。</p><h2 id="函数调用的一般形式"><a href="#函数调用的一般形式" class="headerlink" title="函数调用的一般形式"></a>函数调用的一般形式</h2><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数列表);</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>如果调用无参函数，则实参列表可以没有，但是括号不能省略。</li><li>实参列表的参数类型和个数必须与形参相同且顺序一致，多个实参之间用逗号隔开。</li></ol><h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><p>按照被调用函数在主调函数中出现的位置和完成的功能划分，函数调用有如下方式：</p><ol><li><p>把函数调用作为一个语句。此时一般不需要返回值，只需要执行特定的操作。</p></li><li><p>在表达式中调用函数，这种表达式称为函数表达式。此时要求函数返回一个值参与运算，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=c*Plus(a,b,c);</span><br></pre></td></tr></table></figure></li><li><p>将函数调用作为另一个函数调用的参数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>,Sum(a,b));</span><br></pre></td></tr></table></figure></li></ol><p>【实例】编写函数判断一个数是否是素数</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsPrimeint</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">1</span> || x==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果一个数n可以被2~(n-1)之间的数除，则不是素数，返回1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x<span class="number">-2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;prime);</span><br><span class="line">    <span class="keyword">if</span> (IsPrimeint(prime)==<span class="number">1</span>)<span class="comment">//根据返回值来判断是否是素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不是素数&quot;</span>, prime);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是素数&quot;</span>, prime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116232953286.png" alt="image-20220116232953286" style="zoom:80%;" /></p><h2 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a>函数的调用过程</h2><p>代码示例如上面的示例，图示如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116233320143.png" alt="image-20220116233320143" style="zoom:80%;" /></p><h2 id="函数的原型声明"><a href="#函数的原型声明" class="headerlink" title="函数的原型声明"></a>函数的原型声明</h2><p>与变量的定义和使用一样，<strong>函数的调用也要遵循“先声明，后调用”</strong>的原则。在一个函数调用另一个函数时，需要具备以下条件：</p><ol><li><p>被调函数必须已经存在。</p></li><li><p>如果使用库函数，需要提前引用相关库函数。</p></li><li><p><strong>如果使用用户自定义函数，并且该函数与主调函数在同一个文件中，这时被调用函数应该放在主调函数之前定义。如果函数调用的位置在函数定义之前，则在函数调用之前必须对所调用的函数进行函数原型声明</strong>，函数原型声明的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型声明符 函数名(形参表);</span><br></pre></td></tr></table></figure></li></ol><p>函数原型声明是向编译器表示一个函数的名称，将接收什么样的参数和有什么样的返回值，使编译器能够检查函数调用的合法性。实际上就是函数定义时的函数头，最后加上分号构成的声明语句。<strong>与函数头的区别是，函数声明中的形参列表中可以只写类型名，而不写形参名</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span>;</span><br><span class="line"><span class="comment">//可以写为</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">float</span>,<span class="type">float</span>,<span class="type">float</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>在C语言中进行函数调用时，有两种不同的参数传递方式：<strong>值传递和地址传递</strong>。</p><ol><li><p><strong>值传递</strong></p><p><strong>在函数调用时，实参将其值传递给形参</strong>。这种传递方式即为值传递。</p><p>C语言规定，实参对形参的数据传递是值传递，即单向传递，也就是只能由实参传递给形参而不能由形参传递回来给实参。这是因为，<strong>在内存中，实参和形参占用不同的存储单元</strong>。在调用函数时，给形参分配存储单元，并将实参对应的值传递给形参，调用结束后，形参的存储单元会被释放，实参的存储单元仍要保留维持原值。因此，在执行一个被调用函数时，形参的变化不会改变实参的值。</p></li><li><p><strong>地址传递</strong></p><p><strong>地址传递指的是函数调用时，实参将某些量的地址传递给形参</strong>。这样实参和形参指向同一个内存空间，在执行被调函数的过程中，对形参所指向的空间中的内容改变能够直接影响到实参的值。</p><blockquote><p>在地址传递方式下，形参和实参可以是指针变量（欠-指针）</p></blockquote></li></ol><h1 id="函数的嵌套调用和递归调用"><a href="#函数的嵌套调用和递归调用" class="headerlink" title="函数的嵌套调用和递归调用"></a>函数的嵌套调用和递归调用</h1><h2 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h2><p>C语言中的函数的定义是相互平行的，在定义函数时，一个函数不能包含另一个函数。但是，一个函数在被调用的过程中可以调用其他函数，这就是函数的嵌套调用。</p><p>如下为常规的嵌套调用图示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117144058984.png" alt="image-20220117144058984" style="zoom:80%;" /></p><p>【实例】计算1+$2!$+$3!$+·····+$10!$。（使用嵌套函数）</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//和的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum(Fac(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;阶乘的和为：%d&quot;</span>, sum);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    sum += num;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res *= (i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117145914488.png" alt="image-20220117145914488" style="zoom:80%;" /></p><h2 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h2><p><strong>在调用一个函数的过程中又直接或者间接的调用该函数本身，称为函数的递归调用</strong>。</p><p>递归是一种非常实用的程序设计技术。许多问题具有递归的特性，在某些情况下，用其他方法很难解决的问题，利用递归可以轻松解决。</p><p>【实例】利用递归安抚计算$n!$。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> facRes = <span class="number">1</span>;<span class="comment">//阶乘结果返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//自定义阶乘函数原型声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);<span class="comment">//获取要求的阶乘</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d!阶乘的结果为：%d&quot;</span>,num, Fac(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//阶乘计算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        facRes *= num;</span><br><span class="line">        Fac(num - <span class="number">1</span>);<span class="comment">//递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> facRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117153716073.png" alt="image-20220117153716073" style="zoom:80%;" /></p><h1 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h1><p>关于函数的形参前面说明过支持任何类型的参数，同样的数组也是支持的。</p><h2 id="一维数组作为函数参数"><a href="#一维数组作为函数参数" class="headerlink" title="一维数组作为函数参数"></a>一维数组作为函数参数</h2><p><strong>用数组名作为函数实参时，向形参传递的是数组的地址值</strong>。在定义数组形参时，只需要在后面跟一个方括号就可以。</p><p>【实例】求一组整数的平均值（一维数组）</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Avg</span><span class="params">(<span class="type">int</span> x[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均值为：%f&quot;</span>, Avg(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平均函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Avg</span><span class="params">(<span class="type">int</span> x[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117161707032.png" alt="image-20220117161707032" style="zoom:80%;" /></p><h2 id="二维数组作为函数的参数"><a href="#二维数组作为函数的参数" class="headerlink" title="二维数组作为函数的参数"></a>二维数组作为函数的参数</h2><p><strong>可以使用二维数组名作为函数参数，此时的实参可以直接使用二维数组名，在被调函数中可以指定形参所有维数的大小，也可以省略一维大小的声明</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> x[<span class="number">3</span>][<span class="number">10</span>])</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> x[][<span class="number">10</span>])</span>;</span><br></pre></td></tr></table></figure><p>这两个声明都是合法的，<strong>但是不能把第二维或者更高维度的大小省略</strong>，例如下面的定义说不合法的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> x[][])</span>;</span><br></pre></td></tr></table></figure><p>在第二维相同的情况下，形参数组的第一维可以与实参数组不同，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实参为：</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//形参可以定义为：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">10</span>])</span>;</span><br><span class="line"><span class="comment">//形参或者为：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">8</span>][<span class="number">10</span>])</span>;</span><br></pre></td></tr></table></figure><p>以上两种形参定义都是可以的，这是形参数组和实参数组都是由相同类型的一维数组组成的，<strong>C语言系统不检查第一维度的大小</strong>。</p><p>【实例】实现两个 3 $\times$ 4 矩阵A和B的加法运算。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> b[][<span class="number">4</span>])</span>;<span class="comment">//自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> res[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//矩阵和结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//获取需要计算的矩阵A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵A第%d行数据 | &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a[i][<span class="number">0</span>], &amp;a[i][<span class="number">1</span>], &amp;a[i][<span class="number">2</span>], &amp;a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//获取需要计算的矩阵B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入矩阵B第%d行数据 | &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;b[i][<span class="number">0</span>], &amp;b[i][<span class="number">1</span>], &amp;b[i][<span class="number">2</span>], &amp;b[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;矩阵的和为:\n&quot;</span>);</span><br><span class="line">    Plus(a, b);<span class="comment">//调用自定义函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵和计算函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>],<span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j] = a[i][j] + b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, res[i][<span class="number">0</span>], res[i][<span class="number">1</span>], res[i][<span class="number">2</span>], res[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117212546625.png" alt="image-20220117212546625" style="zoom:80%;" /></p><h1 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h1><p>C语言程序是由一些函数组成的。每个函数都是相对独立的代码块，这些代码只局限于该函数。因此，在非特殊说明下，一个函数的代码对于程序的其他部分来说是隐藏的，它既不会影响程序的其他部分，也不会受程序其他部分的影响。也就是说一个函数的代码和数据不可能与另一个函数的代码和数据相互作用。这是因为它们分别有着自己的作用域。<strong>根据作用域的不同，变量分为两种类型：局部变量和全局变量</strong>。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p><strong>在函数内部定义的变量称为局部变量。局部变量的作用域仅局限于定义它的函数中</strong>。例如：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117213754751.png" alt="image-20220117213754751"  /></p><p>说明：</p><ol><li>主函数<code>main()</code>中定义的变量也是局部变量，仅在<code>main()</code>函数中有效。</li><li><strong>形参也是局部变量</strong>，只能在定义它的函数中有效。</li><li>不同的函数中，可以使用相同名称的局部变量，它们代表不同的对象，互不干扰。</li></ol><p>【实例】判断下述代码的运行结果</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117214820769.png" alt="image-20220117214820769" style="zoom:80%;" /></p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p><strong>在函数体外定义的变量称为全局变量</strong>，全局变量的作用域是从它的定义点开始到文件结束，即位于全局变量定义后面的所有函数都可以使用该变量。</p><p>说明：</p><p><strong>如果要在定义全局变量之前使用函数中的使用该变量，则需要在该函数中使用关键词<code>extern</code>对全局变量进行外部声明</strong>。</p><p>【实例】<code>extern</code>关键字使用</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> a, b;<span class="comment">//全局变量原型声明</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d&quot;</span>, a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure><p>【输出】 a=1 b=2</p><p>【实例】全局变量与局部变量同名，分析结果</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    Test(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数变量%d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b+ ++a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117222317221.png" alt="image-20220117222317221" style="zoom:80%;" /></p><p>利用全局变量可以减少函数实参的个数，从而减少内存空间以及传递数据时的时间消耗。但是一般还是建议除非必要，尽量不要使用全局变量，因为：</p><ol><li><strong>全局变量使函数的执行依赖于外部变量，降低了程序的通用性</strong>。模块化程序设计要求各个模块之间的“关联性”应尽量的小，函数尽可能是封闭的，只通过参数与外界发生联系。</li><li>降低程序的清晰性。</li><li>全局变量在整个程序的执行过程中都会占用存储空间。</li></ol><h1 id="变量的存储类别"><a href="#变量的存储类别" class="headerlink" title="变量的存储类别"></a>变量的存储类别</h1><p><strong>从变量的作用域，即空间的角度看，变量分为局部变量和全局变量</strong>。</p><p><strong>从变量的生存期，即变量的存在时间看，变量可以分为静态变量和动态变量</strong>。静态变量和动态变量是按照其存储方式来区分的。<strong>静态存储方式是指在程序运行期间分配固定的存储空间，程序执行完毕才释放。动态存储方式是在程序运行期间根据需要动态的分配存储空间</strong>，一旦动态过程结束，不论程序是否结束，都将释放存储空间。</p><p><strong>在C语言中，供用户使用的存储空间分为三部分，即程序区，静态存储区和动态存储区。</strong></p><ul><li><strong>程序区：存放用户程序</strong>。</li><li><strong>静态存储区：存放全局变量，静态局部变量和外部变量</strong>。</li><li><strong>动态存储区：存放局部变量，函数形参变量</strong>。</li></ul><blockquote><p><strong>CPU寄存器存放寄存器变量</strong></p></blockquote><p>【关于静态局部变量的作用】</p><p>我在看到静态局部变量的时候，第一反应是这个有什么用？局部使用使用完成都不再使用，为何使用静态来占用内存，目前我大概理解两种静态局部变量的适用情况：</p><ul><li><p>变量如果没有赋初值，对于一般的变量其值系统给的是<code>NULL</code>，静态局部变量系统会赋予初始值0；</p></li><li><p>静态局部变量占用内存，其值会一直保存，可以适用于需要多次调用某方法，但是值要增加的条件等，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Plus</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主函数变量%d&quot;</span>, Plus());<span class="comment">//调用三次，获得三次不同的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Plus</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;<span class="comment">//静态局部变量</span></span><br><span class="line">    a++;<span class="comment">//自增</span></span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：主函数变量1 主函数变量2 主函数变量3</p></li></ul><blockquote><p>详细相关静态局部变量的内容查看<strong>局部变量的存储类型-静态局部变量</strong></p></blockquote><p>C语言有4种变量存储类别声明符，用来通知编译程序采用哪种方式存储变量，这4种变量存储类别声明符是：</p><ul><li><strong>自动变量声明符<code>auto</code>（一般省略）</strong></li><li><strong>静态变量声明符<code>static</code></strong></li><li><strong>外部变量声明符<code>extern</code></strong></li><li><strong>寄存器变量声明符<code>register</code></strong></li></ul><h2 id="局部变量的存储类型"><a href="#局部变量的存储类型" class="headerlink" title="局部变量的存储类型"></a>局部变量的存储类型</h2><p><strong>局部变量可有3种存储类型：自动变量，局部静态变量和寄存器变量</strong>。</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>自动变量是C语言中使用最多的一种变量。因为建立和释放这种类型的变量，都是系统自动进行的，所以称为自动变量。声明自动变量的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">auto</span>] 类型声明符 变量名;</span><br></pre></td></tr></table></figure><p>其中，<code>auto</code>是自动变量存储类别声明符，一般可以省略。如果省略，系统默认该变量为<code>auto</code>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>自动变量是在动态存储区分配存储单元的。在一个函数中定义自动变量，在调用次函数时才会给变量分配存储空间，当函数执行完毕，这些单元被释放，自动变量中存放的数据也随之丢失。每次调用函数，自动变量重新被赋值，且其默认初值是不确定的。</p><h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><p>如果希望在函数调用结束后仍然保留其中定义的局部变量的值，则可以将局部变量定义为局部静态变量。声明局部静态变量的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> 类型声明符 变量名;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>局部静态变量是在静态存储区分配存储单元的。<strong>一个变量被声明为静态，在编译时即分配存储空间，在整个程序运行期间都不释放。因此，函数调用结束后，它的值并不消失，其值能够保持连续性</strong>。</li><li>局部静态变量是在编译过程中赋予初值的，且只赋予一次初值，在程序运行时其初值已定，以后每次调用函数时，都不再赋予初值，而是保留上一次函数调用结束时的结果。</li><li><strong>局部静态变量在未显式初始化时，编译系统把它们初始化为 <code>0</code>（整型变量），<code>0.0</code>（实型变量），<code>\0(空字符)</code>（字符型变量）</strong>。</li></ol><h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>寄存器变量具有与自动变量完全相同的性质。<strong>当把一个变量指定为寄存器存储类型时，系统将它们放在CPU中的一个寄存器中，通常把使用频率较高的变量（如循环次数较多的循环变量）定义为<code>register</code>类型</strong>。</p><p>【实例】寄存器变量的应用</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i+<span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d &quot;</span>, j, i, j * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220117235837946.png" alt="image-20220117235837946" style="zoom:80%;" /></p><p>说明：</p><ol><li><strong>只有局部自动变量和形参可以作为寄存器变量，其他（如全局变量，局部静态变量则不行）</strong>。</li><li><strong>只有<code>int</code>,<code>char</code>和指针类型变量可以定义为寄存器类型，而<code>long</code>,<code>double</code>和<code>float</code>型变量不能设定为寄存器类型，因为它们的数据长度已经超出通用寄存器本身的位长。</strong></li><li>可用于变量空间分配的寄存器的个数依赖于具体的机器</li></ol><h2 id="全局变量的存储类别"><a href="#全局变量的存储类别" class="headerlink" title="全局变量的存储类别"></a>全局变量的存储类别</h2><p>全局变量是在静态存储区域分配单元的，其默认值初值为0。全局变量的存储类型有两种，即外部<code>extern</code>类型和静态<code>static</code>类型。</p><h3 id="外部全局变量"><a href="#外部全局变量" class="headerlink" title="外部全局变量"></a>外部全局变量</h3><p><strong>在多个源程序文件的情况下，如果在一个文件中要引用其他文件中定义的全局变量，则应该在需要引用变量的文件中，使用<code>extern</code>进行该变量的声明</strong>。</p><p>【实例】调用其他文件的全局变量</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件一代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span>;<span class="comment">//在文件二自定义函数原型声明</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">32</span>;<span class="comment">//全局变量声明定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Test();<span class="comment">//调用文件二自定义函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件二代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;<span class="comment">//文件一全局变量原型声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> c = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】32</p><p>说明：</p><ol><li><p><code>extern</code>只能用来声明变量，不能用来定义变量。因为它不会生成新的变量，只是表示该变量已在其他地方有过定义。</p></li><li><p><code>extern</code>用来声明变量时，类型名可以写，也可以不写，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">extern</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>extern</code>不能用来初始化变量</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h3><p>在程序设计时，<strong>如果希望在一个文件中定义的全局变量仅限于被本文件引用，而不能被其他文件访问，则可以在定义次全局变量前面加上<code>static</code>关键词</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>此时，全局变量的作用域仅限于本文件内，其他文件中即使进行了<code>extern</code>声明，也无法使用该变量。</p><p>由此可见，<strong>静态全局变量与外部全局变量在同一个文件的作用域是一样的，但是外部全局变量的作用域可以延伸至其他程序文件，而静态全局变量在被定义的文件以外是不可见的</strong>。</p><h1 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h1><p>C语言由函数组成的，这些函数既可以在一个文件中也可以在多个不同的文件中，根据函数的使用范围，可以将其分为<strong>内部函数和外部函数</strong>。</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>使用存储类别<code>static</code>定义的函数称为内部函数，其一般形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> 类型声明符 函数名(形参表);</span><br></pre></td></tr></table></figure><p>内部函数又称为静态函数。内部函数只能被本文件中的其他函数所调用，而不能被其他外部文件调用。使用内部函数，可以使函数局限于所在文件，如果在不同的文件中有同名函数，则互不干扰。</p><h2 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h2><p><strong>使用存储类别<code>extern</code>（或者没有指定存储类别）定义的函数，其作用域是整个程序的各个文件，可以被其他文件的任何函数调用，称为外部函数</strong>。一般函数没有指定存储类别，都是外部函数。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> 类型声明符 函数名(形参表);</span><br></pre></td></tr></table></figure><p>由于函数都是外部性质的，因此，在定义函数时，关键字<code>extern</code>可以省略。</p><p>在调用函数的文件中，一般要用<code>extern</code>声明所用的函数是外部函数。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【5.0】C-数组</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%905-0%E3%80%91C-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%905-0%E3%80%91C-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于大规模的数据，尤其是相互之间存在一定的联系的数据，怎么表示和组织才能达到高效呢？C语言的数组类型为同类型的数据组织提供了一种有效的形式。</p><p>同样的，字符串应用广泛，但C语言中没有专门的字符串类型，字符串是使用字符数组来存放的。</p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="一维数组的定义和引用"><a href="#一维数组的定义和引用" class="headerlink" title="一维数组的定义和引用"></a>一维数组的定义和引用</h2><h3 id="一维数组的定义"><a href="#一维数组的定义" class="headerlink" title="一维数组的定义"></a>一维数组的定义</h3><p>在C语言中使用数组前必须先进行定义。一维数组的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式声明</span></span><br><span class="line">类型声明符 数组名[常量表达式];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><p>类型声明符是任一种基本数据类型或者构造数据类型，即<code>int</code>，<code>float</code>，<code>char</code>等基本数据类型，以及结构体数据类型。从这里可以看出，数组是建立在其他数据类型的基础之上的，因此数组是构造类型。</p></li><li><p>数组名是用户定义的数组标识符，命名规则遵循标识符命名规则。对于数组元素来说，它们具有一个共同的名字，即数组名。</p><blockquote><p>需要注意的是，数组的名称不可以与其他变量名相同</p></blockquote></li><li><p><strong>方括号中的常量表达式表示数组元素的个数，也成为数组的长度</strong>。</p><blockquote><p>不能在方括号中用变量来表示数组元素的个数，但可以使用符号常数或者常量表达式</p></blockquote></li></ol><h3 id="一维数组元素的存储"><a href="#一维数组元素的存储" class="headerlink" title="一维数组元素的存储"></a>一维数组元素的存储</h3><p>每个数组元素都占用内存中的一个存储单元，每个元素都是一个变量，可以像以前使用普通变量一样使用，不过使用的是数组的索引。<strong>系统在内存中为数组元素分配连续的存储单元</strong>。</p><p>例如，定义语句<code>int a[15]</code>，声明了以下几个问题：</p><ol><li>数组名为<code>a</code></li><li>数组元素的数据类型为<code>int</code></li><li>数组元素的下标值是从0开始的。</li><li>数组名<code>a</code>是数组存储区的首地址，即存放数组第一个元素的地址。<strong>a等价于<code>&amp;a[0]</code>，因此数组名是一个地址常量。不能对数组名进行赋值或者运算</strong>。</li></ol><h3 id="一维数组元素的引用"><a href="#一维数组元素的引用" class="headerlink" title="一维数组元素的引用"></a>一维数组元素的引用</h3><p>对数组元素的引用与对变量的引用类似，与变量引用不同的是，只能对单个数组元素进行引用，而不能一次引用整个数组。一维数组元素的引用格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标]</span><br></pre></td></tr></table></figure><p>【实例】从键盘输入10个整数，求其中的最大数并输出</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数值：&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num[<span class="number">10</span>];    <span class="comment">//定义数组存放10个数值</span></span><br><span class="line">    <span class="type">int</span> max;    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);    <span class="comment">//记录输入数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    max = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max&lt;num[j])</span><br><span class="line">        &#123;</span><br><span class="line">            max = num[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112202101454.png" alt="image-20220112202101454" style="zoom:80%;" /></p><h2 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h2><p><strong>与一半变量初始化一样，数组的初始化就是在定义数组的同时，给其数组元素赋予初值</strong>。</p><blockquote><p>数组的初始化是在编译阶段进行的，这样减少运行时间，提高效率</p></blockquote><p>一维数组的初始化语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型声明符 数组名[常量表达式]=&#123;数值<span class="number">1</span>，数值<span class="number">2</span>，···，数值n&#125;;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//以上示例代码，相当于：</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>,a[<span class="number">1</span>]=<span class="number">2</span>,a[<span class="number">2</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>C语言对数组的初始化有以下几点规定：</p><ol><li><p><strong>可以只给部分数组元素赋初值</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>只能给数组元素逐个赋值，不能给数组整体赋值。</p></li><li><p><strong>如果给全部元素赋值，则在数组声明中，可以不给出数组元素的个数</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="一维数组实例"><a href="#一维数组实例" class="headerlink" title="一维数组实例"></a>一维数组实例</h3><p>【实例】给定$n$个任意数，按由小到大对其排序，并输出排序结果。</p><blockquote><p>详细看数据结构部分（欠数据结构），经典的排序问题</p></blockquote><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组的定义和引用"><a href="#二维数组的定义和引用" class="headerlink" title="二维数组的定义和引用"></a>二维数组的定义和引用</h2><p>前面介绍的数组只有一个下标，称为一维数组，其数组元素也成为单下标变量。在实际问题中，很多问题是二维甚至是多维的，比如常见的矩阵就是二维的，因此C语言允许构造多维数组。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><p>二维数组定义的语法格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line">类型声明符 数组名[常量表达式<span class="number">1</span>][常量表达式<span class="number">2</span>];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>其中，常量表达式1表示第一维的长度，常量表达式2表示第二维的长度</strong>。</p><blockquote><p>数组元素的个数=常量表达式1 $\times$ 常量表达式2</p></blockquote><h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><p><strong>二维数组在概念上是二维的，比如说矩阵，但是其存储器单元是按一维线性排列的</strong>。在一维存储器中存放二维数组，有两种方式：一种是按行排列，即放完一行之后顺次放入第二行；另一种是按列排列，即放完一列之后再顺次放入第二列。<strong>在C语言中，二维数组是按行排列的</strong>。例如：<code>int x[2][3];</code></p><p>先放第一行，即<code>x[0][0]</code>，<code>x[0][1]</code>，<code>x[0][2]</code>，再放第二行，即<code>x[1][0]</code>，<code>x[1][1]</code>，<code>x[1][2]</code>。如图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220113212405628-16420803039851.png" alt="image-20220113212405628" style="zoom:80%;" /></p><h3 id="二维数组的引用"><a href="#二维数组的引用" class="headerlink" title="二维数组的引用"></a>二维数组的引用</h3><p>与一维数组一样，不能对一个二维数组整体进行引用，只能对具体的数据元素进行引用。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标<span class="number">1</span>][下标<span class="number">2</span>];</span><br></pre></td></tr></table></figure><blockquote><p>要注意下标越界问题，部分编译系统不会检查下标越界问题</p></blockquote><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>二维数组的初始化即定义数组的同时对其元素赋值，初始化有两种方法：</p><ol><li><p><strong>把初始化值括在一对大括号内</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>初始化的结果是：<code>x[0][0]=1</code>，<code>x[0][1]=2</code>，<code>x[0][2]=3</code>，<code>x[1][0]=4</code>，<code>x[1][1]=5</code>，<code>x[1][2]=6</code>。</p></li><li><p><strong>把多维数组分解成多个一维数组</strong>，也就是把二维数组看作是一种特殊的一维数组，该数组的每一个元素又是一个一维数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>说明：</p><ol><li><p><strong>可以只对部分元素赋值，未赋值的元素自动取0值</strong>。</p></li><li><p><strong>如果对全部元素赋初值，则第一维的长度可以不给出</strong>。例如，对二维数组初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>即第一维度的长度可以省略，但是第二维度的长度不能省略。</p></li></ol><h3 id="二维数组的应用实例"><a href="#二维数组的应用实例" class="headerlink" title="二维数组的应用实例"></a>二维数组的应用实例</h3><p>【实例】某公司2020年上半年产品销售统计表如下表所示，求每种产品的月平均销售量和所有产品的总月平均销售量。</p><div class="table-container"><table><thead><tr><th>月份</th><th>产品A</th><th>产品B</th><th>产品C</th><th>产品D</th><th>产品E</th></tr></thead><tbody><tr><td>1</td><td>30</td><td>21</td><td>50</td><td>35</td><td>42</td></tr><tr><td>2</td><td>35</td><td>15</td><td>60</td><td>40</td><td>40</td></tr><tr><td>3</td><td>32</td><td>18</td><td>56</td><td>37</td><td>50</td></tr><tr><td>4</td><td>40</td><td>25</td><td>48</td><td>42</td><td>48</td></tr><tr><td>5</td><td>36</td><td>23</td><td>52</td><td>33</td><td>46</td></tr><tr><td>6</td><td>41</td><td>19</td><td>55</td><td>39</td><td>52</td></tr></tbody></table></div><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">5</span>][<span class="number">6</span>] =&#123;  &#123;<span class="number">30</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">36</span>, <span class="number">41</span>&#125; ,  </span><br><span class="line">                    &#123;<span class="number">21</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">19</span>&#125;,   </span><br><span class="line">                    &#123;<span class="number">50</span>, <span class="number">60</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">52</span>, <span class="number">55</span>&#125;,   </span><br><span class="line">                    &#123;<span class="number">35</span>, <span class="number">40</span>, <span class="number">37</span>, <span class="number">42</span>, <span class="number">33</span>, <span class="number">39</span>&#125;,   </span><br><span class="line">                    &#123;<span class="number">42</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">46</span>, <span class="number">52</span>&#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">    <span class="type">float</span> yuePing;  <span class="comment">//每种产品的月平均销售量</span></span><br><span class="line">    <span class="type">float</span> zongYue;  <span class="comment">//所有产品的总月平均销售量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            yuePing += A[i][j];<span class="comment">//产品总和</span></span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;产品%d月平均销售量为：%.2f\n&quot;</span>,i+<span class="number">1</span>,yuePing/<span class="number">6</span>);</span><br><span class="line">                zongYue += yuePing/<span class="number">6</span>;<span class="comment">//每件产品总和的和</span></span><br><span class="line">                yuePing = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>==<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;所有产品月平均销售量为：%.2f&quot;</span>, zongYue/<span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115162021891.png" alt="image-20220115162021891" style="zoom:80%;" /></p><h1 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h1><p>前面说明的都是数值型数组，即数组元素都是数值。<strong>还有一种数组，其每个元素都是字符，也就是说数组元素的数据类型是<code>char</code>，初次之外与数值型数组没有区别</strong>。</p><p>字符串应用广泛，但是C语言中没有专门的字符串类型，<strong>字符串是存放在字符数组中的</strong>。</p><h2 id="字符数组的定义和初始化"><a href="#字符数组的定义和初始化" class="headerlink" title="字符数组的定义和初始化"></a>字符数组的定义和初始化</h2><p>字符型数组的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="type">char</span> 数组名[字符个数];</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">2</span>]=&#123;<span class="string">&quot;ch&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>字符数组也可以是二维或者多维数组，例如：<code>char c[2][2]</code></strong>。</p><p>同样，字符数组也允许在定义时进行初始化赋值，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符常量赋值</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">6</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//字符串常量赋值</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">5</span>]=&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>字符型数组初始化时，提供的数据个数如果小于数组元素的个数，则多余的数组元素初始化为空字符<code>\0</code>，而数值型数组初始化为<code>0</code></strong>。</p><blockquote><p><code>\0</code>在C语言中定义为<code>NULL</code>，即空字符</p></blockquote><p>【实例】编写程序，输出”Hello,world”。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">12</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\,&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">12</span>]=&#123;<span class="string">&quot;Hello,world&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115171917918.png" alt="image-20220115171917918" style="zoom:80%;" /></p><blockquote><p>如果你足够细心的话，会发现，<strong>字符数组的长度多余实际字符长度</strong>，详细原因见字符串</p></blockquote><p>【关于字符数组长度=初始化字符长度问题】</p><p>如果你使用如下代码输出，就会发现一些奇怪的输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">5</span>] = &#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);    <span class="comment">//输出全部字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，规定5个字符，但是初始化的时候就给5个字符，按照之前说的<code>printf</code>函数必须遇到<code>\0</code>才会停止输出。那么在GCC编译器上，输出的结果为：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115202945078.png" alt="image-20220115202945078" style="zoom:80%;" /></p><p>在Visual Studio 2019 IDE上的输出结果为：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115203201315.png" alt="image-20220115203201315" style="zoom:80%;" /></p><p>这也是著名的“烫烫烫”问题，详细原因可以参考<a href="https://zhuanlan.zhihu.com/p/92004659">烫烫烫烫烫烫！ - 汇智动力IT学院的文章 - 知乎</a>。</p><p><strong>简单来说，对于编译器来说，一次编译过程中会做很多初始化的工作，在这个工作中为了对内存的高效合理化应用，会提前在没用的内存或者需要调度它用的内存写入一些字符来标识，当发生内存溢出的时候，这些本来标识的字符被当作数据处理，例如中文处理，在中文编码就变成了“烫烫烫”</strong>。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>前面说明字符串常量时，说明了对于实际字符小于声明字符长度的，其余字符会被<code>\0</code>赋值。因此<strong>C编译器以<code>\0</code>来判断字符串是否结束，而不是通过字符长度来判断字符串长度</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">6</span>]=&#123;<span class="string">&quot;China&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>赋值结果为：数组<code>c</code>含有6个字符，前五个组成”China”，最后一位字符为<code>\0</code>，即空字符。</p><p>需要注意的是：</p><ol><li><p>初始化字符数组时不可以超出数组长度</p></li><li><p><strong>用字符串常量初始化时，字符数组长度可以省略，其数组存放字符个数由赋值的字符串长度决定</strong>。</p><blockquote><p>实际长度=实际字符长度+1（<code>\0</code>）</p></blockquote></li><li><p><strong>用字符常量初始化时，如果省略字符数组长度，则实际长度=实际字符长度</strong>。</p></li></ol><h2 id="字符数组的输入和输出"><a href="#字符数组的输入和输出" class="headerlink" title="字符数组的输入和输出"></a>字符数组的输入和输出</h2><p>字符数组的输入和输出有两种方法：<strong>一种是逐个把字符输入/输出，另一种方法是整个字符串一次输入/输出</strong>。</p><p><strong><code>scanf</code>/<code>printf</code>函数可以输入/输出任何类型的数据，若要输入/输出字符，则格式为<code>%c</code>，若要输入/输出字符串，格式为<code>%s</code></strong>。</p><ol><li><p>字符数组的输入。从键盘逐个读取字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,字符数组元素地址);</span><br></pre></td></tr></table></figure></li><li><p>从键盘读取一串字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,字符数组名);</span><br></pre></td></tr></table></figure></li><li><p>字符数组的输出。从键盘逐个输出字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,字符数组元素地址);</span><br></pre></td></tr></table></figure></li><li><p>从键盘输出一串字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,字符数组名);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>需要注意的是，输出字符串时，遇到<code>\0</code>则结束。</p></blockquote><p>【<strong>关于输入字符串超出数组字符长度问题</strong>】</p><p>问题源于如下代码，代码很简单，输入字符串，输出字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">3</span>];<span class="comment">//定义字符数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);<span class="comment">//输入字符存储字符数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);<span class="comment">//输入字符输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们正常按照字符数量输入字符，则输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115193556578.png" alt="image-20220115193556578" style="zoom:80%;" /></p><p>但是如果我们故意多输入一些字符，则输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115193639617.png" alt="image-20220115193639617" style="zoom:80%;" /></p><p>首先我们需要明确几点规则：</p><ol><li><strong>对于字符数组，每个字符数组最后一位一定是一个<code>\0</code>字符</strong>。</li><li><strong>对于<code>printf()</code>函数来说，输出字符是自动截取到<code>\0</code>字符</strong>。</li><li><strong>对于数组溢出问题，不在C编译器的预编译报错范围</strong>，也就是说数组溢出问题需要程序员自行负责。</li></ol><p><strong>所以对于直接获取字符串输入来说，获取多少编译器就在最后+<code>\0</code>字符，然后<code>printf</code>函数输出字符串，是读取到<code>\0</code>才会停止，导致即使超出字符数组长度，也可以原样输出的原因</strong>。</p><p>那么问题升级一下，如果我在输入字符串的时候，输入了空格会怎么办？代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">5</span>];  <span class="comment">//容纳5个字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c); <span class="comment">//输入字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, c[<span class="number">3</span>]); <span class="comment">//输出第四个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);    <span class="comment">//输出全部字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115195643582.png" alt="image-20220115195643582" style="zoom:80%;" /></p><blockquote><p>0对应的是<a href="http://c.biancheng.net/c/ascii/">ASCII</a>码的<code>NULL</code>，即空字符，也就是C语言的<code>\0</code>。</p></blockquote><p>可以看到，<strong>如果我们在输入字符串的时候，输入空格，那么空格会被默认为<code>\0</code>字符，即<code>NULL</code>（空字符）</strong>。那么，我们真的想要输出空格怎么办？</p><p><strong>可以使用<code>%[^\n]</code>来告诉输入函数，以回车作为字符串输入的结束</strong>。对于上面的代码，我们修改后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">5</span>];  <span class="comment">//容纳5个字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, c); <span class="comment">//输入字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, c[<span class="number">3</span>]); <span class="comment">//输出第四个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c);    <span class="comment">//输出全部字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115200213805.png" alt="image-20220115200213805" style="zoom:80%;" /></p><p>可以得知，32是<a href="http://c.biancheng.net/c/ascii/">ASCII</a>的空格字符。在输入的时候，我们规定编译器在回车的地方认为是字符串的结束，即在该处加上了<code>\0</code>字符，这样就解决了这个问题。</p><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><p><strong>在C语言标准库函数中，提供了一些专门用于处理字符串的函数，常用的有<code>gets()</code>,<code>puts()</code>,<code>strlen()</code>,<code>strcmp()</code>,<code>strlwr</code>,<code>strupr()</code>,<code>strcat()</code>,<code>strcpy()</code>,<code>strncpyy()</code></strong>函数。</p><blockquote><p>在使用这些函数之前，需要引入专门的函数库，即<code>#include &lt;string.h&gt;</code></p></blockquote><ol><li><p><strong><code>gets()</code>，<code>puts()</code>是字符串输入/输出函数</strong>。</p><p>其中，<code>gets()</code>函数是字符串输入函数。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(字符数组名);</span><br></pre></td></tr></table></figure><p>函数功能：获取输入的字符串到指定变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(字符数组名);</span><br></pre></td></tr></table></figure><p>函数功能：输出指定字符串，同<code>printf</code>，也是截取到字符<code>\0</code>。</p></li><li><p><strong><code>strlen()</code>函数事获取字符串长度函数</strong>。语法格式如下：</p><blockquote><p><code>strlen</code>是英文<code>string length</code>的缩写，即字符串长度。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(字符数组名);</span><br></pre></td></tr></table></figure><blockquote><p>在Visual Studio 2019 编译器上是截取<code>\0</code>之前的字符实际长度，而在GCC编译器中，是截取全部的字符长度，即包含<code>\0</code>字符的长度。（修正：如果字符数组长度没有大于实际长度1位，这输出的长度包含<code>\0</code>字符，即实际长度+1，反之，这输出正确的数组实际长度）</p></blockquote></li><li><p><strong><code>strcmp()</code>函数是字符串比较函数</strong>。语法格式如下：</p><blockquote><p><code>strcmp</code>是英文<code>string compare</code>的缩写，即字符串比较。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(字符数组<span class="number">1</span>，字符数组<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>函数功能：<strong>将两个字符数组的字符串从左到右逐个比较，比较字符的ASCII码大小，并由函数返回值返回比较结果</strong>。（<strong>字符串的比较原理：每个字符串ASCII码的和做比较</strong>）</p><ul><li>字符串1=字符串2，返回值=0</li><li>字符串1&gt;字符串2，返回值&gt;0</li><li>字符串1&lt;字符串2，返回值&lt;0</li></ul><p>【大坑说明】</p><p>注意这里有个大坑，如果我们常规的字符数组初始化<code>char c[2]=&#123;&quot;he&quot;&#125;;</code>末尾没有<code>\0</code>字符，则编译器在获取该字符串的时候会溢出，也就是说编译器底层获取的<code>c[2]</code>实际的值已经不是<code>he</code>了。而对于<code>scanf()</code>/<code>puts()</code>来说，它会自动在最后加上<code>\0</code>字符，所以不会出现这种问题。</p><blockquote><p>当初始化字符数组规定字符=实际赋值，这会出现<code>\0</code>字符丢失，如果按照C语言规定，初始化数组时规定字符&gt; 实际初始化赋值一位，则不会出现这个问题</p></blockquote></li><li><p><strong><code>strlwr()</code>和<code>strupr()</code>函数，是字符串大小写转换函数</strong>。函数语法格式如下：</p><blockquote><p><code>strlwr</code>是英文<code>string lower</code>(case)的缩写，即字符串小写（字母）</p><p><code>struper</code>是英文<code>string upper</code>(case)的缩写，即字符串大写（字母）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换小写字母函数</span></span><br><span class="line">strlwr(字符数组名);</span><br><span class="line"><span class="comment">//转换大写字母函数</span></span><br><span class="line">strupr(字符数组名);</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">6</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//小写字母初始化</span></span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;<span class="comment">//大写字母初始化</span></span><br><span class="line">    <span class="built_in">puts</span>(strupr(c));<span class="comment">//转换为大写</span></span><br><span class="line">    <span class="built_in">puts</span>(strlwr(b));<span class="comment">//转换为小写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115215932091.png" alt="image-20220115215932091" style="zoom:80%;" /></p></li><li><p><strong><code>strcat()</code>是字符串连接函数</strong>。语法格式如下：</p><blockquote><p><code>strcat</code>是英文<code>string catenate</code>的缩写，即字符串连接。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(字符数组名<span class="number">1</span>，字符数组名<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>函数功能：把字符数组2中的字符串连接到字符数组1中字符串的后面，并删去字符串1后的串标志<code>\0</code>。函数返回值为字符数组1的首地址</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">strcat</span>(c, b));<span class="comment">//拼接字符串数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220115223420492.png" alt="image-20220115223420492" style="zoom:80%;" /></p><blockquote><p>需要注意的是，合并字符数组时，第一个字符数组的长度要足够长，否则不足以容纳全部字符数组2</p></blockquote></li><li><p><strong><code>strcpy()</code>/<code>strncpy()</code>是字符串复制函数</strong>。语法格式如下：</p><blockquote><p><code>strcpy</code>是英文<code>string copy</code>的缩写，即字符串复制。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制全部字符数组</span></span><br><span class="line"><span class="built_in">strcpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);</span><br><span class="line"><span class="comment">//复制指定长度的字符串数组</span></span><br><span class="line"><span class="built_in">strncpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>,n);</span><br></pre></td></tr></table></figure><p><strong>函数功能：（<code>strcpy</code>）把字符数组2中的字符串复制到字符组1中。串结束标志<code>\0</code>也一同复制；（<code>strncpy</code>）把字符数组2中的前n个字符复制到字符数组1中，取代字符数组1中原有的前n个字符</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strcpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">6</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">strcpy</span>(c, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116160131040.png" alt="image-20220116160131040" style="zoom:80%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strncpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>] = &#123;<span class="string">&quot;helloleoleiming&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = &#123;<span class="string">&quot;HELLO&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(c,b,<span class="number">6</span>);<span class="comment">//复制字符数组b前六个字符到C</span></span><br><span class="line">    c[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将c的第七个字符变为结束字符“\0”</span></span><br><span class="line">    <span class="built_in">puts</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116163403734.png" alt="image-20220116163403734" style="zoom:80%;" /></p><p>如果你足够细心，会疑问直接复制不可以吗？为什么要多此一举？<strong>实际上<code>strncpy</code>函数不会给末尾加上结束符号，即<code>\0</code></strong>。所以需要手动添加。</p><blockquote><p>我在GCC编译器上测试这样是可以通过的，但是在Visual Studio 2019上测试不通过，原因还是上面提到的<strong>实际上<code>strncpy</code>函数不会给末尾加上结束符号，即`\0</strong>。</p></blockquote><ul><li>个人感觉这是个历史遗留问题，此方法暂时不建议使用。</li></ul></li></ol><h2 id="字符数组应用实例"><a href="#字符数组应用实例" class="headerlink" title="字符数组应用实例"></a>字符数组应用实例</h2><p>【实例】编程实现凯撒加密，即是将加密文本中的每个字符替换成为其后面的第k个字符。</p><p>【代码示例】【伪装凯撒加密】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100 <span class="comment">//设置最大加密字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bit 12 <span class="comment">//设置加密位数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入加密文本：&quot;</span>);</span><br><span class="line">    <span class="type">char</span> text[MAX]; <span class="comment">//定义加密字符变量</span></span><br><span class="line">    gets(text); <span class="comment">//获取字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        text[i] += Bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的文本为：%s&quot;</span>,text);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220116164848886.png" alt="image-20220116164848886" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【4.0】C-循环结构及其应用</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%904-0%E3%80%91C-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%904-0%E3%80%91C-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>循环是程序的一种基本结构，它可以解决很多有用的问题，特别是那些重复性有规律的事情。</p><h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a><code>while</code>循环语句</h1><p><code>while</code>循环语句的语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line">    语句系列;<span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>while</code>语句的执行过程是：根据表达式判断，如果为真，则执行循环体，一直执行循环体，直到<code>break;</code>才会跳出循环</strong>。</p><blockquote><p>需要注意的是，<code>while</code>是在循环前，先判断</p></blockquote><p>【实例】求 $n!$。</p><p>【代码示例1】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要求的阶乘：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    sum = n;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (n&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum *= (n<span class="number">-1</span>);</span><br><span class="line">                n = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;阶乘的结果为： %ld&quot;</span>,sum);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;阶乘的结果为：1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的数值非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【示例代码2】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> s;</span><br><span class="line">    s = <span class="number">1</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要求的阶乘：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        s *= i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的阶乘结果为：%ld&quot;</span>, n, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出1】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112000315699.png" alt="image-20220112000315699" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112000419537.png" alt="image-20220112000419537" style="zoom:80%;" /></p><p>【输出2】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112000533569.png" alt="image-20220112000533569" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112000419537.png" alt="image-20220112000419537" style="zoom:80%;" /></p><h1 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a><code>do-while</code>循环语句</h1><p>在<code>while</code>语句中，是在执行循环体之前进行循环条件判断的。因此，在有的时候，需要在循环体执行后进行判断，也就是说循环体的语句无论什么条件下都至少要执行一次。为了方便这种情况，C语言提供了<code>do-while</code>语句，语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (表达式);</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112141915117.png" alt="image-20220112141915117" style="zoom:67%;" /></p><p>该语句的执行过程为：执行循环体结束，判断表达式，如果为真，则继续执行循环体，反之则跳出循环体。</p><p>【实例】求$1+2+3+4+······+100$，即$\sum\limits_{i = 1}^{100}i$。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += k;</span><br><span class="line">        k++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (k&lt;=<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>,sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112142526030.png" alt="image-20220112142526030" style="zoom: 80%;" /></p><h1 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a><code>for</code>循环语句</h1><p><strong>对循环状态的初始化和对循环控制变量的修改，是循环语句中不可缺少的两个组成部分。为了便于描述，阅读和检查，C语言提供了与<code>while</code>语句和<code>do-while</code>语句功能相似的<code>for</code>语句。</strong><code>for</code>语句是控制循环语句最广泛的一种循环控制语句。其功能是某段程序代码执行若干次，特别适合已知循环次数的情况。其语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>表达式1常为赋值表达式，用来确定循环结构中的控制循环次数的变量的初始值，实现循环控制变量的初始化。</li><li>表达式2常为关系表达式或者逻辑表达式，用来判断循环是否继续执行，通常将循环控制变量与某一值进行比较来判断是否继续执行循环体。</li><li>表达式3为表达式语句，用来描述控制变量的变化，常为自增或者自减表达式。</li></ul><p>【实例】输入10个整数，求这10个整数的和。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个整数：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p><code>for</code>循环中的表达式1，表达式2，表达式3都是选择项，即可以缺省，但分号<code>;</code>不可以缺省。</p></li><li><p>省略表达式1，表示不对循环控制变量赋初值。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;表达式<span class="number">1</span>；表达式<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>实际上表达式1可以写在for语句结构的外面。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">20</span>;<span class="keyword">for</span>(;表达式<span class="number">1</span>;表达式<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>一般使用这种格式的原因是：循环控制变量的初值不是已知常量值，而是需要通过前面的语句执行计算得到。</p></li><li><p>省略表达式2，表示不用判断循环条件是否成立，循环条件总是满足的。此时如果不做其他处理时，则为死循环，类似于<code>while(1)</code>的效果。</p></li><li><p>省略表达式3，可以在循环体中进行控制。</p></li><li><p>省略三个表达式，可以使用<code>break;</code>来控制跳出循环。</p></li><li><p><code>for</code>语句的循环体可以是空语句，表示当循环满足时空操作。一般用于延时处理，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++);</span><br></pre></td></tr></table></figure><p>表示循环空循环了10000次，占用一定的时间，起到了延时效果。</p></li><li><p>在<code>for</code>语句中，表达式1和表达式3都可以是一项或者多项。相当于多一项，各项之间用<code>,</code>隔开。</p></li></ol><blockquote><p><code>for</code>结构不是狭义上的计数式循环，是广义上的循环结构。</p></blockquote><p>【实例】猴子吃桃问题，猴子第一天摘下若干桃子，当即吃了一半，还不过瘾，又多吃了一个，第二天早上又将剩下的桃子吃了一半，又多吃了一个。以后每天早上都这么吃，直到第10天早上只剩下1个桃子，求第一天共摘了多少桃子？</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sum *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为：%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112152758146.png" alt="image-20220112152758146" style="zoom:80%;" /></p><h1 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h1><p><strong>一个循环语句中包含另一个完整的循环结构，称为循环的嵌套。</strong>嵌套在内的称为内循环，嵌套内循环的循环称为外循环。理论上循环的嵌套是无限的。</p><p>对于双重循环来说，内层循环的执行次数为：内层次数 $\times$ 外层次数。</p><p>【实例】输出十行星号（<code>*</code>）半金字塔形</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112162331985.png" alt="image-20220112162331985" style="zoom:80%;" /></p><h1 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a><code>break</code>语句和<code>continue</code>语句</h1><p>在循环结构的循环体中，可以使用<code>break</code>语句和<code>continue</code>语句来控制循环的流程。<strong>其中<code>break</code>语句的功能是从循环体中退出，提前结束循环；<code>continue</code>语句的功能则是终止本次循环，跳出本次循环体中剩余未执行的语句，转向下一次循环是否执行的循环条件判断</strong>。</p><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><code>break</code>语句</h2><p><code>break</code>语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>break</code>语句只能出现在<code>switch</code>语句或者循环语句的循环体中</p></blockquote><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><code>continue</code>语句</h2><p><code>continue</code>语句格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>continue</code>语句只能出现在<code>while</code>，<code>do-while</code>和<code>for</code>循环语句的循环体中。</li></ol><h1 id="goto语句和标号"><a href="#goto语句和标号" class="headerlink" title="goto语句和标号"></a><code>goto</code>语句和标号</h1><p><code>goto</code>语句是无条件转移语句。其功能是改变程序控制的流程，无条件地将控制转移到语句标号所在处。语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 语句标号;</span><br></pre></td></tr></table></figure><p>其中：<strong>语句标号用标识符来命名，当它放在某个语句行前面做该语句行的标识时，它的后面需要有冒号<code>:</code></strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error:语句;</span><br></pre></td></tr></table></figure><p>在C语言中，语句标号通常与<code>goto</code>语句配合使用，表示无条件跳转到语句标号指定的语句位置。<strong>在程序中，标号必须与<code>goto</code>语句处于同一个函数中，但可以不在同一个循环层中</strong>。</p><p><code>goto</code>语句不常用，主要是因为大量使用它会破坏程序的结构化，使程序的流程混乱，可读性降低。</p><p>【实例】求$1+2+3+4+······+100$，即$\sum\limits_{i = 1}^{100}i$。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    loop:<span class="keyword">if</span> (i&lt;=<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和为:%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220112142526030.png" alt="image-20220112142526030" style="zoom: 80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【3.0】C-选择结构及其应用</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%903-0%E3%80%91C-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%903-0%E3%80%91C-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分东西不多，相对简单，快速上手，通俗易懂。</p><h1 id="关系运算符和关系表达式"><a href="#关系运算符和关系表达式" class="headerlink" title="关系运算符和关系表达式"></a>关系运算符和关系表达式</h1><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>在程序中经常需要比较两个量的大小关系，以决定程序的下一步进行的工作。比较两个量的运算符称为关系运算符。通俗来讲，也就是比较运算，即将两个操作数比较并产生运算结构0（假）或1（真）。C语言提供的关系运算符有6种，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:left">&lt;</td><td>小于</td></tr><tr><td style="text-align:left">&lt;=</td><td>小于或等于</td></tr><tr><td style="text-align:left">&gt;</td><td>大于</td></tr><tr><td style="text-align:left">&gt;=</td><td>大于或等于</td></tr><tr><td style="text-align:left">==</td><td>等于</td></tr><tr><td style="text-align:left">!=</td><td>不等于</td></tr></tbody></table></div><p>说明：</p><ol><li>C语言中的关系运算符与数学中的（&gt;,&gt;=等）不一样。</li><li>以上6种关系运算符中，前4种（&lt;,&lt;=,&gt;,&gt;=）的优先级相同，后两种(==,!=)的优先级相同，前4种优先级高于后两种。</li><li>关系运算符的结合性为从左到右。</li></ol><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><p>关系表达式是指用关系运算符将两个数（或者表达式）连接起来进行关系运算的式子，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&lt;<span class="number">2</span>;</span><br><span class="line">a&gt;b;</span><br><span class="line">a&lt;a+b;</span><br></pre></td></tr></table></figure><p><strong>关系表达式的结果是逻辑值，即真值或者假值，其中1为真，0为假，真值表示关系表达式表示关系成立，反之则不成立</strong>。</p><h2 id="优先级和结合性"><a href="#优先级和结合性" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><p>关系运算符的结合性都是自左向右的。</p><blockquote><p>注意运算符的优先级</p></blockquote><h1 id="逻辑运算符和逻辑表达式"><a href="#逻辑运算符和逻辑表达式" class="headerlink" title="逻辑运算符和逻辑表达式"></a>逻辑运算符和逻辑表达式</h1><p>C语言中，对参与逻辑运算的所以数值，都转化为逻辑“真”或“假”后才参与逻辑运算，<strong>如果参与逻辑运算的数值为0，则把它作为逻辑“假”处理，而所有非0的数值都作为逻辑“真”处理</strong>。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>C语言中有3种逻辑运算符：逻辑与（和）（&amp;&amp;），逻辑或（||），逻辑非（！）</strong>，详细如下表：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与（和），双目运算符，左右两数为“真”则为真，反之为“假”</td></tr><tr><td>\</td><td>\</td><td></td><td>或，双目运算符，左右都为“假”则为假，反之为“真”</td></tr><tr><td>！</td><td>非，单目运算符，对操作符取反</td></tr></tbody></table></div><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><p>逻辑表达式是由逻辑运算符将逻辑量连接起来构成的式子。对象可以是任何类型的数据，但<strong>运算结果一定是整型值，并且只有两个值：1和0，分别表示真和假</strong>。</p><p>说明：</p><ol><li>对于<code>a&amp;&amp;b</code>，只有<code>a</code>的值为真时，才需要判断<code>b</code>的值。</li><li>对于<code>a||b</code>，只有<code>a</code>的值为真时，才不需要判断<code>b</code>的值。</li><li>对于$2<a<3$这类表达式，C语言中的实现为`(a>2)&amp;&amp;(a&lt;3)`。</li></ol><h2 id="优先级和结合性-1"><a href="#优先级和结合性-1" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><p>三种运算符的优先级由高到低依次为：<code>!</code>，<code>&amp;&amp;</code>，<code>||</code>。</p><p>逻辑运算符中的<code>&amp;&amp;</code>和<code>||</code>的结合性为从左向右，<code>!</code>的结合性为从右向左。</p><p>【实例】逻辑运算符的应用</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    a = <span class="number">12</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a与b的结果为 %d\n&quot;</span>, a &amp;&amp; b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a与b的结果为 %d\n&quot;</span>, a || b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b取反的结果为 %d&quot;</span>, !b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107202757950.png" alt="image-20220107202757950" style="zoom:80%;" /></p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h1><p><strong><code>if</code>语句是条件选择语句，它先对给定条件进行判断，根据判定的结果（真或假）决定要执行的语句。<code>if</code>语句有<code>if</code>分支，<code>if-else</code>分支和嵌套的<code>if</code>语句3种形式</strong>。</p><h2 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a><code>if</code>分支</h2><p><code>if</code>分支是最简单的条件语句，<code>if</code>分支语句的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    语句<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中，表达式一般为逻辑语句或者关系表达式。语句1可以是一条简单的居于或者多条语句，<strong>当为多条语句时，需要用大括号<code>&#123;&#125;</code>，将这些语句括起来，构成复合语句</strong>。<br><code>if</code>分支语句的执行过程是：当表达式值为真（非0）时，会执行语句1，反之则不执行。</p><p>【实例】从键盘输入一个整数，如果输入的是2的倍数，则显示“成功”，反之则不显示<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);    <span class="comment">//获取输入</span></span><br><span class="line">    <span class="keyword">if</span> (a%<span class="number">2</span>==<span class="number">0</span>)     <span class="comment">//取余判断</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功&quot;</span>);     <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107212112534.png" alt="image-20220107212112534" style="zoom:80%;" /></p><h2 id="if-else分支"><a href="#if-else分支" class="headerlink" title="if-else分支"></a><code>if-else</code>分支</h2><p><code>if</code>分支语句只允许在条件为真时指定要执行的语句，而<code>if-else</code>分支还可以在条件为假时指定要执行的语句。<code>if-else</code>分支语句的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还是上面2的整数的例子，稍微改进一下，如果不是2的倍数，则输出“不是2的倍数”。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);    <span class="comment">//获取输入</span></span><br><span class="line">    <span class="keyword">if</span> (a%<span class="number">2</span>==<span class="number">0</span>)     <span class="comment">//取余判断</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是2的倍数&quot;</span>,a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不是2的倍数&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107212335429.png" alt="image-20220107212335429" style="zoom:80%;" /></p><p>【实例】输入三个值，如果三个值均大于0且符合任意两个之和大于第三个，则计算以这三个值为边的三角形面的结果。<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b, c;    <span class="comment">//定义三边长</span></span><br><span class="line">    <span class="type">double</span> s;   <span class="comment">//定义面积</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (a+b&gt;c &amp;&amp; a+c&gt;b &amp;&amp; b+c&gt;a &amp;&amp; a&gt;<span class="number">0</span> &amp;&amp; b&gt;<span class="number">0</span> &amp;&amp; c&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="built_in">sqrt</span>(( a + b + c )*(a + b - c)*(a + c - b)*(b + c - a))/<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;三角形的面积为%f&quot;</span>, s);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107214623210.png" alt="image-20220107214623210" style="zoom:80%;" /></p><blockquote><p>已知三边，求三角形面积参考 <a href="https://baike.baidu.com/item/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F/106956?fr=aladdin">海伦公式</a></p></blockquote><h2 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的<code>if</code>语句</h2><p>简单的<code>if</code>语句只能通过给定条件的判断执行两种操作，而不能多种操作中选择一个，此时嵌套的<code>if</code>语句解决了这个问题。<strong><code>if</code>语句中又包含一个或者多个<code>if</code>语句时，称为<code>if</code>语句的嵌套</strong>。<br>常用的<code>if</code>语句嵌套有以下两种形式：</p><ul><li><p>形式一，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    <span class="keyword">if</span>(表达式)</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(表达式)</span><br><span class="line">        语句<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        语句<span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>形式二，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>)</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式n)</span><br><span class="line">    语句n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句n+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>【实例】将学生成绩按分数输出 A B C D E 等级<br>【补充】成绩对照关系表</p><p>| 百分制                 | 等级 |<br>| ——————————— | —— |<br>| 90$\leq$score$\leq$100 | A    |<br>| 80$\leq$score$&lt;$90     | B    |<br>| 70$\leq$score$&lt;$80     | C    |<br>| 60$\leq$score$&lt;$70     | D    |<br>| 0$\leq$score$&lt;$60      | E    |</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> score;  <span class="comment">//定义分数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入分数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);    <span class="comment">//获取输入的分数</span></span><br><span class="line">    <span class="keyword">if</span> (score&gt;<span class="number">100</span> || score &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的成绩不合法&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;=<span class="number">100</span> &amp;&amp; score&gt;=<span class="number">90</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 A&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span> &amp;&amp; score &gt;=<span class="number">80</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 B&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">80</span> &amp;&amp; score &gt;=<span class="number">70</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 C&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">70</span> &amp;&amp; score &gt;=<span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 D&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该同学的成绩等级为 E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107221041613.png" alt="image-20220107221041613" style="zoom:80%;" /></p></li></ul><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h2><p>对于常规的两种选择可以使用<code>if-else</code>语句，那么对于两种及以上的多种选择则需要<code>switch</code>语句的帮助了。当然你也可以通过使用嵌套的<code>if-else</code>语句来实现多种选择。</p><p><code>switch</code>语句的一般格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">    语句系列<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">    语句系列<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//default可以为空    </span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【实例】在键盘上输入 1~7 实现输出对应的星期几，如果输入的值不是 1~7，则输出非法数据。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的数据非法&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】</p><ol><li><code>break</code>表示跳出当前循环。</li><li><code>case</code>的循序是任意的，也就是说<code>default</code>可以放到最前面或者任意一个位置。</li></ol><h2 id="条件运算符和条件表达式"><a href="#条件运算符和条件表达式" class="headerlink" title="条件运算符和条件表达式"></a>条件运算符和条件表达式</h2><p><strong>条件运算符很特殊，它是C语言中唯一一个三目运算符</strong>，也就是说，<strong>它要求要有三个运算对象</strong>。条件表达式的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span> ;</span><br></pre></td></tr></table></figure><p><strong>条件表达式的执行过程：如果表达式1的值为真，则执行表达式2，反之则执行表达式3</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a&gt;b?a:b;</span><br></pre></td></tr></table></figure><p>若a大于b，则c的值由a赋值，反之，则c的值由b赋值。</p><blockquote><p>比较两个数最大值可以使用该方法</p></blockquote><p>说明：</p><ol><li><p>条件运算符的优先级低于算术运算符，关系运算符以及逻辑运算符，<strong>仅高于赋值运算符和逗号运算符</strong>。</p></li><li><p><strong>条件运算符的结合性为从左到右</strong>，当有条件运算符镶嵌时，按照从右到左的顺序依次运算。</p></li><li><p>条件表达式中三个表达式的类型可以不同，其中表达式1表示条件，只能是0或者非0的结果；当表达式2和表达式3的类型不同时，<strong>条件表达式值的类型为两者中较高的类型（可以参考自动类型转换阶级）</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">a&lt;b?<span class="number">3</span>:<span class="number">4.0</span>;</span><br></pre></td></tr></table></figure><p>该例子的值为 3.0 而不是整型数 3 。</p></li></ol><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>【实例】经典问题，对于输入的年份，计算该年份是否为闰年。</p><p>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line">    <span class="keyword">if</span> (year%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (year%<span class="number">100</span> !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 为闰年&quot;</span>, year);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 为闰年&quot;</span>, year);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 不是闰年&quot;</span>, year);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d 不是闰年&quot;</span>, year);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】闰年判断规则：</p><ol><li>能被4整除且不能被100整除。</li><li>世纪年能被400整除的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2.0】C-数据类型及运算</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%902-0%E3%80%91C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%902-0%E3%80%91C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="【2-0】数据类型及运算"><a href="#【2-0】数据类型及运算" class="headerlink" title="【2.0】数据类型及运算"></a>【2.0】数据类型及运算</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>c 语言经典的入门内容，笔记断断续续写了一个多礼拜，最近一直在考试，碰到考试周了就很头疼。</p><h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><p>C程序由C语言的基本字符组成，基本字符依据规则组成C语言的<strong>标识符</strong>和<strong>关键词</strong>，再按照语法要求构成程序。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>C语言中由<strong>用户命名的符号称为标识符</strong>，用来标明用户设定的变量名，数组名，函数名，结构体名等。标识符必须由有效字符构成，也就是标识符要合法。</p><p>C语言的命名规则如下：</p><ol><li><p>标识符只能由<strong>字母，下划线，数字</strong>组成，且<strong>第一个字符必须是字母或者下划线</strong>，不能是数字。如：<code>cla</code>,<code>cla1</code>都是合法的，但是<code>2cla</code>,<code>%123</code>等都是不合法的。</p></li><li><p>字母区分大小写，例如：<code>AB</code> 和 <code>ab</code>是两个不同的标识符</p><blockquote><p>当然有的计算机语言不区分大小写；例如：VB语言不区分大小写</p></blockquote></li><li><p>不能使用C语言中的关键字</p></li><li><p>C语言虽然本身不限制标识符的长度，但是实际长度收到不同的编译系统和机器系统的限制。</p></li></ol><p><strong>为了提高标识符的可读性，一般来说，业内较为流行的有驼峰命名法，下划线命名法和匈牙利命名法</strong></p><ul><li><p><strong>驼峰命名法</strong></p><ul><li><p>小驼峰命名法：除了第一个单词之外，其他单词首字母都大学。例如：<code>myFileName</code>，<code>openFileSys</code>等。</p><blockquote><p>常用于变量名，函数名；</p></blockquote></li><li><p>大驼峰命名法（又称帕斯卡命名法）：所有单词的首字母均大写，例如：<code>OpenFileSys</code>，<code>ConDataBase</code>等</p><blockquote><p>常用于类名，属性，命名空间等；</p></blockquote></li></ul></li><li><p><strong>下划线命名法</strong></p><ul><li>名称中的每一个逻辑断点都用一个下划线来标记，例如，函数名 <code>print_student_name</code>。下划线命名法是随着C语言的出现而流行的，在UNIX/Linux这样的环境，以及GNU代码中非常普遍。</li></ul></li><li><p><strong>匈牙利命名法</strong></p><ul><li>该命名法由微软公司名为 Charles Simonyi 的匈牙利程序员发明的，其基本原则是，<strong>变量名=属性+类型+对象描述</strong>。通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先 <code>m_</code>（成员变量），再指针，再简单数据类型，再其他。例如，<code>m_lpsStr</code> 表示指向一个字符串的长指针成员变量。</li></ul></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>C语言规定具有特别意义的字符串为关键字（即保留字），关键字不能作为用户标识符。在一些IDE中，关键字会显示为彩色字符来做明显标识。</p><p>C语言的关键字如下表，可以分为以下几类：</p><ol><li>类型声明符。如表示整型的 <code>int</code>等</li><li>语句定义符。用于表示语句功能的，例如条件语句的 <code>if</code>,<code>else</code>等</li><li>预处理命令字。它们是以固定的形式用于专门的位置，表示一个预处理命名，通常将它们当作关键字来看待，如文件包含预处理命令 <code>include</code> 等</li></ol><p><strong>C语言中的关键字</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">int</th><th style="text-align:center">long</th><th style="text-align:center">short</th><th style="text-align:center">float</th><th style="text-align:center">double</th><th style="text-align:center">char</th></tr></thead><tbody><tr><td style="text-align:center">while</td><td style="text-align:center">do</td><td style="text-align:center">switch</td><td style="text-align:center">case</td><td style="text-align:center">continue</td><td style="text-align:center">break</td></tr><tr><td style="text-align:center">const</td><td style="text-align:center">signed</td><td style="text-align:center">unsigned</td><td style="text-align:center">if</td><td style="text-align:center">else</td><td style="text-align:center">for</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">auto</td><td style="text-align:center">register</td><td style="text-align:center">static</td><td style="text-align:center">extern</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">struct</td><td style="text-align:center">union</td><td style="text-align:center">enum</td><td style="text-align:center">typedef</td><td style="text-align:center">volatile</td></tr><tr><td style="text-align:center">goto</td><td style="text-align:center">sizeof</td><td style="text-align:center">inline</td><td style="text-align:center">restrict</td><td style="text-align:center">bool</td><td style="text-align:center">_ Complex</td></tr><tr><td style="text-align:center">_Imaginary</td><td style="text-align:center">include</td><td style="text-align:center">define</td><td style="text-align:center">undef</td><td style="text-align:center">ifdef</td><td style="text-align:center">ifndef</td></tr><tr><td style="text-align:center">endif</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><p>其中的bool,_Complex和_Imaginary是C99新增的关键字，其余的关键字全由小写字母组成。</p><h1 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h1><p>C程序的处理对象为<strong>数据，它们通常以常量或者变量的形式出现</strong>。常量是在程序运行过程中值保持不变的量，变量则是在程序运行过程中值可以改变的量。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>C语言的常量有两种，一种是字面常量，字面常量不需要定义，是非定义量，即通常的数字和字符，例如：123，456，-123，12.4或者字符”A”,”b”等。第二种是自定义常量，或者符号常量，<strong>以一个标识符来代表某一个字面常量，通常利用C语言的宏定义命令 <code>define</code> 来定义</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415962</span></span><br></pre></td></tr></table></figure><p>其含义为以标识符 <code>PI</code> 来代表数据 3.1415926。宏定义命令之后，程序凡是用到 3.1415926 的地方都可以使用 <code>PI</code> 来表示，减少书写的工作量，还可以通过别名来提高程序的可读性。</p><p>使用符号常量后，程序的可维护性好，当需要修改某一常量时，只要修改宏定义中的常量即可，不必逐一修改。</p><blockquote><p>有关于宏的知识，后面会详细讲述</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>每个变量都有三个属性：变量名，存储空间，变量值</strong>。</p><ol><li>变量名：即变量的名字，是我们自定义的标识符，程序中通常使用变量名来对变量进行引用。</li><li>存储空间：每个变量在内存中都占用一定的存储单元。存储单元的大小由变量的类型决定。在C程序中，变量可以通过变量名称访问，也可以通过变量的地址来访问。</li><li>变量值，即变量存储空间中存放的值。</li></ol><p>在C程序中，对任何变量都必须 <strong>先声明，后使用</strong> ，只有在定义了变量的名字，数据类型之后，才能对变量进行各种运算。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>完整的变量定义语句包含两个元素：<strong>变量名和数据类型</strong>。数据类型规定了变量的三个限制：</p><ol><li>变量所占用的存储空间的大小，存储空间以字节为单位，如整型变量占用2个字节，浮点型占用4个字节。</li><li>变量的取值范围，变量的取值返回与存储空间的大小有关，如整型取值范围为 $-32728$~$32767$ ，浮点型取值范围为 $-3.4 \times 10^{-38}$ ~ $3.4 \times 10^{38}$ 。</li><li>变量能进行的运算。如只有整型或者字符型的数据可以进行”取余”运算</li></ol><blockquote><p>关于为什么整型的取值范围为 -32728~32767 ，详情参见 <a href="https://helloseraphine.top/index.php/archives/368.html">原码，反码，补码的前世今生</a></p></blockquote><p>C语言的数据类型如下图所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107161251322.png" alt="image-20220107161251322" style="zoom:80%;" /></p><blockquote><p>存储类型以字节为单位，实际长度由机器字长决定。整型数据取值范围与存储长度一致，但浮点型数据的取值范围还与其系统存储格式有关。</p></blockquote><h2 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h2><p>整型数据包括整常数和存放整数的变量，C语言中整型常量可以有三种表示形式：</p><ol><li>十进制形式，如15，-1555</li><li>八进制形式。<strong>C语言中八进制以数字 0 开头</strong>，只能以 0~ 7 这8个数字组合表示，如 0271 对应十进制的数为 $2 \times 8^2 + 7 \times 8^1 +1 \times 8^0 = 185$</li><li>十六进制形式。<strong>C语言中十六进制数以 0x 或者 0X 开头，可以用 0~9 这10个数表示以及字母 A~F（或 a~f ）组合来表示</strong>。如 0x61F 对应的十进制数为 $6 \times 16^2 + 1 \times 16^1 + 15 \times 16^0 = 1567$</li></ol><p>整型数据按存储空间长度可以分为五种：</p><ol><li><p><strong>基本整型：关键字为 <code>int</code></strong> 。在16位计算机中基本整型数据占据2个字节，最高位表示正负符号位，取值范围 $-32768$ ~ $32767$。在32位计算机中基本整型占据4个字节，最高位位正负符号位，取值范围为 $-2147493648$ ~ $2147483647$ 。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;    <span class="comment">//声明了整型变量 a</span></span><br></pre></td></tr></table></figure></li><li><p><strong>短整型：关键字为 <code>short int</code> (<code>int</code>可以省略)</strong>。短整型占2个字节，最高位为符号位，取值范围为 $-32768$ ~ $32767$。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> a;    <span class="comment">//声明了短整型变量 a</span></span><br><span class="line"><span class="type">short</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong>长整型：关键字为 <code>long int</code>( <code>int</code> 可以省略)</strong>。长整型占4个字节，最高位为符号位，取值范围为 $-2^{31}$ ~ $2^{31}-1$ 。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> a;    <span class="comment">//声明了长整型变量 a</span></span><br><span class="line"><span class="type">long</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong>双长整型：关键字为 <code>long long int</code>（<code>int</code> 可以省略）</strong>。双长整型占 8 个字节，最高位为符号位，取值范围为 $-2^{63}$ ~ $2^{63}-1$ 。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a;    <span class="comment">//声明了双长整型变量 a</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br></pre></td></tr></table></figure></li><li><p><strong>布尔型：关键字为 <code>bool</code></strong>。布尔型数据占据 2 个字节。<strong>其取值有两种：真（TRUE/1）和假（FLASE/0）</strong>。代码示例：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> x;    <span class="comment">//声明了布尔型变量 x</span></span><br></pre></td></tr></table></figure><blockquote><p>C99之后的Bool被定义为 <code>_bool</code>，再次之前布尔类型是通过 <code>int</code> 类型来定义的</p></blockquote><p>以上基本整型，短整型，长整型及双长整型都是可正可负的，可以看作省略了关键字 <code>signed</code> 的有符号类型，即以上的定义可以写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> loog a;</span><br></pre></td></tr></table></figure><p>如果在使用的数值无须符号，则定义为无符号类型，其关键字为 <code>unsigned</code> 。 定义无符号类型的整型变量只需要在前面加上该关键字即可。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> loog a;</span><br></pre></td></tr></table></figure><blockquote><p>无符号类型即全为正数，无负数（抛弃了符号位）</p></blockquote><p>无符号关键字只适用于整型变量。</p><p>C语言的变量必须“先定义，后使用”，从上面的示例可以看出，C语言中变量的定义格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储类型 数学类型 变量名称；</span><br></pre></td></tr></table></figure><blockquote><p>其中存储类型可以默认省略。</p></blockquote><h2 id="实型数据"><a href="#实型数据" class="headerlink" title="实型数据"></a>实型数据</h2><p>实型数据包括实型常数（常量）和实型变量，实型数据即带小数的数据（实数），或称浮点数。</p><p>C语言中实型常量只用十进制形式，但是其表示方式有两种：</p><ol><li>直接十进制形式，如：0123，-456.48。</li><li>指数形式，如： $1.23e-2$，$-4.123e2$。<br>指数形式通常用来表示一些比较大的数值，格式为：实数部分+字母 E 或者 e +正负号+整数部分。其中的 E 或者 e 表示十次方，即 $实数e^{-/+整数}$，并不是常规数学表达式中的自然底数，正负号表示指数部分的符号，整数为幂的大小。字母 E 或者 e 之前必须有数字，之后的数字必须为整数。</li></ol><p>C语言中实型数据按长度大小可以分为三类：</p><ol><li><strong>单精度型：关键字为 <code>float</code></strong>，占 4 个字节。提高 7 位有效数字，取值范围为 $-3.4 \times 10^{-38}$ ~ $3.4 \times 10^{38}$。</li><li><strong>双精度型：关键字为 <code>double</code></strong>，占 8 个字节，提供 16 位有效数字，取值范围为 $-1.7 \times 10^{-308}$ ~ $1.7 \times 10^{308}$。</li><li><strong>长双精度型：关键字为 <code>long double</code></strong>，占 16 个字节，取值范围为  $-1.2 \times 10^{-4932}$ ~ $1.2 \times 10^{4932}$。</li></ol><blockquote><p>计算机中实型数据实际上是以指数的形式存储的，用二进制来表示小数部分以及用 2 的幂次来表示指数部分。但不同长度类型中究竟用多少位来表示小数部分，多少位来表示指数部分，各种 C 编译系统不尽相同。</p></blockquote><p>【实例】输出单精度实数，验证有效数字位数<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">1111111.222222</span>;    <span class="comment">//小数点前7位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107164922598.png" alt="image-20220107164922598" style="zoom:80%;" /><br>【说明】我用的是VScode，手动配置链接的 <a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW</a>，可以得出此编译器的单精度浮点的有效位为 8 位。</p><p>【实例】输出双精度实数<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">1111111.22222</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165026188.png" alt="image-20220107165026188" style="zoom:80%;" /><br>【说明】</p><ul><li><strong>使用 <code>%f</code> 可以输出单精度或者双精度浮点数，对于长双精度浮点数，使用 <code>%Lf</code> 。</strong></li><li><strong><code>double</code> 输出的时候，默认输出小数后 6 位 ，不足 6 位时补 0，多余 6 位时四舍五入后只输出前 6 位。</strong></li><li><strong>可以使用 <code>%.xf</code> 修改 x 的值来指定输出小数点后几位</strong></li></ul><h2 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h2><p>C语言中字符型数据包括字符常量和字符变量。</p><p><strong>字符常量必须用单引号括起来，单引号中只能为单个字符</strong>，在内存中占用一个字节，例如：<code>A</code>，<code>a</code>，<code>#</code>等。</p><p><strong>字符型数据在C语言中是以 ASCII 码形式存储的</strong>，即字符常量的数值就是其保持的 ASCII 码的值，如：<code>A</code> 的 ASCII 码值为 65 。<strong>因为 ASCII 码值为整型，故C语言中字符型数据与整型数据可以在同一个表达式中出现，并且不会进行类型转换</strong>。例如： <code>a</code>-32相当于 97-32 。</p><blockquote><p>可以通过对大写字母 +32 来进行大小写转换。</p></blockquote><p>C语言中还有一类特殊的字符，称为<strong>转义字符</strong>，<strong>以 <code>\</code> 开头，根据斜杠后面的不同字符表达特定的含义</strong>。常用的转义字符如下：</p><ul><li><strong><code>\n</code>：回车换行。</strong></li><li><code>\b</code>：退格</li><li><code>\r</code>：回车</li><li><strong><code>\t</code>：水平制表，即横向跳到下一个制表位。</strong></li><li><code>\v</code>：垂直制表，即纵向跳到下一个制表位。</li><li><strong><code>\\</code>：反斜线符号 <code>\</code>。</strong></li><li><strong><code>\&#39;</code>：单引号 <code>&#39;</code></strong>。</li><li><strong><code>\&quot;</code>：双引号 <code>&quot;</code></strong>。</li><li><code>\a</code>：鸣铃。</li><li><code>\f</code>：走纸换页。</li><li><strong><code>\ddd</code>：1~3位八进制数所代表的字符</strong>。</li><li><strong><code>\xhh</code>：1~2位十六进制数所代表的字符</strong></li></ul><p>实际上，利用 <code>\ddd</code> 和 <code>\xhh</code> 可以表示任意一个字符，分别利用八进制和十六进制转换为 ASCII 码的值。例如：<code>\123</code> 输出表示为 <code>S</code>。</p><p><strong>定义字符型变量的关键字为 <code>char</code></strong>，字符型变量在内存中占用一个字节。需要注意的是，在使用字符型存储整型时，只有一个字节的大小，注意溢出问题。</p><p>【实例】输出字符及其对应的 ASCII 码<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch=%c\nASCII=%d&quot;</span>, ch, ch);</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165203189.png" alt="image-20220107165203189" style="zoom:80%;" /></p><p>此外，C语言中还有一类数据，是用一对双引号括起来的一个或者多个字符，称为字符串常量，简称字符串，例如 <code>Hello,World</code>。</p><p>但是C语言并没有字符串类型，字符串类型的处理需要字符型数组。数组的内容后面会涉及，此处先不赘述。</p><h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><p>C语言允许不同类型的数据混合运算，运算中可以按照一定的规则或者人为干预进行类型转换。<strong>转换的方式分为两种：隐式类型转换和显式类型转换</strong>。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>隐式类型转换是编译系统自动进行的，不需要人为干预，隐式类型转换遵循三个基本规则：</p><ol><li><p>如果参与运算的变量类型不同，则先转换成同一类型，然后进行运算。</p></li><li><p>按“低位向高级转换”原则，如果运算中有几种不同类型的操作数，则同一转换为类型高的数据类型，再进行运算，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="type">double</span> c = <span class="number">2.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,a + b + c);</span><br></pre></td></tr></table></figure><p>在计算的时候，先将 a,b转换为 <code>double</code> 类型，然后进行计算，所得的结果为 <code>double</code> 类型。</p><p>各种类型转换方向如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(char,short) --&gt;B(int) --&gt;C(unsigned) --&gt;D(long) --&gt;E(double)</span><br><span class="line">    F(float) --&gt;E(double)</span><br></pre></td></tr></table></figure><blockquote><p>浮点型运算时系统一律转换为双精度浮点进行运算，运算结束后再根据类型来转换回去，以防止计算精度丢失。</p></blockquote></li><li><p>赋值运算符号作业两边的数据类型不同时，赋值号右边数据类型将转化为与左边数据一致的类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="type">double</span> c = <span class="number">2.3</span>;</span><br><span class="line"><span class="type">int</span> d = a + b + c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d);</span><br></pre></td></tr></table></figure><p>a+b+c得出的结果为 <code>double</code> 类型，在进行赋值后，被强制转换为 d 的 <code>int</code> 类型，丢失部分精度。</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换即显式类型转换，其作用是人为将相关类型转换为指定的数据类型。转换格式代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(目标的类型标识符)(要转换的变量)</span><br></pre></td></tr></table></figure><p>【实例】使用强制类型转换参与运算<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="type">int</span> d = a + (<span class="type">int</span>)b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%f&quot;</span>,d,b);</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165321653.png" alt="image-20220107165321653" style="zoom:80%;" /><br>【说明】<strong>强制类型转换不改变原数据类型，只是在参与运算的时候改变运算时的参与数据类型</strong>。</p><h1 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h1><p>运算表达式是对数据进行操作和处理的基本单位，一个运算表达式由两m个要素组成的运算量与运算符。运算量包括常量和变量。C语言提供了很多基本运算来实现运算处理，这些运算符可以分为以下几类：</p><ol><li>算术运算符：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>(求余数，或者称模运算)。</li><li>自增自减运算符：<code>++</code>,<code>--</code>。</li><li>关系运算符：用于比较运算，包括 <code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>=&lt;</code>,<code>==</code>,<code>!=</code>(不相等)。</li><li>逻辑运算符：用于逻辑运算，包括 <code>&amp;&amp;</code>(与),<code>||</code>(或),<code>!</code>(非)。</li><li>位运算符：按照二进制位进行运算，包括 <code>&amp;</code>(位与)，<code>|</code>(位或)，<code>~</code>(位非)，<code>&lt;&lt;</code>(左移)，<code>&gt;&gt;</code>(右移)。</li><li>条件运算符：<code>?:</code> 条件运算符是C语言中唯一一个三目运算符，用于条件求值。</li><li>赋值运算符：可以分为下面三类<ul><li>简单赋值运算符：<code>=</code></li><li>复合算术赋值运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>。</li><li>复合位位运算赋值运算符：<code>&amp;=</code>，<code>|=</code>，<code>^=</code>，<code>&gt;&gt;=</code>，<code>&lt;&lt;=</code>。</li></ul></li><li>逗号运算符：<code>,</code>。</li><li>指针运算符：<code>*</code>。</li><li>地址运算符：<code>&amp;</code>。</li><li>构造类型特殊运算符：<code>.</code>(引用成员运算符)，<code>-&gt;</code>(指向成员运算符)，<code>[]</code>(下标运算符)。</li><li>小括号运算符：<code>()</code>。</li><li>花括号运算符：<code>&#123;&#125;</code>。</li><li>长度运算符：<code>sizeof(类型运算符)</code>用于计算数据类型所占的字节数。</li><li>类型转换运算符：（类型标识符）（表达式）</li></ol><h2 id="算术运算符和算术表达式"><a href="#算术运算符和算术表达式" class="headerlink" title="算术运算符和算术表达式"></a>算术运算符和算术表达式</h2><h3 id="算符运算符及其相关"><a href="#算符运算符及其相关" class="headerlink" title="算符运算符及其相关"></a>算符运算符及其相关</h3><p>算术运算符：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>(求余数，或者称模运算)。<br>需要注意的是：</p><ol><li><strong>关于除法运算符 <code>/</code>：如果两个整数相除，则结果为整数，小数部分将被去掉，例如：5/2，结果为 2，而不是 2.5。两个操作数只要有一个是浮点数，则结果为浮点数</strong>。</li><li><strong>关于模运算符 <code>%</code>:只适用于两个整数取余，其两个运算量只能是整型或者字符型，不能是其他类型，取余结果的符号是由被除数决定的，例如：7%(-3)的结果是 1，而（-7）%（-3）结果为 -1</strong>。</li></ol><h3 id="算术运算符的优先级与结合性"><a href="#算术运算符的优先级与结合性" class="headerlink" title="算术运算符的优先级与结合性"></a>算术运算符的优先级与结合性</h3><p>算术表达式的计算按运算符的优先级从高到低依次进行。双目运算符的优先级与基本四则运算法则一致，先乘除再加减。</p><p>在一个运算符出现同级运算符时，运算遵循“左结合律”，即按照自左向右进行计算，例如：a+b+c，先 a+b ,再 +c。</p><h2 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h2><h3 id="赋值运算符及其说明"><a href="#赋值运算符及其说明" class="headerlink" title="赋值运算符及其说明"></a>赋值运算符及其说明</h3><p>赋值运算符的作用时将一个数据赋值给一个变量。赋值运算符：可以分为下面三类</p><ul><li>简单赋值运算符：<code>=</code></li><li>复合算术赋值运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>。</li><li>复合位位运算赋值运算符：<code>&amp;=</code>，<code>|=</code>，<code>^=</code>，<code>&gt;&gt;=</code>，<code>&lt;&lt;=</code>。</li></ul><blockquote><p>例如：<code>a+=1</code> 等价于 <code>a=a+1</code>，其余同理，此处不做过多说明。</p></blockquote><p><strong>所有赋值运算符都是将右边的值赋值给左边，因此赋值运算符左边只能为变量。</strong></p><h3 id="赋值运算符的结合性"><a href="#赋值运算符的结合性" class="headerlink" title="赋值运算符的结合性"></a>赋值运算符的结合性</h3><p>赋值运算符遵循“右结合性”，方向为“自右向左”。</p><p>【实例】验证赋值运算符的结合性<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line">a *= a += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165243975.png" alt="image-20220107165243975" style="zoom:80%;" /></p><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><h3 id="自增自减运算符及其表达式"><a href="#自增自减运算符及其表达式" class="headerlink" title="自增自减运算符及其表达式"></a>自增自减运算符及其表达式</h3><p>自增运算符 <code>++</code>，自减运算符 <code>--</code> 的作用是让变量加 1 或者减 1 ，常用于循环结构中，但自增自减运算符都有前置和后置之分，前置后置决定了变量使用与计算的顺序：</p><ul><li>自增运算符前置：如 <code>++i</code>，是先将 i 的值加 1 后，再使用 i 的值。</li><li>自增运算符后置：如 <code>i++</code>，是先使用 i 的值，然后再加 1 。</li><li>自减运算符前置：如 <code>--i</code>，是先将 i 的值减 1 后，再使用 i 的值。</li><li>自减运算符后置：如 <code>i--</code>，是先使用 i 的值，再使 i 的值减 1 。</li></ul><p><strong>自增自减运算符只能作用域变量，不能用于常量或者表达式，如 <code>3++</code>，<code>--（x*y）</code>等都是不合法的</strong>。</p><h3 id="自增自减的结合性"><a href="#自增自减的结合性" class="headerlink" title="自增自减的结合性"></a>自增自减的结合性</h3><p>自增自减运算符为右结合性，结合方向为“自右向左”。需要注意的是，自增自减运算符不可以作用于表达式。</p><p>【实例】验证自增自减运算符结合性<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b,c;</span><br><span class="line">a =<span class="number">10</span>;</span><br><span class="line">b = !a++;</span><br><span class="line">c = a--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\nc=%d&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure><p>【输出结果】 <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165448270.png" alt="image-20220107165448270" style="zoom:80%;" /><br>【说明】 <code>!x</code>x代表数值，结果为 0 。<code>!</code>默认非 0 值为真，采用非操作后，变为假，然后整型输出就是 0 。反之，如果 <code>!0</code>，则输出 1 。</p><h2 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h2><p>C语言中，<code>,</code>逗号运算符作为分割符号。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br></pre></td></tr></table></figure><p>也可以作为运算符，用于链接多个表达式，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式 <span class="number">1</span>,表达式 <span class="number">2</span>,...,表达式 n;</span><br></pre></td></tr></table></figure><p>当逗号用于运算时，将从左到右依次求取各个表达式的值。</p><h1 id="数据的输入和输出"><a href="#数据的输入和输出" class="headerlink" title="数据的输入和输出"></a>数据的输入和输出</h1><p>在C语言中通过输入/输出函数实现数据的输入/输出。<strong>系统提供了一批标准输出函数，这些函数包含在一些头文件中，称为库函数</strong>。要使用这些函数，必须在程序开头事先用文件包含命令 <code>#include</code> 包含这些头函数。</p><p>以下部分，主要是标准输入/输出函数，即 <code>&lt;stdio.h&gt;</code> 库函数里的内容。</p><h2 id="格式输入函数-scanf"><a href="#格式输入函数-scanf" class="headerlink" title="格式输入函数 scanf"></a>格式输入函数 <code>scanf</code></h2><p>格式输入函数 <code>scanf</code> 将数据按规定的格式从键盘上读取到指定变量中。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式示例</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输入项地址列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的值为空&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>scanf</code> 函数从键盘读入数据时，需要注意以下几点：</p><ol><li><p>输入多个数据时，建议使用空格或者相关分隔符进行分割，这样数据的输入不会出现二义性。代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如说下面这样</span></span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br></pre></td></tr></table></figure></li><li><p>输入的数据个数与顺序要与 <code>sacnf()</code> 函数一致。</p></li><li><p>如果格式控制字符串中有普通字符，则必须依次原样输入，否则可能发生错误。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;a=%d,b=%d,c=%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的时候需要输入</span></span><br><span class="line"><span class="comment">//a=1,b=2,c=3</span></span><br></pre></td></tr></table></figure></li></ol><p>下面对C语言的格式符进行解释说明。<br><strong>格式符皆以 <code>%</code> 开始标记</strong>，格式示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% [m][l或h]数据类型声明字母</span><br></pre></td></tr></table></figure><p>其中，方括号为可选项，可以为空，但是数据类型字母声明不可缺省。</p><ol><li>数据类型声明字母<ul><li><strong>d：输入十进制整数</strong>。</li><li>o：输入八进制整数。</li><li>x：输入十六进制整数。</li><li>u：输入无符号十进制整数。</li><li><strong>f：输入小数形式实型数</strong>。</li><li>e：输入指数形式实型数。</li><li><strong>c：输入单个字符</strong>。</li><li>s：输入字符串。</li></ul></li><li><strong><code>l</code> 和 <code>h</code> 为长度格式符。<code>l</code> 用于规定长整型和双长整型，<code>h</code> 则规定输入为短整型</strong>。<ul><li><code>%ld</code> , <code>%lo</code> , <code>%lx</code>：表示输入数据为长整型十进制，长整型八进制，长整型十六进制。</li><li><code>%lf</code> , <code>le</code>：表示输入双精度型小数形式，双精度指数形式。</li><li><code>%hd</code> , <code>%ho</code> , <code>%hx</code> ：表示输入的数据类型为短整型十进制，短整型八进制，短整型十六进制。</li></ul></li><li><strong><code>m</code> 为十进制整数，用于指定输入数据的宽度（即数字个数）</strong>。代码示例：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>输入 123456，输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165540946.png" alt="image-20220107165540946" style="zoom:80%;" /><br>该代码读取的时候只读取前 5 个字符，即5个宽度。后面的默认去除。</p><p>对于指定了宽度的输入格式，数据之间可以无分隔符，系统会自动截取宽度来读入。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%5d%2d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a,b);</span><br></pre></td></tr></table></figure><p>输入1234567，输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165620883.png" alt="image-20220107165620883" style="zoom:80%;" /></p><p><strong>对于浮点型，数据宽度为数据的整体宽度，包括小数点在内，即数据宽度 m=整体位数+1（小数点）+小数位数</strong>。格式输入函数只能指定数据整体的宽度，无法指定小数位数，这和后面输出函数 <code>printf</code>时不同的。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%3f%3f&quot;</span>, &amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%f,b=%f&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>输入 1.23.4 ，输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107165634840.png" alt="image-20220107165634840" style="zoom:80%;" /></p><h2 id="格式输出函数-printf"><a href="#格式输出函数-printf" class="headerlink" title="格式输出函数 printf"></a>格式输出函数 <code>printf</code></h2><p><strong>格式输出函数 <code>printf</code> 将指定的数据按指定的格式输出到控制台上</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学术定义版</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输出项列表);</span><br><span class="line"><span class="comment">//通俗版</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要输出到控制的部分&quot;</span>,伴随输出需要的参数);</span><br></pre></td></tr></table></figure><p><code>printf()</code> 函数中的格式控制字符和 <code>scansf()</code> 函数一致，包含格式符与普通字符。格式符用于控制输出格式，普通字符将原样输出显示。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a=<span class="number">1.2</span>,b=<span class="number">1.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%f,b=%f&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>其中 <code>%f</code> 为格式控制符， <code>a=</code> 则是普通字符，会输出到屏幕上。<br><code>printf()</code> 中的格式符与 <code>scanf()</code> 一致，皆以 <code>%</code> 为开始标记，但是相比要复杂一些，格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% [±] [<span class="number">0</span>] [m] [.n] [l或h] 数据类型字母</span><br></pre></td></tr></table></figure><ol><li><p>数据类型声明字母与 <code>scanf()</code> 基本一致，有少许扩充：</p><ul><li><strong>d：以十进制整数形式输出</strong>。</li><li>o：以八进制整数形式输出。</li><li>x或者X：以十六进制整数形式输出。</li><li>u：以无符号十进制整数形式输出。</li><li><strong>f：以小数形式实型数输出</strong>。</li><li>e或者E：以指数形式实数输出。</li><li>c：以单个字符形式输出。</li><li>s：以字符串形式输出。</li><li>g或者G：由系统决定采用 <code>%f</code> 格式还是 <code>%e</code> 格式，以使输出宽度最小，不输出无意义的 0。</li><li>% ：输出百分号（例如<code>%%</code>）</li></ul></li><li><p><code>l</code> 或 <code>h</code> 的含义同 <code>sancf()</code>；<code>l</code> 双精度/长整型，<code>h</code> 短整型。</p></li><li><p><code>m.n</code> 指定输出数据的宽度。<br>输出整数时：<strong>只有 <code>m</code>，没有 <code>.n</code> 部分。 <code>m</code> 表示输出整数的位数。如果整数的实际位数大于指定的 <code>m</code>，则按照实际的位数输出，如果整数的实际位数小于指定 <code>m</code>，则左边按位补空格</strong>。<br>输出浮点数时：<code>m</code> 指定数据总宽度，含义与 <code>scanf</code> 函数相同， <strong>m=整数位数+1（小数位）+小数位数</strong>。<strong><code>n</code> 指定小数位数</strong>。<br>【实例】指定浮点数输出格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a=<span class="number">1.123</span>,b=<span class="number">112.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%3.1f b=%f&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107171339828.png" alt="image-20220107171339828" style="zoom:80%;" /></p><p>说明：<code>%3.1f</code>指定了3位输出位数，排除一位小数点，<code>.1</code>指定了一位小数，则输出<code>1.1</code>。</p></li><li><p><strong>[0]指定输出数据空位置的填充方式，指定0则以0填充，不指定则默认空格填充</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">123</span>;</span><br><span class="line"><span class="type">float</span> a=<span class="number">1.123</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%3.1f b=%05d&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107171951763.png" alt="image-20220107171951763" style="zoom:80%;" /></p></li><li><p><strong><code>±</code>指定输出数据的对齐方式：指定 <code>+</code> 时，输出右对齐；指定 <code>-</code> 时，输出左对齐；不指定时默认为<code>+</code>，输出右对齐</strong>。</p><blockquote><p>此项在不同的编译器有不同的处理方式，部分编译器不支持该格式</p></blockquote></li></ol><h2 id="字符输出函数-getchar"><a href="#字符输出函数-getchar" class="headerlink" title="字符输出函数 getchar()"></a>字符输出函数 <code>getchar()</code></h2><p><strong>字符输入函数 <code>getchar()</code>的功能是从输入设备上读取输入的一个字符，其返回值即为所读入的字符</strong>，一般与赋值语句联用，将读取的字符传递给变量。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line">c = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c的值为%c&quot;</span>, c);</span><br></pre></td></tr></table></figure><blockquote><p>该函数只会读取一个字符，如果输入多个字符，默认读取首字符。</p></blockquote><h2 id="字符输出函数-putchar"><a href="#字符输出函数-putchar" class="headerlink" title="字符输出函数 putchar()"></a>字符输出函数 <code>putchar()</code></h2><p><strong>字符输出函数 <code>putchar()</code>的功能是向控制台输出一个字符</strong>，调用格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(c);</span><br></pre></td></tr></table></figure><p>c可以是输出的字符常量或者变量，也可以<strong>是整型常量或者变量（此时系统会默认将其转化为ASCII码对应的字符）</strong>。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">78</span>;</span><br><span class="line"><span class="built_in">putchar</span>(a);</span><br></pre></td></tr></table></figure><p>输出结果：<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107173133432.png" alt="image-20220107173133432" style="zoom:80%;" /></p><h1 id="赋值语句和顺序结构程序设计"><a href="#赋值语句和顺序结构程序设计" class="headerlink" title="赋值语句和顺序结构程序设计"></a>赋值语句和顺序结构程序设计</h1><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p><strong>赋值语句即实现赋值功能</strong>，这里主要说明<code>=</code>运算符构成的赋值语句。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=表达式;</span><br></pre></td></tr></table></figure><p>表达式可以是常量，变量或者运算式。关于<code>=</code>赋值要注意的是：</p><ol><li><p>可以在声明变量的时候，直接赋值。代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>也可以先声明变量，后赋值，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>赋值语句可以嵌套，即表达式可以为赋值表达式，例如下面的操作是合法的，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是<strong>下面的操作是非法的</strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = b = c = d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="顺序结构程序设计"><a href="#顺序结构程序设计" class="headerlink" title="顺序结构程序设计"></a>顺序结构程序设计</h2><p>C语言为结构化程序设计语言，分为三种基本结构：顺序结构，选择结构，循环结构。<strong>顺序结构是最基本的结构，程序从上到下依次执行</strong>。实际上选择结构与循环结构都为局部结构，是在整体顺序框架中的。顺序结构程序按照需要实现的功能逻辑顺序进行设计。</p><p>【实例】输入圆的半径，计算圆的面积<br>【代码示例】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> r;    <span class="comment">//定义圆的半径</span></span><br><span class="line">    <span class="type">float</span> s;    <span class="comment">//定义圆的面积</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入圆的半径&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;r);</span><br><span class="line">    s = <span class="number">3.14</span> * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆的面积为%f&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【输出结果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220107175919896.png" alt="image-20220107175919896" style="zoom:80%;" /></p><h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><p>数学函数属于库函数(Library function)，在头文件<code>math.h</code>中，因此<strong>要使用数学函数，必须在程序开头处使用文件包含命令<code>#include</code>将<code>math.h</code>包含进来，例如<code>#include &lt;math.h&gt;</code></strong>。C语言函数库提供了丰富的数学函数供用户使用，如下是一些常用的函数：</p><ol><li><p><strong>绝对值函数<code>abs()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">-5</span>);</span><br></pre></td></tr></table></figure><p>输出结果：5</p><blockquote><p><code>labs()</code>以及<code>fabs()</code>分别用于求长整型数和实数的绝对值</p></blockquote></li><li><p><strong>开方函数<code>sqrt()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>输出结果：2</p></li><li><p><strong>对数函数<code>log10()</code></strong>（以10为底），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">log10</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>输出结果：1.000000</p></li><li><p><strong>自然对数函数<code>log()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">log</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：0.693147</p></li><li><p><strong>指数函数<code>exp()</code></strong>（即$e^x$，以e为底），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">exp</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">exp</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：7.389056</p></li><li><p><strong>次方函数<code>pow10()</code></strong>（即$10^x$，以10为底），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pow10</span><span class="params">(<span class="type">int</span> p)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">pow10(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：100</p><blockquote><p>部分编译器不支持该函数</p></blockquote></li><li><p><strong>次方函数<code>pow()</code></strong>（即$x^y$），代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果：4</p></li><li><p><strong>正弦函数<code>sin()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：-0.988032</p></li><li><p><strong>余弦函数<code>cos()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">cos</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：0.154251</p></li><li><p><strong>正切函数<code>tan()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">tan</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="built_in">tan</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>输出结果：-6.405331</p></li><li><p><strong>反正弦函数<code>asin()</code>，反余弦函数<code>acos()</code>，反正切函数<code>atan()</code></strong>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数代码</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">asin</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">acos</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atan</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure></li></ol><h1 id="常见错误分析"><a href="#常见错误分析" class="headerlink" title="常见错误分析"></a>常见错误分析</h1><ol><li>遗漏符号，例如分号，逗号，引号等。</li><li>未定义就使用，或者在定义之前使用该变量。</li><li>使用中文字符不被识别。</li><li>语法错误。</li><li>数据溢出。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【1.0】C-引言</title>
      <link href="/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%901-0%E3%80%91C-%E5%BC%95%E8%A8%80/"/>
      <url>/2022/05/22/C%E8%AF%AD%E8%A8%80/%E3%80%901-0%E3%80%91C-%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="【1-0】引言"><a href="#【1-0】引言" class="headerlink" title="【1.0】引言"></a>【1.0】引言</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是C语言基础的笔记，也是我的复习笔记，本笔记没有长篇大论的理论，也没有过多的基础解释，对于稍微熟悉一点计算机语言的但是又迫切复习的小伙伴来说可能会有一些帮助。</p><p>前排提醒，本文需要一定的<strong>计算机基础</strong>和<strong>计算机语言基础</strong></p><p>废话不多说，直接开始C语言之旅。</p><h1 id="C语言入门程序结构"><a href="#C语言入门程序结构" class="headerlink" title="C语言入门程序结构"></a>C语言入门程序结构</h1><p>直接展示计算机语言的入门编程，<code>Hello world</code>，代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);    <span class="comment">//输出Hello World</span></span><br><span class="line">    getchar();    <span class="comment">//暂停控制台</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码结构很简单，先来剖析一下每一个部分是什么意思。</p><ul><li>第一行代码 <code>#include &lt;stdio.h&gt;</code> ，是C语言的头函数，<code>#</code>后面是预处理函数宏，这句话的意思是引入<code>stdio.h</code> 这个系统文件，在头文件中包含了C语言开始的入口和基本的处理，所以需要编写C语言，开头一定需要引入头函数。</li><li>第二行 <code>int main()&#123;&#125;</code> 表示这是个“主函数”，所有我们需要跑的代码都需要写在 <code>&#123;&#125;</code> 花括号里面才可以运行，它是我们的写的代码的入口点。</li><li>第三行 <code>printf(&quot;Hello world&quot;);</code> 它的意思是在屏幕上输出 <code>()</code> 括号里的内容。因为括号里写的是 “Hello world”,所以它会在控制台上输出相应的字符。</li><li>第四行 <code>getchar();</code> ，你可能在一般入门的地方不会见到这个函数，如果你使用的是 <code>VScode</code> 编辑器手动链路C底层或者其他编辑器，如果运行的时候，控制台一秒闪过，就需要使用这个函数来暂停控制台。</li><li>第五行 <code>return 0;</code> 它的意思是返回一个 0 ，你或许会有疑问：为什么要返回 0，返回其他可以不可以，为什么要返回 0 ，我可以先告诉你的是：它可以自定义返回大部分的整型数字，例如：1，2，3，4，5，6，7，8，9等等。至于为什么不可以返回例如 “你好” 之类的，后面学到函数的时候就会明白了。</li><li>如果你足够细心就会发现，对于主函数里的每行代码的末尾都有 <code>;</code> ，结束。是的，<code>;</code> 表示每行代码的结束。</li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>另外，最终重要的是注释，注释是对代码的一种解释说明，它不会影响代码的任何运行，只是为了方便后来的人来阅读或者理解别人的代码来辅助的。<br>C语言的注释格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双斜杠，表示行内注释，它只能注释一行的内容</span></span><br><span class="line"><span class="comment">//如果你希望可以注释很多行的内容可以使用如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这样/*~*/</span>里面的内容就全部注释了</span><br><span class="line">    这行也是被注释了</span><br><span class="line">    这行也是</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>注释是我们的法宝，也是帮助我们快速入门看懂代码的基础。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，你现在已经学会C语言了，快去写一个学生管理系统吧（bushi）</p><p>C语言是万物的基础，对于 <code>JAVA</code> <code>C#</code> 等高级语言来说，底层是又C语言发展而来，俗话说得好“汇编生C，C生万物”。掌握好C语言，对不论是其他计算机语言，还是其他计算机的知识，都有一定的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-4.0】R-基本图形</title>
      <link href="/2022/05/22/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-4-0%E3%80%91%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2/"/>
      <url>/2022/05/22/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-4-0%E3%80%91%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这不是基本图形的说明使用，例如常见的条形图，饼图，直方图等，此内容可以当作快速查阅手册。</p><h1 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h1><h2 id="简单条形图"><a href="#简单条形图" class="headerlink" title="简单条形图"></a>简单条形图</h2><p><strong>条形图通过函数<code>barplot()</code>来实现</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>height<span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> space <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">        names.arg <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> legend.text <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> beside <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">        horiz <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span></span><br><span class="line">        col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> border <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> sub <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">        xlim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xpd <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="built_in">log</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> axisnames <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">        cex.axis <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;cex.axis&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> cex.names <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;cex.axis&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        inside <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> axis.lty <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> offset <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        add <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ann <span class="operator">=</span> <span class="operator">!</span>add <span class="operator">&amp;&amp;</span> par<span class="punctuation">(</span><span class="string">&quot;ann&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> args.legend <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>height</code>：接收一个向量参数，根据向量参数内容绘制图形</strong></li><li><strong><code>horiz = TRUE</code></strong>：设置为<code>TRUE</code>则图形会生成水平条形图</li><li><strong><code>main</code>：图形标题</strong></li><li><strong><code>xlab</code>：X 轴标签</strong></li><li><strong><code>ylab</code>：Y 轴标签</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>horiz <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>main <span class="operator">=</span> <span class="string">&#x27;这是标题&#x27;</span><span class="punctuation">,</span></span><br><span class="line">        xlab<span class="operator">=</span><span class="string">&#x27;这是X轴&#x27;</span><span class="punctuation">,</span>ylab<span class="operator">=</span><span class="string">&#x27;这是Y轴&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220512200201549.png" alt="image-20220512200201549" style="zoom:50%;" /></p><p>如果<strong>希望标签距离图表更近一些</strong>，可以通过<strong>额外设置<code>mtext</code>来增加外边框的文本标签</strong>，例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>horiz <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>main <span class="operator">=</span> <span class="string">&#x27;这是标题&#x27;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">,</span>ylab<span class="operator">=</span><span class="string">&#x27;这是Y轴&#x27;</span><span class="punctuation">)</span></span><br><span class="line">mtext<span class="punctuation">(</span><span class="string">&#x27;这是X轴&#x27;</span><span class="punctuation">,</span>side<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>line <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220512202945242.png" alt="image-20220512202945242" style="zoom:50%;" /></p><blockquote><p>如果需要绘制的变量是一个因子或者有序型因子，可以直接使用<code>plot()</code>绘制垂直条形图</p></blockquote><h2 id="堆砌条形图和分组条形图"><a href="#堆砌条形图和分组条形图" class="headerlink" title="堆砌条形图和分组条形图"></a>堆砌条形图和分组条形图</h2><p><strong>如果传入的<code>Height</code>参数不是向量而是一个矩阵，则绘制的结果是堆砌条形图或者分组条形图</strong>。<strong>堆砌条形图和分组条形图取决于参数<code>beside=FALSE/TRUE</code></strong>，<strong>如果为<code>TRUE</code>，则矩阵中的每一列表示一个分组，各列的值将并列而不是堆砌；如果为<code>FALSE</code>，则矩阵中的每一列都生成图中的一个条形，其高度取决于其值。</strong></p><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">opar <span class="operator">=</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 将图形分割成一行两列</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制堆砌条形图</span></span><br><span class="line">barplot<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制分组条形图</span></span><br><span class="line">barplot<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span>beside <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220512204141414.png" alt="image-20220512204141414" style="zoom: 67%;" /></p><h2 id="均值条形图"><a href="#均值条形图" class="headerlink" title="均值条形图"></a>均值条形图</h2><p>可以将数据计算出各种平均值，中位值等结果生成相关条形图，代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>summary<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        names.arg <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;Min.&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;1st Qu.&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;Median&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;Mean&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;3rd Qu.&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;Max&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        las<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220512212911555.png" alt="image-20220512212911555" style="zoom: 67%;" /></p><blockquote><p>关于文本显示不全问题，可以参考<a href="https://helloseraphine.top/index.php/archives/560.html">关于R以及Rstudio的相关问题</a>，或者查看下面内容</p></blockquote><h3 id="条形图微调"><a href="#条形图微调" class="headerlink" title="条形图微调"></a>条形图微调</h3><p>随着条数的增多，标签可能会重叠或者消失，可以通过如下参数来调整：</p><ul><li><strong><code>cex.names</code>：（数值型）小于 1 的数值表示缩小标签字体大小</strong></li><li><strong><code>names.arg</code>：（向量）允许自定义标签内容</strong></li><li><strong><code>las=2</code>：旋转字体朝向</strong></li></ul><h2 id="棘状图"><a href="#棘状图" class="headerlink" title="棘状图"></a>棘状图</h2><p>这是一种特殊的条形图，<strong>棘状图对堆砌图进行重缩放，使得每个条形的总值为 1 ，而每一段数据则以比例来呈现。棘状图可以通过<code>vcd</code>包中的<code>spine()</code>来绘制</strong>，代码示例：</p><blockquote><p>注意：<code>spine</code>传递的参数必须是双向表，即<code>table</code></p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 棘状图</span></span><br><span class="line">library<span class="punctuation">(</span>vcd<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> table<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>trees<span class="operator">$</span>Height<span class="punctuation">)</span></span><br><span class="line">spine<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220512215113129.png" alt="image-20220512215113129" style="zoom:50%;" /></p><h1 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h1><p>饼图随处可见，可以<strong>通过函数<code>pie</code>来创建</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pie<span class="punctuation">(</span>x<span class="punctuation">,</span> labels <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">,</span> edges <span class="operator">=</span> <span class="number">200</span><span class="punctuation">,</span> radius <span class="operator">=</span> <span class="number">0.8</span><span class="punctuation">,</span></span><br><span class="line">    clockwise <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> init.angle <span class="operator">=</span> <span class="keyword">if</span><span class="punctuation">(</span>clockwise<span class="punctuation">)</span> <span class="number">90</span> <span class="keyword">else</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">    lty <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code>：（数值型）表示每个扇形所占的面积</strong></li><li><strong><code>labels</code>：（向量/单体取决于X）表示每个扇形的标签</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 饼图</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">pie<span class="punctuation">(</span>a<span class="punctuation">,</span>labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;苹果&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;西瓜&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;橘子&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220512215613638.png" alt="image-20220512215613638" style="zoom:80%;" /></p><p>如果希望<strong>实现<code>3D</code>饼图的效果，则可以使用<code>plotrix</code>包中的<code>pie3D()</code>函数来实现</strong>，代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3D饼图</span></span><br><span class="line">library<span class="punctuation">(</span>plotrix<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2.2</span><span class="punctuation">)</span></span><br><span class="line">name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;苹果&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;西瓜&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;橘子&#x27;</span><span class="punctuation">)</span></span><br><span class="line">pie3D<span class="punctuation">(</span>a<span class="punctuation">,</span>labels<span class="operator">=</span>name<span class="punctuation">,</span>explode <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>explode</code>：表示饼的分离程度</strong></li></ul><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513184517721.png" alt="image-20220513184517721" style="zoom:50%;" /></p><p>如上图，在不标注标签数值的情况下，我们的肉眼获取无法区分”西瓜”和”橘子”的大小区别，这个时候可以使用<strong>扇形图</strong>。它是<strong>通过<code>plotrix</code>包中的<code>fan.plot()</code>函数来实现的</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3D饼图</span></span><br><span class="line">library<span class="punctuation">(</span>plotrix<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2.2</span><span class="punctuation">)</span></span><br><span class="line">name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;苹果&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;西瓜&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;橘子&#x27;</span><span class="punctuation">)</span></span><br><span class="line">fan.plot<span class="punctuation">(</span>a<span class="punctuation">,</span>labels<span class="operator">=</span>name<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513190120549.png" alt="image-20220513190120549" style="zoom:50%;" /></p><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p><strong>直方图是一种类似于条形图的图</strong>，它通过将X轴的值连续起来，然后Y值显示其高度，<strong>通过函数<code>hist()</code>函数来创建</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hist<span class="punctuation">(</span>x<span class="punctuation">,</span> breaks <span class="operator">=</span> <span class="string">&quot;Sturges&quot;</span><span class="punctuation">,</span></span><br><span class="line">     freq <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> probability <span class="operator">=</span> <span class="operator">!</span>freq<span class="punctuation">,</span></span><br><span class="line">     include.lowest <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fuzz <span class="operator">=</span> <span class="number">1e-7</span><span class="punctuation">,</span></span><br><span class="line">     density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;lightgray&quot;</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     main <span class="operator">=</span> paste<span class="punctuation">(</span><span class="string">&quot;Histogram of&quot;</span> <span class="punctuation">,</span> xname<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">     xlim <span class="operator">=</span> <span class="built_in">range</span><span class="punctuation">(</span>breaks<span class="punctuation">)</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     xlab <span class="operator">=</span> xname<span class="punctuation">,</span> ylab<span class="punctuation">,</span></span><br><span class="line">     axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">     nclass <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> warn.unused <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code>：数据值</strong></li><li><strong><code>freq</code>：（布尔值）当值为<code>FLASE</code>表示根据概率密度而不是频数绘制图形</strong></li><li><strong><code>breaks</code>：用于控制组的数量</strong></li></ul><p>在定义直方图中的单元时，默认将生成等距切分。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 普通直方图</span></span><br><span class="line">hist<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 概率密度直方图</span></span><br><span class="line">hist<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>freq <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 添加密度曲线</span></span><br><span class="line">hist<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">,</span>freq <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513192146545.png" alt="image-20220513192146545" style="zoom: 67%;" /></p><ul><li><strong><code>density(x)</code>：生成密度数据</strong></li></ul><h1 id="核密度图"><a href="#核密度图" class="headerlink" title="核密度图"></a>核密度图</h1><p>核密度图时用于估计随机变量密度概率的一种非参数方法，绘制核密度图的方法为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核密度图</span></span><br><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 基本和密度图</span></span><br><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;核密度图&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 颜色填充核密度图</span></span><br><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;核密度图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">polygon<span class="punctuation">(</span>density<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span><span class="punctuation">,</span>col <span class="operator">=</span> <span class="string">&#x27;black&#x27;</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>polygon</code>：绘制指定值下的多边形区域</strong>，可以理解为填充指定区域</li></ul><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513193651584.png" alt="image-20220513193651584" style="zoom: 67%;" /></p><p><strong>核密度可以通过分组来比较组间的差异，可以通过使用<code>sm</code>包中的<code>sm.density.compare()</code>来实现</strong>，具体方法和实现效果自行查询，此处不做说明。</p><h1 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h1><p>箱线图又称为盒须图，<strong>通过绘制连续型变量的五数总括，即最小值，下四分位数（第25百分位数），中位数（第50百分位数），上四分位数（第75百分位数）以及最大值，描述了连续型变量的分布</strong>。</p><p><strong>通过函数<code>boxplot</code>来实现</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>formula<span class="punctuation">,</span> data <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">,</span> subset<span class="punctuation">,</span> na.action <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">        xlab <span class="operator">=</span> mklab<span class="punctuation">(</span>y_var <span class="operator">=</span> horizontal<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        ylab <span class="operator">=</span> mklab<span class="punctuation">(</span>y_var <span class="operator">=</span><span class="operator">!</span>horizontal<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        add <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ann <span class="operator">=</span> <span class="operator">!</span>add<span class="punctuation">,</span> horizontal <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">        drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> lex.order <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 箱线图</span></span><br><span class="line">boxplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513195516930.png" alt="image-20220513195516930" style="zoom:50%;" /></p><p><strong>可以通过<code>boxplot.stats(x)</code>来输出用于构建图形的统计量</strong>。</p><h2 id="并列箱线图"><a href="#并列箱线图" class="headerlink" title="并列箱线图"></a>并列箱线图</h2><p>可以通过传入参数的时候传入如下格式的参数即可：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>并列数据<span class="number">1</span><span class="operator">~</span>并列数据<span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>具体用法和实现效果自行查询，此处不做说明</p></blockquote><h2 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h2><p>有一种特殊的箱线图，<strong>它结合了核密度图</strong>，形成了新的图形即小提琴图。</p><p>可以通过<code>vioplot</code>包中的<code>vioplot()</code>函数来绘制，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vioplot<span class="punctuation">(</span>x<span class="punctuation">,</span> use.cols <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小提琴图</span></span><br><span class="line">library<span class="punctuation">(</span>vioplot<span class="punctuation">)</span></span><br><span class="line">vioplot<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513200708708.png" alt="image-20220513200708708" style="zoom:50%;" /></p><blockquote><p>关于小提琴图的更多说明，请自行查询</p></blockquote><h1 id="点图"><a href="#点图" class="headerlink" title="点图"></a>点图</h1><p>点图顾名思义，在图中根据数据绘制大量的点，可以<strong>通过<code>dotchart()</code>函数来实现</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dotchart<span class="punctuation">(</span>x<span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> groups <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> gdata <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> offset <span class="operator">=</span> <span class="number">1</span><span class="operator">/</span><span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">         ann <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;ann&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> xaxt <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;xaxt&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> frame.plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="built_in">log</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">         cex <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;cex&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> pt.cex <span class="operator">=</span> cex<span class="punctuation">,</span></span><br><span class="line">         pch <span class="operator">=</span> <span class="number">21</span><span class="punctuation">,</span> gpch <span class="operator">=</span> <span class="number">21</span><span class="punctuation">,</span> bg <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;bg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         color <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> gcolor <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> lcolor <span class="operator">=</span> <span class="string">&quot;gray&quot;</span><span class="punctuation">,</span></span><br><span class="line">         xlim <span class="operator">=</span> <span class="built_in">range</span><span class="punctuation">(</span>x<span class="punctuation">[</span><span class="built_in">is.finite</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>labels</code>：用来指点每个点的标签</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点图</span></span><br><span class="line">dotchart<span class="punctuation">(</span>trees<span class="operator">$</span>Girth<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220513201323377.png" alt="image-20220513201323377" style="zoom:50%;" /></p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>关于 R 的基本图形如上所示，其更多的自定义参数可以查询官方文档，或者自行网络查询。</p>]]></content>
      
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-3.0】R-图形初阶</title>
      <link href="/2022/05/22/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-3-0%E3%80%91%E5%9B%BE%E5%BD%A2%E5%88%9D%E9%98%B6/"/>
      <url>/2022/05/22/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-3-0%E3%80%91%E5%9B%BE%E5%BD%A2%E5%88%9D%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>千呼万唤始出来，终于到了图形这部分，这部分主要说明如何创建和保存图形以及图形相关常用的参数使用。</p><h1 id="图形相关基础函数"><a href="#图形相关基础函数" class="headerlink" title="图形相关基础函数"></a>图形相关基础函数</h1><h2 id="使用图形"><a href="#使用图形" class="headerlink" title="使用图形"></a>使用图形</h2><p>首先，先在你的R上运行如下代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 1.jpg 的文件</span></span><br><span class="line">jpeg<span class="punctuation">(</span><span class="string">&#x27;1.jpg&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绑定trees数据</span></span><br><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 根据Height和Volume绘制点图形</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Volume<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 自定义图形标题</span></span><br><span class="line">title<span class="punctuation">(</span><span class="string">&quot;这是一个标题&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 解除绑定trees数据</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 返回输出结果</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行后会在当前工作目录下产生一个名称为<code>1.jpg</code>的图片，如下所示：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220507194124730.png" alt="image-20220507194124730" style="zoom: 50%;" /></p><p>这就是所生成的图形，利用的是<code>trees</code>数据所生成的图形。</p><h2 id="图形输出"><a href="#图形输出" class="headerlink" title="图形输出"></a>图形输出</h2><p>用于图形输出的函数如下所示：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>pdf(&#39;filename.pdf&#39;)</code></td><td>输出<code>PDF</code>文件</td></tr><tr><td><code>png(&#39;filename.png&#39;)</code></td><td>输出<code>PNG</code>文件</td></tr><tr><td><code>jpeg(&#39;filename.jpg/jpeg&#39;)</code></td><td>输出<code>JPG</code>文件</td></tr><tr><td><code>bmp(&#39;filename.bmp&#39;)</code></td><td>输出<code>BMP</code>文件</td></tr></tbody></table></div><p>需要注意的是<strong>使用上述函数输出图片后要使用<code>dev.off()</code>函数来完成文件输出</strong>。</p><blockquote><p>关于<code>JPG</code>和<code>JPEG</code>的区别可以参考我这篇文章<a href="https://www.helloseraphine.top/static/%E7%90%90%E7%A2%8E%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html">琐碎问题记录</a>。</p></blockquote><h1 id="图形参数"><a href="#图形参数" class="headerlink" title="图形参数"></a>图形参数</h1><p>我们可以通过修改图形的相关参数来实现我们想要的图形效果，例如图形颜色，图形样式等。</p><p><strong>修改图形参数的方式有两种，第一种是使用<code>par()</code>函数来修改全局参数，第二种是在定义图形的时候定义相关参数</strong>。关于<code>par()</code>函数的使用后续说明。</p><p>在前面的代码中，以及试验过了<code>plot()</code>函数的输出结果，即图形样式。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span>  xlim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     <span class="built_in">log</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> sub <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     ann <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;ann&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> frame.plot <span class="operator">=</span> axes<span class="punctuation">,</span></span><br><span class="line">     panel.first <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> panel.last <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> asp <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">     xgap.axis <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ygap.axis <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">     ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code></strong>：即<code>x</code>轴数据</li><li><strong><code>y</code></strong>：即<code>y</code>轴数据</li></ul><h2 id="符号和线条"><a href="#符号和线条" class="headerlink" title="符号和线条"></a>符号和线条</h2><p>可以通过设置以下参数来修改图形的符号和线条类型：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>pch</code></td><td>指定绘制点时使用的符号</td></tr><tr><td><code>cex</code></td><td>指定符号的大小。<code>cex</code>是数值型，默认大小为1，2表示放大2倍</td></tr><tr><td><code>lty</code></td><td>指定线条类型</td></tr><tr><td><code>lwd</code></td><td>指定线条宽度。默认值为1，同<code>cex</code></td></tr></tbody></table></div><p>关于<strong><code>pch</code>值对应的点符号样式</strong>如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220507202152075.png" alt="image-20220507202152075" style="zoom: 200%;" /></p><p>关于<code>lty</code>参数对应线条的类型样式如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220507202632041.png" alt="image-20220507202632041" style="zoom: 50%;" /></p><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>用于颜色指定的相关参数如下：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>col</code></td><td>设置绘图颜色。某些函数可以接受颜色值向量并自动循环使用。例如：<code>col=c(&#39;red&#39;,&#39;green)</code>则绘制的图线先红色后绿色，周而复始.</td></tr><tr><td><code>col.axis</code></td><td>坐标轴刻度文字的颜色</td></tr><tr><td><code>col.lab</code></td><td>坐标轴标签的颜色</td></tr><tr><td><code>col.main</code></td><td>标题颜色</td></tr><tr><td><code>col.sub</code></td><td>副标题颜色</td></tr><tr><td><code>fg</code></td><td>前景色（即图表框的颜色）</td></tr><tr><td><code>bg</code></td><td>背景色</td></tr></tbody></table></div><p>颜色的指定可以通过颜色索引，颜色名称，十六进制颜色值，RGB值或者HSV值来指定颜色。例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">col<span class="operator">=</span><span class="number">1</span></span><br><span class="line">col<span class="operator">=</span><span class="string">&#x27;white&#x27;</span></span><br><span class="line">col<span class="operator">=</span><span class="string">&#x27;#FFFFFF&#x27;</span></span><br><span class="line">col<span class="operator">=</span>rgb<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">col<span class="operator">=</span>hsv<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>图形参数同样可以用来指定字号，字体和字样等，参数如下所示：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>cex</code></td><td>表示绘图大小，默认为1</td></tr><tr><td><code>cex.axis</code></td><td>坐标轴刻度字体的大小，大小设置同上</td></tr><tr><td><code>cex.lab</code></td><td>坐标轴标签的大小，大小设置同上</td></tr><tr><td><code>cex.main</code></td><td>标题的大小，大小设置同上</td></tr><tr><td><code>cex.sub</code></td><td>副标题的大小，大小设置同上</td></tr><tr><td>——————-</td><td>———————————————————</td></tr><tr><td><code>font</code></td><td>接收整型参数，用于指定绘图字体样式。（1=常规，2=粗体，3=斜体，4=粗斜体，5=符号字体）</td></tr><tr><td><code>font.axis</code></td><td>坐标轴刻度字体样式，同上</td></tr><tr><td><code>font.lab</code></td><td>坐标轴标签字体样式，同上</td></tr><tr><td><code>font.main</code></td><td>标题字体样式，同上</td></tr><tr><td><code>font.sub</code></td><td>副标题字体样式，同上</td></tr><tr><td><code>ps</code></td><td>字体磅值（1磅 $\approx$ $\frac{1}{72}$ 英寸），文本最终大小=$ps \times cex$</td></tr><tr><td><code>family</code></td><td>绘制文本时使用的字体族。</td></tr></tbody></table></div><h1 id="添加文本，自定义坐标轴和图例"><a href="#添加文本，自定义坐标轴和图例" class="headerlink" title="添加文本，自定义坐标轴和图例"></a>添加文本，自定义坐标轴和图例</h1><h2 id="图形尺寸于边界尺寸"><a href="#图形尺寸于边界尺寸" class="headerlink" title="图形尺寸于边界尺寸"></a>图形尺寸于边界尺寸</h2><p>同样的可以通过参数来控制生成图形的尺寸，如下所示：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>pin</code></td><td>以英寸表示图形的尺寸（宽和高）</td></tr><tr><td><code>mai</code></td><td>以数值向量表示边界的大小，顺序是下，左，上，右，单位为英寸</td></tr><tr><td><code>mar</code></td><td>以数值向量表示边界大小，顺序同上，单位是英分</td></tr></tbody></table></div><blockquote><p>1英寸=2.54厘米，1英分= $\frac{1}{12}$ 英寸</p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>需要高级绘图函数（例如<code>plot</code>，<code>hist</code>，<code>boxplot</code>）允许设定更多的自定义内容，例如标题，图例等。</p><blockquote><p>某些高级绘图函数默认包含了标题和标签，可以<strong>通过设置<code>ann=FLASE</code>来移除它们</strong></p></blockquote><p>可以使用<code>title()</code>函数为图形添加标题和坐标轴标签，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title<span class="punctuation">(</span>main <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> sub <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">      line <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>NA是Not Available的缩写，是一种占位符，可以理解为值=NA，但是不存在</p></blockquote><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title<span class="punctuation">(</span>main <span class="operator">=</span> <span class="string">&#x27;这是主标题&#x27;</span><span class="punctuation">,</span>sub <span class="operator">=</span> <span class="string">&#x27;这是副标题&#x27;</span><span class="punctuation">,</span>xlab <span class="operator">=</span> <span class="string">&#x27;这是横坐标标签&#x27;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&#x27;这是纵坐标标签&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h2><p>可以<strong>使用函数<code>axis()</code>来创建自定义坐标轴</strong>。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axis<span class="punctuation">(</span>side<span class="punctuation">,</span> at <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> tick <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> line <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">     pos <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> font <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> lty <span class="operator">=</span> <span class="string">&quot;solid&quot;</span><span class="punctuation">,</span></span><br><span class="line">     lwd <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> lwd.ticks <span class="operator">=</span> lwd<span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> col.ticks <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     hadj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> padj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> gap.axis <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>参数说明如下：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>side</code></td><td>整型，表示在图形哪边绘制坐标轴（1=下，2=左，3=上，4=右）</td></tr><tr><td><code>at</code></td><td>数值型向量，表示需要绘制刻度线的位置</td></tr><tr><td><code>labels</code></td><td>字符型向量，表示置于刻度线旁边的文字标签（如果为<code>NULL</code>则直接使用<code>at</code>中的值）</td></tr><tr><td><code>pos</code></td><td>坐标轴线绘制位置的坐标（即与另一条坐标轴相交的位置）</td></tr><tr><td><code>lty</code></td><td>线条类型</td></tr><tr><td><code>col</code></td><td>线条和刻度线的颜色</td></tr><tr><td><code>las</code></td><td>标签是否平行(=0)或者垂直于(=2)坐标轴</td></tr><tr><td><code>tck</code></td><td>刻度线的长度，以相对于绘图区域大小的分数表示（负值表示在图形外侧，正值表示在图形内侧，0表示禁用刻度，1表示绘制网格线）；默认值为 $-0.01$</td></tr></tbody></table></div><p>创建自定义坐标轴时，应该禁用高级绘图函数自动生成的坐标轴。</p><ul><li><strong>参数<code>axes=FLASE</code>将禁用全部坐标轴（包括坐标轴框架线）</strong></li><li><strong>参数<code>xaxt=&#39;n&#39;</code>和<code>yaxt=&#39;n&#39;</code>将分别禁用 X 轴或者 Y 轴（会留下框架线，只是去除了刻度）</strong></li></ul><p>现在运行如下代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">&lt;-</span> x</span><br><span class="line">z <span class="operator">&lt;-</span> 10<span class="operator">/</span>x</span><br><span class="line"></span><br><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定图形边界</span></span><br><span class="line">par<span class="punctuation">(</span>mar<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">)</span><span class="operator">+</span><span class="number">0.1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制红色直线</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span>y<span class="punctuation">,</span>type <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="number">21</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span>yaxt<span class="operator">=</span><span class="string">&#x27;n&#x27;</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>ann<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制蓝色曲线</span></span><br><span class="line">lines<span class="punctuation">(</span>x<span class="punctuation">,</span>z<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;b&#x27;</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="number">22</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制左侧Y轴刻度线</span></span><br><span class="line">axis<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span>at<span class="operator">=</span>x<span class="punctuation">,</span>labels <span class="operator">=</span> x<span class="punctuation">,</span>col.axis<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span>las<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制右侧Y轴刻度线</span></span><br><span class="line">axis<span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span>at<span class="operator">=</span>z<span class="punctuation">,</span>labels <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>z<span class="punctuation">,</span>digits <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span>col.axis<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">,</span>las<span class="operator">=</span><span class="number">2</span></span><br><span class="line">     <span class="punctuation">,</span>cex.axis<span class="operator">=</span><span class="number">0.7</span><span class="punctuation">,</span>tck<span class="operator">=</span><span class="operator">-</span><span class="number">.01</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加右侧标题</span></span><br><span class="line">mtext<span class="punctuation">(</span><span class="string">&#x27;y=1/x&#x27;</span><span class="punctuation">,</span>side<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>line<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>cex.lab<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>las<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加横纵坐标标题</span></span><br><span class="line">title<span class="punctuation">(</span><span class="string">&#x27;这是一个样图&#x27;</span><span class="punctuation">,</span>xlab <span class="operator">=</span> <span class="string">&#x27;这是横坐标&#x27;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&#x27;这是纵坐标&#x27;</span><span class="punctuation">,</span>line <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行结果生成的图形如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220508105802075.png" alt="image-20220508105802075" style="zoom: 50%;" /></p><p>关于上述语法解释，<strong><code>line()</code>函数是绘制图线</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> iter <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>其中参数<code>type</code>的值以及功能如下：</p><div class="table-container"><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td><code>type=&#39;p&#39;</code></td><td>表示绘制点</td></tr><tr><td><code>type=&#39;l&#39;</code></td><td>表示绘制线</td></tr><tr><td><code>type=&#39;b&#39;</code></td><td>表示绘制点和线</td></tr><tr><td><code>type=&#39;c&#39;</code></td><td>表示曲线连接的空点</td></tr><tr><td><code>type=&#39;s&#39;</code>或者<code>type=&#39;S&#39;</code></td><td>表示阶梯状线</td></tr><tr><td><code>type=&#39;h&#39;</code></td><td>表示直方图状垂直线</td></tr><tr><td><code>type=&#39;n&#39;</code></td><td>表示不产生任何点或者线</td></tr></tbody></table></div><p><strong><code>round()</code>函数是进行四舍五入的函数</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>x<span class="punctuation">,</span> digits <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>x</code>：需要处理的数据</strong></li><li><strong><code>digits</code>：要使用的小数位数或者有效数字的数目</strong></li></ul><p><strong><code>mtext</code>函数是将文本写在图形区域的是个边距的周围</strong>。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mtext<span class="punctuation">(</span>text<span class="punctuation">,</span> side <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> line <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> at <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">      adj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> padj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> font <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>相关参数说明如下：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>text</code></td><td>标题内容</td></tr><tr><td><code>side</code></td><td>文本在坐标轴边框的位置（1=下，2=左，3=上，4=右）</td></tr><tr><td><code>line</code></td><td>距离坐标轴边框的距离，值越大越远</td></tr><tr><td><code>las</code></td><td>文字是否平行(=0)或者垂直于(=2)坐标轴</td></tr></tbody></table></div><h2 id="次要刻度线"><a href="#次要刻度线" class="headerlink" title="次要刻度线"></a>次要刻度线</h2><p>如上创建的图形都只拥有主刻度线，没有次刻度线。想要<strong>创建次刻度线，需要使用<code>Hmisc</code>宏包的<code>minor.tick()</code>函数。</strong><code>minor.tick()</code>函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minor.tick<span class="punctuation">(</span>nx<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> ny<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> tick.ratio<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">,</span> x.args <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> y.args <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>nx</code>：指在X轴分割的区域，2即次刻度线将每个区间分为两个区域</strong></li><li><strong><code>ny</code>：指在Y轴分割的区域，同上</strong></li><li><strong><code>tick.ratio</code>：表示次刻度相对于主刻度线的大小比例</strong></li></ul><h2 id="参考线"><a href="#参考线" class="headerlink" title="参考线"></a>参考线</h2><p><strong>函数<code>abline()</code>可以用来为图形添加参考线</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abline<span class="punctuation">(</span>a <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> b <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> h <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> v <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> reg <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">       coef <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> untf <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>h</code>：Y 轴的参考线</strong></li><li><strong><code>v</code>：X 轴的参考线</strong></li></ul><p>代码实例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在垂直 3 坐标和水平 2 坐标，用虚线话画出红色的参考线</span></span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>v<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p>当图形中存在多个数据的时候，使用图例可以帮助读者快速区分数据曲线。</p><p>可以<strong>使用函数<code>legend()</code>来添加图例。</strong>函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">legend<span class="punctuation">(</span>x<span class="punctuation">,</span> y <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> legend<span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> col <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;col&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       border <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> lty<span class="punctuation">,</span> lwd<span class="punctuation">,</span> pch<span class="punctuation">,</span></span><br><span class="line">       angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> bty <span class="operator">=</span> <span class="string">&quot;o&quot;</span><span class="punctuation">,</span> bg <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;bg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       box.lwd <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;lwd&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> box.lty <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;lty&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> box.col <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;fg&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       pt.bg <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> pt.cex <span class="operator">=</span> cex<span class="punctuation">,</span> pt.lwd <span class="operator">=</span> lwd<span class="punctuation">,</span></span><br><span class="line">       xjust <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> yjust <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> x.intersp <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> y.intersp <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       adj <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> text.width <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> text.col <span class="operator">=</span> par<span class="punctuation">(</span><span class="string">&quot;col&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       text.font <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> merge <span class="operator">=</span> do.lines <span class="operator">&amp;&amp;</span> has.pch<span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">       plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> horiz <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> title <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">       inset <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> xpd<span class="punctuation">,</span> title.col <span class="operator">=</span> text.col<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> title.adj <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">       title.cex <span class="operator">=</span> cex<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> title.font <span class="operator">=</span> text.font<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       seg.len <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>参数说明如下：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>location</code></td><td>有两种定位图例位置的方法，第一种是通过指定 X，Y 的值来指定图例的位置（以图例左上角为顶点），第二种方式是通过指定关键字，<code>&quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;</code>，如果使用关键字指定位置，可以通过<code>inset</code>参数来调整其距离边框的位置。</td></tr><tr><td><code>title</code></td><td>图例的标题</td></tr></tbody></table></div><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">legend<span class="punctuation">(</span><span class="string">&quot;topleft&quot;</span><span class="punctuation">,</span>title <span class="operator">=</span> <span class="string">&#x27;图例标题&#x27;</span><span class="punctuation">,</span>inset <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;B&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220508191935662.png" alt="image-20220508191935662" style="zoom:50%;" /></p><h2 id="文本标注"><a href="#文本标注" class="headerlink" title="文本标注"></a>文本标注</h2><p>可以<strong>通过函数<code>text()</code>和<code>mtext()</code>将文本添加到图形，<code>text()</code>可以向绘图区域内添加文字，而<code>mtext()</code>是向绘图区域四周添加文字</strong>。函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mtext</span></span><br><span class="line">mtext<span class="punctuation">(</span>text<span class="punctuation">,</span> side <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> line <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> outer <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> at <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">      adj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> padj <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> font <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># text</span></span><br><span class="line">text<span class="punctuation">(</span>x<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><code>mtext</code>函数已经在坐标轴部分说明了，<code>text</code>的相关参数说明如下;</p><ul><li><strong><code>x</code>：指定 X 轴的位置</strong></li><li><strong><code>y</code>：指定 Y 轴的位置</strong></li><li><strong><code>label</code>：标注内容</strong></li><li><strong><code>pos</code>：标准内容和点的偏移量</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">b <span class="operator">&lt;-</span> 1<span class="operator">/</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>a<span class="punctuation">,</span>b<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加坐标的文字</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="string">&#x27;这是第一个数据&#x27;</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">,</span><span class="string">&#x27;这是第二个数据&#x27;</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">3</span><span class="punctuation">,</span><span class="string">&#x27;这是第三个数据&#x27;</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220508193453179.png" alt="image-20220508193453179" style="zoom:50%;" /></p><h3 id="数学标注"><a href="#数学标注" class="headerlink" title="数学标注"></a>数学标注</h3><p>同样的，你也可以<strong>使用类似于<code>Tex</code>中的写法为图形添加数学符号和公式</strong>。<strong>可以利用<code>plotmath()</code>函数来实现</strong>，如果你希望看到即时效果，可以尝试运行<code>demo(plotmath)</code>来查看。</p><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 expression() 来呈现数学公式</span></span><br><span class="line">text<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">,</span>labels<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>frac<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>pos<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>关于<code>Tex</code>/<code>LaTex</code>用法说明，可以看我这篇文章<a href="https://www.helloseraphine.top/index.php/archives/514.html">LaTex基础（上）</a></p></blockquote><h1 id="图形的组合"><a href="#图形的组合" class="headerlink" title="图形的组合"></a>图形的组合</h1><p><strong>在R中使用函数<code>par()</code>或者<code>layout()</code>可以组合多幅图形为一幅总括图</strong>。</p><p>可以通过<strong>在<code>par()</code>函数中使用图形参数<code>mfrow=c(nrows,ncols)</code>来创建按行填充的图形矩阵</strong>，或者可以使用<strong><code>nfcol=c(nrows,ncols)</code>来按列填充矩阵</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绑定数据源</span></span><br><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 获取初始图形参数</span></span><br><span class="line">opar <span class="operator">&lt;-</span> par<span class="punctuation">(</span>no.readonly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 设置两行两列</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Volume<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第一个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Girth<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第二个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Height<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第三个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>Height<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;第四个图&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 设置图形参数</span></span><br><span class="line">par<span class="punctuation">(</span>opar<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 解绑数据源</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220509101320519.png" alt="image-20220509101320519" style="zoom:50%;" /></p><p>接下来尝试<strong>使用<code>layout（）</code>函数绘制组合图形</strong>，其函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout<span class="punctuation">(</span>mat<span class="punctuation">,</span> widths <span class="operator">=</span> rep.int<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> ncol<span class="punctuation">(</span>mat<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       heights <span class="operator">=</span> rep.int<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow<span class="punctuation">(</span>mat<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> respect <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>mat</code>：矩阵类型参数，四个参数表示四个位置</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line">layout<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span>byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Height<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Volume<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Girth<span class="punctuation">)</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220509102709140.png" alt="image-20220509102709140" style="zoom:50%;" /></p><p>为了<strong>更精细的控制每幅图的大小</strong>，可以有选择性的在<code>layout()</code>函数中<strong>使用<code>heights</code>和<code>widths</code>两个参数</strong>。</p><ul><li><strong><code>widths</code>和<code>heights</code>：两个函数都接收一个向量参数</strong>，是一种比例</li></ul><p><strong>相对高度可以通过数值来指定，绝对高度通过函数<code>lcm()</code>来指定</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line">layout<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span>byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">       <span class="punctuation">,</span>widths <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>heights <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Height<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Volume<span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>Girth<span class="punctuation">)</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220509103823858.png" alt="image-20220509103823858" style="zoom:50%;" /></p><h2 id="图形的精细化控制"><a href="#图形的精细化控制" class="headerlink" title="图形的精细化控制"></a>图形的精细化控制</h2><p>在某些情况下，你可能希望通过多个图形叠加来形成其他图形，这个时候就需要<strong>使用<code>fig</code>参数来实现</strong>。代码示例如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">attach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>fig<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Height<span class="punctuation">,</span>Volume<span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>fig<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">,</span><span class="number">0.5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>new<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>Height<span class="punctuation">,</span>horizontal <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>axes<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>fig<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.65</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">,</span>new<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>Volume<span class="punctuation">,</span>axes<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">detach<span class="punctuation">(</span>trees<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>new=TRUE</code>：意思是绘制图形的时候不清楚原图像，而是继续叠加绘图</strong></li></ul><p>运行效果如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220509105257431.png" alt="image-20220509105257431" style="zoom:50%;" /></p><p><strong><code>fig</code>参数接收一个四参数的向量，它表示的是相对位置，其参数类型为<code>fig=c(x1,x2,y1,y2)</code></strong>，代码<code>par(fig=c(0,0.8,0,0.8))</code>的意思是规定图形的绘制范围为：横向从 0 到 0.8 这个比例范围内，纵向 0 到 0.8 这个比例范围内。</p><blockquote><p>如果你在绘图过程中报错<code>figure margins too large</code>，则说明绘图已经超出绘图设备区域，适当缩小绘图区域即可。</p></blockquote><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这部分初步理解和利用图形相关参数来实现一些基本的自定义图形。</p>]]></content>
      
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NEW-2.0】R-创建数据集</title>
      <link href="/2022/05/22/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-2-0%E3%80%91%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>/2022/05/22/R%E8%AF%AD%E8%A8%80/%E3%80%90NEW-2-0%E3%80%91%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="数据集的概念"><a href="#数据集的概念" class="headerlink" title="数据集的概念"></a>数据集的概念</h1><p>数据集是由数据构成的矩形数组，行表示观测（记录），列表示变量（字段）。</p><p><code>R</code>有许多用于<strong>存储数据的结构，包括标量，向量，数组，数据框和列表</strong>。</p><p><code>R</code>可以处理的<strong>数据类型包括数值型，字符型，逻辑型，复数型和原生型</strong>。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><strong>向量是用于存储数据的一维数组</strong>。</p><h3 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a>创建向量</h3><p><strong>利用<code>c()</code>可以用来创建向量</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;你好&quot;</span><span class="punctuation">,</span><span class="string">&quot;世界&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>注：单个向量之内的数据类型需要相同。<strong>一个向量不可以混合多种数据类型</strong></p></blockquote><h3 id="访问向量元素"><a href="#访问向量元素" class="headerlink" title="访问向量元素"></a>访问向量元素</h3><p>通过<strong>指定向量中元素的位置来访问元素</strong>，例如：</p><ul><li><code>a[c(1)]</code>来表示指定访问向量<code>a</code>中第一个元素。</li><li><code>a[c(1，3)]</code>来表示指定访问向量<code>a</code>中第一个和第三个元素。</li><li><code>a[c(1:3)]</code>来表示访问向量<code>a</code>中第一个到第三个元素。</li></ul><p>【从<code>C</code>和<code>C#</code>角度看】</p><ul><li>向量就是规定类型的一维数组，通过函数<code>c(数据内容，间隔采用,号)</code>来创建。</li><li>访问数组中元素通过下标来访问，使用函数<code>向量变量[c(下标位置)]</code></li></ul><blockquote><p>需要注意的是：<strong><code>R</code>语言的数字是从1开始的，而不是0.</strong></p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><strong>矩阵是一个二维数组。</strong></p><h3 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h3><p><strong>通过函数<code>matrix</code>来创建</strong>。函数源码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="punctuation">(</span>data <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> <span class="built_in">dimnames</span> <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">)</span> </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span><span class="built_in">is.object</span><span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="operator">||</span> <span class="operator">!</span><span class="built_in">is.atomic</span><span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">    data <span class="operator">&lt;-</span> as.vector<span class="punctuation">(</span>data<span class="punctuation">)</span></span><br><span class="line">  .Internal<span class="punctuation">(</span>matrix<span class="punctuation">(</span>data<span class="punctuation">,</span> nrow<span class="punctuation">,</span> ncol<span class="punctuation">,</span> byrow<span class="punctuation">,</span> <span class="built_in">dimnames</span><span class="punctuation">,</span> <span class="built_in">missing</span><span class="punctuation">(</span>nrow<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="built_in">missing</span><span class="punctuation">(</span>ncol<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>data：二维数组数据内容</strong></li><li><strong>nrow：（数值）行数，默认<code>1</code></strong></li><li><strong>ncol：（数值）列数，默认<code>1</code></strong></li><li><strong>byrow：（布尔）填充数值是从列开始还是从行开始，<code>FLASE</code>默认值，表示从列开始填充</strong></li><li><strong>dimnames：（两个参数的<code>list</code>）行列名称重命名，默认<code>NULL</code></strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按列填充</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line">     <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">1</span>    <span class="number">5</span>    <span class="number">9</span>   <span class="number">13</span>   <span class="number">17</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">2</span>    <span class="number">6</span>   <span class="number">10</span>   <span class="number">14</span>   <span class="number">18</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">3</span>    <span class="number">7</span>   <span class="number">11</span>   <span class="number">15</span>   <span class="number">19</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">4</span>    <span class="number">8</span>   <span class="number">12</span>   <span class="number">16</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按行填充</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line">     <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span>   <span class="number">11</span>   <span class="number">12</span>   <span class="number">13</span>   <span class="number">14</span>   <span class="number">15</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="punctuation">]</span>   <span class="number">16</span>   <span class="number">17</span>   <span class="number">18</span>   <span class="number">19</span>   <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按行填充,并重命名</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一行&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> cname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一列&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第五列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="built_in">list</span><span class="punctuation">(</span>rname<span class="punctuation">,</span>cname<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line">       第一列 第二列 第三列 第四列 第五列</span><br><span class="line">第一行      <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line">第二行      <span class="number">6</span>      <span class="number">7</span>      <span class="number">8</span>      <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">第三行     <span class="number">11</span>     <span class="number">12</span>     <span class="number">13</span>     <span class="number">14</span>     <span class="number">15</span></span><br><span class="line">第四行     <span class="number">16</span>     <span class="number">17</span>     <span class="number">18</span>     <span class="number">19</span>     <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="访问矩阵元素"><a href="#访问矩阵元素" class="headerlink" title="访问矩阵元素"></a>访问矩阵元素</h3><p>同理也是<strong>通过矩阵下标来表示位置</strong>，<code>矩阵名称[x,y]</code>，<code>x</code>表示行数，<code>y</code>表示列数。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个矩阵,按行填充,并重命名</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一行&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> cname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;第一列&quot;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第五列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="built_in">list</span><span class="punctuation">(</span>rname<span class="punctuation">,</span>cname<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第二行元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">第一列 第二列 第三列 第四列 第五列 </span><br><span class="line">     <span class="number">6</span>      <span class="number">7</span>      <span class="number">8</span>      <span class="number">9</span>     <span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第二行第三个元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第二行第三，四个元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">第三列 第四列 </span><br><span class="line">     <span class="number">8</span>      <span class="number">9</span> </span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">第三列 第四列 </span><br><span class="line">     <span class="number">8</span>      <span class="number">9</span> </span><br></pre></td></tr></table></figure><p>【从<code>C</code>和<code>C#</code>角度看】</p><ul><li>矩阵是已经嵌套好的二维数组，更加偏向于数学上的线性代数。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是矩阵的加强版，它的<strong>维度可以大于2</strong>。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>通过<strong>函数<code>array</code>创建</strong>，函数原型示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array<span class="punctuation">(</span>data <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> <span class="built_in">dim</span> <span class="operator">=</span> <span class="built_in">length</span><span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">dimnames</span> <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong>data：数组的数据</strong></li><li><strong>dim：数组的长度，<code>c(行数,列数,维度)</code></strong></li><li><strong>dimnames：(<code>List</code>类型)数组行列维度名称</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个一维数组</span></span><br><span class="line"><span class="operator">&gt;</span> name1 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> name2 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二列&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三列&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> name3 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一层&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二层&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三层&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第四层&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">24</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span> <span class="operator">&lt;-</span> array<span class="punctuation">(</span>a<span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">list</span><span class="punctuation">(</span>name1<span class="punctuation">,</span>name2<span class="punctuation">,</span>name3<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第一层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行      <span class="number">1</span>      <span class="number">3</span>      <span class="number">5</span></span><br><span class="line">第二列      <span class="number">2</span>      <span class="number">4</span>      <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第二层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行      <span class="number">7</span>      <span class="number">9</span>     <span class="number">11</span></span><br><span class="line">第二列      <span class="number">8</span>     <span class="number">10</span>     <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第三层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行     <span class="number">13</span>     <span class="number">15</span>     <span class="number">17</span></span><br><span class="line">第二列     <span class="number">14</span>     <span class="number">16</span>     <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">,</span> <span class="punctuation">,</span> 第四层</span><br><span class="line"></span><br><span class="line">       第一列 第二列 第三列</span><br><span class="line">第一行     <span class="number">19</span>     <span class="number">21</span>     <span class="number">23</span></span><br><span class="line">第二列     <span class="number">20</span>     <span class="number">22</span>     <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h3><p>同上，使用元素位置来访问，代码示例</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个一维数组</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">24</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span> <span class="operator">&lt;-</span> array<span class="punctuation">(</span>a<span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问数组第二层第二行第二列元素</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p>数据框类似于Excel，是一种键值对的格式，它可以<strong>混合使用多种数据类型</strong>。</p><h3 id="创建数据框"><a href="#创建数据框" class="headerlink" title="创建数据框"></a>创建数据框</h3><p>通过<strong>使用函数<code>data.frame()</code></strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.frame<span class="punctuation">(</span>...<span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> check.rows <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">           check.names <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fix.empty.names <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">           stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong>…：数据内容</strong></li><li><strong>row.names：行名称</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个数据框</span></span><br><span class="line"><span class="operator">&gt;</span> name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;小明&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> classNum <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;林学一班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学二班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学三班&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="punctuation">,</span>classNum<span class="punctuation">,</span>row.names <span class="operator">=</span> rname<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a</span><br><span class="line">       name classNum</span><br><span class="line">第一行 小明 林学一班</span><br><span class="line">第二行 小亮 林学二班</span><br><span class="line">第三行 小亮 林学三班</span><br></pre></td></tr></table></figure><h3 id="数据框元素的访问"><a href="#数据框元素的访问" class="headerlink" title="数据框元素的访问"></a>数据框元素的访问</h3><p>可以通过元素位置索引来访问，<strong><code>数据框名称[第几列]</code>，表示访问第几列元素。<code>数据框名称[第几行,第几列]</code>或者</strong>如果想要表现其中两个数据关系，可以通过<code>table(数据框名称$列/行名称)</code>来实现。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个数据框</span></span><br><span class="line"><span class="operator">&gt;</span> name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;小明&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> classNum <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;林学一班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学二班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学三班&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="punctuation">,</span>classNum<span class="punctuation">,</span>row.names <span class="operator">=</span> rname<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第一列数据</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">       name</span><br><span class="line">第一行 小明</span><br><span class="line">第二行 小亮</span><br><span class="line">第三行 小亮</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问第一行第1,2个数据</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">       name classNum</span><br><span class="line">第一行 小明 林学一班</span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 获取行列数据的关系</span></span><br><span class="line"><span class="operator">&gt;</span> table<span class="punctuation">(</span>a<span class="operator">$</span>classNum<span class="punctuation">,</span>a<span class="operator">$</span>name<span class="punctuation">)</span></span><br><span class="line">          </span><br><span class="line">           小亮 小明</span><br><span class="line">  林学二班    <span class="number">1</span>    <span class="number">0</span></span><br><span class="line">  林学三班    <span class="number">1</span>    <span class="number">0</span></span><br><span class="line">  林学一班    <span class="number">0</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在每次访问变量元素的时候，都需要输入<code>数据框名称$列/行名称</code>，会比较繁琐，可以通过<strong>使用函数<code>attach()</code>和<code>detach()</code>或者单独使用函数<code>with()</code>来简化代码</strong>。</p><p><strong>或者使用<code>$</code>来访问元素</strong>。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 创建一个数据框</span></span><br><span class="line"><span class="operator">&gt;</span> name <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;小明&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;小亮&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> classNum <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;林学一班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学二班&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;林学三班&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> rname <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="punctuation">,</span>classNum<span class="punctuation">,</span>row.names <span class="operator">=</span> rname<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问name列</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="operator">$</span>name</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;小明&quot;</span> <span class="string">&quot;小亮&quot;</span> <span class="string">&quot;小亮&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 访问name列的第二个元素</span></span><br><span class="line"><span class="operator">&gt;</span> a<span class="operator">$</span>name<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;小亮&quot;</span></span><br></pre></td></tr></table></figure><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>暂欠</p><p>通过函数<code>factor</code>来创建.</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>列表也是一种一维数组，它可以嵌套多种数据类型</strong>。</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>使用函数<code>list()</code>来创建，函数原型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span><span class="punctuation">(</span>...<span class="punctuation">)</span>;</span><br></pre></td></tr></table></figure><p>当然你也可以给列表中的参数命名，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(name1=object1,....)</span><br></pre></td></tr></table></figure><h1 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h1><p><code>R</code>可以从键盘，文本文件，Excel和Access，流行的统计软件，特殊格式的文件以及多种关系数据库导入数据。</p><blockquote><p>关于向R中导入数据的权威指南参见<a href="https://cran.r-project.org/doc/manuals/R-data.pdf">R Data Import/Export手册</a></p></blockquote><h2 id="使用键盘输入数据"><a href="#使用键盘输入数据" class="headerlink" title="使用键盘输入数据"></a>使用键盘输入数据</h2><p><strong>使用<code>edit()</code>函数调用产生一个输入数据的文本框，输入数据</strong>即可完成键入数据。代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个数据框</span></span><br><span class="line">a <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name<span class="operator">=</span>character<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>classNum<span class="operator">=</span>character<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>Num<span class="operator">=</span>numeric<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 键入数据框内容</span></span><br><span class="line">a <span class="operator">&lt;-</span> edit<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 打印数据框内容</span></span><br><span class="line">print<span class="punctuation">(</span>a<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>弹出输入数据的文本框样式：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220505211928183.png" alt="image-20220505211928183" style="zoom:80%;" /></p><blockquote><p><code>character(0)</code>是空字符型创建，<code>numeric(0)</code>是空数值型，<code>logical(0)</code>是空逻辑型</p></blockquote><h2 id="从带分隔符的文本文件导入数据"><a href="#从带分隔符的文本文件导入数据" class="headerlink" title="从带分隔符的文本文件导入数据"></a>从带分隔符的文本文件导入数据</h2><p>即从常规的<code>TXT</code>文本中读取数据，需要注意的是<strong>该文件需要是<code>ASCII</code>编码的文件</strong>。</p><blockquote><p>关于如何查看<code>TXT</code>文件是否是<code>ASCII</code>编码以及如何转换成<code>ASCII</code>编码的文件请自行百度</p></blockquote><p><strong>读取需要使用<code>read.table()</code>函数</strong>，函数原型如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">read.table<span class="punctuation">(</span>file<span class="punctuation">,</span> header <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="built_in">quote</span> <span class="operator">=</span> <span class="string">&quot;\&quot;&#x27;&quot;</span><span class="punctuation">,</span></span><br><span class="line">           dec <span class="operator">=</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> numerals <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;allow.loss&quot;</span><span class="punctuation">,</span> <span class="string">&quot;warn.loss&quot;</span><span class="punctuation">,</span> <span class="string">&quot;no.loss&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">           row.names<span class="punctuation">,</span> col.names<span class="punctuation">,</span> as.is <span class="operator">=</span> <span class="operator">!</span>stringsAsFactors<span class="punctuation">,</span></span><br><span class="line">           na.strings <span class="operator">=</span> <span class="string">&quot;NA&quot;</span><span class="punctuation">,</span> colClasses <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> nrows <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">           skip <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> check.names <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="operator">!</span>blank.lines.skip<span class="punctuation">,</span></span><br><span class="line">           strip.white <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> blank.lines.skip <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">           comment.char <span class="operator">=</span> <span class="string">&quot;#&quot;</span><span class="punctuation">,</span></span><br><span class="line">           allowEscapes <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> flush <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">           stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">           fileEncoding <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> encoding <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span> text<span class="punctuation">,</span> skipNul <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>file</code>：即文件路径</strong></li><li><strong><code>header</code>：（布尔值）即文件开头的是否是变量而不是数据</strong></li><li><strong><code>sep</code>：自定义数据分隔符，默认为空格</strong></li><li><strong><code>row.names</code>：自定义行名称</strong></li><li><strong><code>col.names</code>：自定义列名称</strong></li></ul><blockquote><p>文件路径<strong>如果提供的是相对路径，则需要将文件放在工作目录下</strong>，如果是绝对路径则不需要，<strong>绝对路径使用正斜杠</strong>。</p></blockquote><p>文本文件内容如下，第一行为列名称，数据通过<code>|</code>分割。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|班级</span><br><span class="line">小明|林学一班</span><br><span class="line">小张|林学二班</span><br><span class="line">小亮|林学三班</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是在Win中，<code>TXT</code>文件最后需要以回车结尾，至于为什么可以参考<a href="https://zhuanlan.zhihu.com/p/380574688">CRLF和LF的差异</a></p></blockquote><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文本文件内容</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;D:/DATA/R/test.txt&#x27;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&#x27;|&#x27;</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;第一行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第二行&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;第三行&#x27;</span><span class="punctuation">)</span>  <span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> a</span><br><span class="line">       姓名     班级</span><br><span class="line">第一行 小明 林学一班</span><br><span class="line">第二行 小张 林学二班</span><br><span class="line">第三行 小亮 林学三班</span><br></pre></td></tr></table></figure><h2 id="导入Excel数据"><a href="#导入Excel数据" class="headerlink" title="导入Excel数据"></a>导入Excel数据</h2><p><strong>读取Excel最好的方式是将Excel导出为<code>csv</code>文件（逗号分隔文件），然后使用前面的读取文本来读取</strong>。</p><h3 id="使用R包读取Excel数据"><a href="#使用R包读取Excel数据" class="headerlink" title="使用R包读取Excel数据"></a>使用R包读取Excel数据</h3><p>在Windows系统中，可以<strong>使用<code>RODBC</code>包来访问Excel文件。电子表格第一行应当包含变量/列的名称</strong>。</p><p>首先，<strong>下载安装<code>RODBC</code>包</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;RODBC&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>使用该包读取Excel文件，Excel文件内容如下：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名     班级 学号</span><br><span class="line">小明 林学一班  <span class="number">123</span></span><br><span class="line">小亮 林学二班  <span class="number">321</span></span><br><span class="line">小张 林学三班  <span class="number">345</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 载入RODBC包</span></span><br><span class="line">library<span class="punctuation">(</span>RODBC<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 打开链接</span></span><br><span class="line">A <span class="operator">&lt;-</span> odbcConnectExcel2007<span class="punctuation">(</span><span class="string">&#x27;test.xlsx&#x27;</span><span class="punctuation">)</span> <span class="comment"># 注：如果你的电脑是32位的使用方法odbcConnectExcel(&#x27;test.xlsx&#x27;)</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">a <span class="operator">&lt;-</span> sqlFetch<span class="punctuation">(</span>A<span class="punctuation">,</span><span class="string">&#x27;Sheet1&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 关闭链接</span></span><br><span class="line">odbcClose<span class="punctuation">(</span>A<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 输出数据</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">  姓名     班级 学号</span><br><span class="line"><span class="number">1</span> 小明 林学一班  <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 小亮 林学二班  <span class="number">321</span></span><br><span class="line"><span class="number">3</span> 小张 林学三班  <span class="number">345</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>A &lt;- odbcConnectExcel2007(&#39;test.xlsx&#39;)</code>：A是打开Excel的一个链接通路，传入参数为Excel文件路径</strong></li><li><strong><code>a &lt;- sqlFetch(A,&#39;Sheet1&#39;)</code>：第一个参数传入打开的通路，第二个参数是表示第几个表</strong></li></ul><blockquote><p>如果你在<code>library(RODBC)</code>的时候报需要更高版本R的支持，可以选择手动导入旧版本包或者更新R版本</p></blockquote><p>当然，如果觉得上述繁琐，<strong>有一个最简单的方法，使用<code>xlsx</code>宏包中的 <code>read.xlsx()</code>函数</strong>。函数原型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">read.xlsx<span class="punctuation">(</span></span><br><span class="line">  file<span class="punctuation">,</span></span><br><span class="line">  sheetIndex<span class="punctuation">,</span></span><br><span class="line">  sheetName <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  rowIndex <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  startRow <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  endRow <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  colIndex <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  as.data.frame <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  colClasses <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  keepFormulas <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">  encoding <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span><span class="punctuation">,</span></span><br><span class="line">  password <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>file</code>：文件路径</strong></li><li><strong><code>sheetIndex</code>：文件中第几个表的索引</strong></li></ul><p>代码示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>xlsx<span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> read.xlsx<span class="punctuation">(</span><span class="string">&#x27;test.xlsx&#x27;</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="从剪切板上读取Excel数据"><a href="#从剪切板上读取Excel数据" class="headerlink" title="从剪切板上读取Excel数据"></a>从剪切板上读取Excel数据</h3><p>通过将要输入的内容复制到剪切板，然后读取剪切板的内容来输入数据。</p><p><strong>通过<code>read.delim(&#39;clipboard&#39;)</code>函数来实现</strong>。</p><blockquote><p>在运行该函数之前，务必先复制正确的数据内容</p></blockquote><h2 id="从网页抓取数据"><a href="#从网页抓取数据" class="headerlink" title="从网页抓取数据"></a>从网页抓取数据</h2><blockquote><p>暂欠</p></blockquote><h2 id="从XML中导入数据"><a href="#从XML中导入数据" class="headerlink" title="从XML中导入数据"></a>从XML中导入数据</h2><blockquote><p>暂欠</p></blockquote><h2 id="访问数据框系统"><a href="#访问数据框系统" class="headerlink" title="访问数据框系统"></a>访问数据框系统</h2><p>如果写过程序的小伙伴可能会很熟悉这里，<strong>使用<code>RODBC</code>包提供的接口来链接数据库，该方法几乎可以连接市面上所有数据库系统</strong>。包中相关函数说明如下：</p><blockquote><p>注：在使用<code>RODBC</code>包访问数据库之前，需要根据自己的电脑下载相关的<code>ODBC</code>驱动。</p></blockquote><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>odbcConnect(dsn,uid=&quot;&quot;,pwd=&quot;&quot;)</code></td><td>建立数据库的连接</td></tr><tr><td><code>sqlFetch(channel,sqltable)</code></td><td>读取数据库中的某个表到一个数据框中</td></tr><tr><td><code>sqlQuery(channel,query)</code></td><td>向数据框提交查询并返回一个结果</td></tr><tr><td><code>sqlSave(channel,mydf,tablename=&quot;&quot;,append=FALSE)</code></td><td>将数据框写入或者更新(<code>append=True</code>)到数据库中的某个表</td></tr><tr><td><code>sqlDrop(channel,sqtable)</code></td><td>删除数据库中的某个表</td></tr><tr><td><code>close(channel)</code></td><td>关闭数据库的连接</td></tr></tbody></table></div><p>该包提供的是面向数据库的双向通路，既可以读取数据库也可以写入数据库。</p><p>关于该包的更多更详细的用法，自行查看包的相关说明。</p>]]></content>
      
      
      <categories>
          
          <category> R语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown进阶</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/MarkDown%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/MarkDown%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown进阶用法"><a href="#MarkDown进阶用法" class="headerlink" title="MarkDown进阶用法"></a>MarkDown进阶用法</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于常规的排版问题，MarkDown给出了简单的解决方案，但是如果我们希望能够做出顺序图/时序图或者相关流程图，又或者数学相关工作者希望的相关数学公式显示问题又怎么解决呢？</p><p>学习此部分，需要掌握一定的<strong>MarkDown基础</strong></p><p><strong>本部分内容为个人经验总结</strong></p><p>本篇最后更新于 <strong>时间</strong> ，部分内容可能与现在不符，请自行判断</p><h4 id="start" align="center"><font color="blue">——生命的意义不在于躲避风雨，而是在雨中起舞♬</font></h4><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>如果在使用过程中，用户想要输入类似于 <code>*</code> 的等已经有相关意义的字符怎么办？这个时候就需要使用转义字符来表示你要单独使用该字符了，告诉编译器不要翻译成markdown格式了。<br><strong>MarkDown支持在下面的字符前插入反斜杠(<code>\</code>)来实现转义</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>创建脚注格式类似这样 <sup><a href="#fn_Markdown" id="reffn_Markdown">Markdown</a></sup>。</p><blockquote id="fn_Markdown"><sup>Markdown</sup>. MarkDown — Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。<a href="#reffn_Markdown" title="Jump back to footnote [Markdown] in the text."> &#8617;</a></blockquote><blockquote><p>注：脚注可能在部分Markdown解析中不适用</p></blockquote><h1 id="LaTeX数学公式语言-Markdown支持的"><a href="#LaTeX数学公式语言-Markdown支持的" class="headerlink" title="LaTeX数学公式语言(Markdown支持的)"></a>LaTeX数学公式语言(Markdown支持的)</h1><p>常用的数学公式表示方法：</p><ul><li><p><strong>行中数学公式</strong><br><strong>在MarkDown中一般使用两个 <script type="math/tex">这里写公式</script> 来表示数学公式的区域</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>2x+y=12<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>显示的效果如下：$2x+y=12$</p></li><li><p><strong>独立数学公式</strong><br><strong>如果采用两个 $$$这里写公式$$$，则是公式单独占用行</strong>，还是上面的例子，展示效果如下：<script type="math/tex">2x+y=12</script></p></li><li><p><strong>独立带编号的数学公式</strong><br>代码如下:</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;equation&#125;数学公式<span class="keyword">\end</span>&#123;equation&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\begin{equation}数学公式\end{equation}$</p></li></ul><h2 id="常用的命令字符"><a href="#常用的命令字符" class="headerlink" title="常用的命令字符"></a>常用的命令字符</h2><ul><li><p><strong>字号转换</strong><br>改变数学公式展示的字号大小，代码示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Huge</span> 这是一号字体<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\huge</span> 这是二号字体<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\LARGE</span> 这是三号字体<span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常用数学符号</strong></p><p>| 符号 |  实现  |   意义   |<br>| :—: | :——: | :———: |<br>|  ≤   |  \leq  | 小于等于 |<br>|  ≥   |  \geq  | 大于等于 |<br>|  ≪   |  \ll   |  远小于  |<br>|  ≫   |  \gg   |  远大于  |<br>|  ×   | \times |   乘号   |<br>|  ÷   |  \div  |   除号   |<br>|  ≠   |  \neq  | 不等于号 |</p></li><li><p><strong>常用希腊字符</strong></p><p>| 符号 |  实现  |<br>| :—: | :——: |<br>|  α   | \alpha |<br>|  β   | \beta  |<br>|  θ   | \theta |<br>|  π   |  \pi   |</p></li><li><p><strong>常用公式</strong></p><p>|                公式                |               实现               |                             说明                             |<br>| :————————————————: | :———————————————: | :—————————————————————————————: |<br>|              $log<em>xy$              |             log_x y              |       `</em><code>表示下标，如果如左边写，默认第一个是下标内容        ||          $log_&#123;x+1&#125; 3y+1$          |          log_&#123;x+1&#125; 3y+1          |</code><em>{}<code>在花括号里写的公式会呈现在下标，花括号外面的则默认真数  ||               $x^n$                |               x^n                |  同样的可以使用</code>^{}<code>，在花括号里写的公式会默认在次方里显示   ||          $\sqrt &#123;x + y&#125;$           |          \sqrt &#123;x + y&#125;           |</code>\sqrt{}<code>花括号里的公式会展示成开平方             ||           $\frac&#123;x&#125;&#123;y&#125;$            |           \frac&#123;x&#125;&#123;y&#125;            |</code>\frac{}{}`第一个括号内的公式为分子，第二个括号的内容为分母  |<br>|    $\sum\limits</em>{x = 1}^{n} 7x$    |    \sum\limits<em>{x = 1}^{n} 7x    | `\sum\limits</em>{}^{}` 占位符，第一个花括号是下面的公式，第二个花括号是和，第三个占位符的位置是后缀的公式 |<br>| $\int<em>{0}^{\frac{\pi}{2}} \sin(x)$ | \int</em>{0}^{\frac{\pi}{2}} \sin(x) |                        如左边公式所示                        |</p></li></ul><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h2><p>代码示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[方形] --&gt;B(圆角)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt;|a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt;|a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[横向流程图]</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 注：代码前面存在一个制表位(`Tab`)来防止被转义为图形，下面同理</span><br><span class="line"></span><br><span class="line">展示效果：</span><br><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><h2 id="纵向流程图"><a href="#纵向流程图" class="headerlink" title="纵向流程图"></a>纵向流程图</h2><p>代码示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">A[方形] --&gt; B(圆角)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt; |a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt; |a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[竖向流程图]</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">展示效果：</span><br><span class="line">```mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><h2 id="标准流程图（纵向）"><a href="#标准流程图（纵向）" class="headerlink" title="标准流程图（纵向）"></a>标准流程图（纵向）</h2><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">展示效果：</span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h2 id="标准流程图（横向）"><a href="#标准流程图（横向）" class="headerlink" title="标准流程图（横向）"></a>标准流程图（横向）</h2><p>代码示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: 开始框</span></span><br><span class="line"><span class="code">op=&gt;operation: 处理框</span></span><br><span class="line"><span class="code">cond=&gt;condition: 判断框(是或否?)</span></span><br><span class="line"><span class="code">sub1=&gt;subroutine: 子流程</span></span><br><span class="line"><span class="code">io=&gt;inputoutput: 输入输出框</span></span><br><span class="line"><span class="code">e=&gt;end: 结束框</span></span><br><span class="line"><span class="code">st(right)-&gt;op(right)-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes)-&gt;io(bottom)-&gt;e</span></span><br><span class="line"><span class="code">cond(no)-&gt;sub1(right)-&gt;op</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">展示效果：</span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h1 id="其他图"><a href="#其他图" class="headerlink" title="其他图"></a>其他图</h1><p>其他图的设计例如：UML图，甘特图等，一般情况下专业的MarkDown才会支持，一般的MarkDown对于上面的流程图支持已是最大限度了。大多数情况下，使用MarkDown来直接绘制流程图远远不如使用相关软件工具绘制插入图片来的更加方便。</p><blockquote><p>如果真的必要且感兴趣，详情查询相关书籍或者其他教程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何化身嘉然小姐来参加网课</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%A6%82%E4%BD%95%E5%8C%96%E8%BA%AB%E5%98%89%E7%84%B6%E5%B0%8F%E5%A7%90%E6%9D%A5%E5%8F%82%E5%8A%A0%E7%BD%91%E8%AF%BE/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%A6%82%E4%BD%95%E5%8C%96%E8%BA%AB%E5%98%89%E7%84%B6%E5%B0%8F%E5%A7%90%E6%9D%A5%E5%8F%82%E5%8A%A0%E7%BD%91%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们终于开始上网课了，看到网课的摄像头，啊很快啊，一个整活的想法油然而生啊。反手就是一个嘉然小姐，一个面补，我都打出去了，他都防住了，我说对不起我是瞎放的，他说我可不是瞎放的，视频后期，绿幕抠图，虚拟摄像头一看就是有备而来………</p><p>扯远了，关于最终的思想效果，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321141443653.png" alt="image-20220321141443653" style="zoom: 50%;" /></p><blockquote><p>感谢林某爹提高的图片</p></blockquote><h1 id="软件准备和环境说明"><a href="#软件准备和环境说明" class="headerlink" title="软件准备和环境说明"></a>软件准备和环境说明</h1><p>【配置说明】</p><ol><li>Win10操作系统</li><li>vTube studio最新版</li><li>OBS Studio最新版</li><li>腾讯会议</li></ol><h1 id="VTube-studio"><a href="#VTube-studio" class="headerlink" title="VTube studio"></a>VTube studio</h1><h2 id="VTube-studio的安装"><a href="#VTube-studio的安装" class="headerlink" title="VTube studio的安装"></a>VTube studio的安装</h2><p>这个软件是Vtube即2D模型/2.5D模型的运算场景，说人话就是虚拟人物和面部捕捉是在这个软件进行的，首先打开<code>Steam</code>，搜索<code>VTube studio</code>，如下图，选择安装即可</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321143502768.png" alt="image-20220321143502768" style="zoom:60%;" /></p><blockquote><p>如果你的足够有能力的话，可以购买<code>DLC</code>来支持一下该软件</p></blockquote><p>安装完成后，运行<code>VTube studio</code>界面如下图，在进入软件的时候会弹出一堆相关说明，确认即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321144048742.png" alt="image-20220321144048742" style="zoom:67%;" /></p><h2 id="VTube-studio的使用"><a href="#VTube-studio的使用" class="headerlink" title="VTube studio的使用"></a><code>VTube studio</code>的使用</h2><h3 id="模型捕捉绑定"><a href="#模型捕捉绑定" class="headerlink" title="模型捕捉绑定"></a>模型捕捉绑定</h3><p>在安装完成后，进入软件的界面，首先需要记住的是可以<strong>使用双击来唤醒菜单</strong>，关于各个部分的功能如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321145008008.png" alt="image-20220321145008008" style="zoom:67%;" /></p><p>现在你所看到的人物模型是<code>VTube studio</code>自带的模型，你可以在<strong>【人物模型部分】</strong>进行选择其他默认自带的模型或者导入自己的2D模型。现在使用导入【嘉然模型】来做示例，关于模型文件会在文章最后末尾给出，自行下载，点击进入【人物模型部分】按钮后，选择导入模型，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321145313856.png" alt="image-20220321145313856" style="zoom:60%;" /></p><p>在点击导入模型后，会弹出路径提醒，然后将你下载的模型导入到它所指定的文件夹中，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321145437300.png" alt="image-20220321145437300" style="zoom: 67%;" /></p><p>将【嘉然模型】文件导入<code>Live2DModels</code>文件夹，后即可在软件中查看导入的模型，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321145621049.png" alt="image-20220321145621049" style="zoom:67%;" /></p><p>现在点击【设置】，进入设置页面。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321145900945.png" alt="image-20220321145900945" style="zoom:67%;" /></p><p>如果你需要导入自己的一些别的资源，例如背景，贴纸等，可以在【常规设置】中右侧【打开资源文件夹】中导入自己的资源，如果没有这个需求，可以不用管。</p><p>现在直接进入【摄像捕捉设置】中，在右侧栏选择【选择摄像头】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150124713.png" alt="image-20220321150124713" style="zoom: 67%;" /></p><p>在弹出的设置提醒中，选择自己要使用哪个摄像头进行捕捉，如果你的摄像头列表中含有<code>VTubeSudioCam</code>则排除该摄像头，查找并选择其他摄像头，该摄像头是软件的虚拟摄像头。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150244658.png" alt="image-20220321150244658" style="zoom:67%;" /></p><p>剩下的设置，就是默认的第一个即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150424082.png" alt="image-20220321150424082" style="zoom:67%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150444592.png" alt="image-20220321150444592" style="zoom: 80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150510882.png" alt="image-20220321150510882" style="zoom:80%;" /></p><p>设置完成后，可以选择【面部捕捉：开启】开启面部捕捉，如果你的模型支持且你希望进行手部捕捉，则在【捕捉类型】中选择面部捕捉和手部捕捉，在本示例【嘉然模型】中，不存在手部绑骨，即无法进行手部捕捉，默认即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150730936.png" alt="image-20220321150730936" style="zoom:80%;" /></p><p>面部捕捉开启后，你的摄像头会被调用打开，会出现面部捕捉的UI显示，如下图，你可以对着摄像头做面无表情来点击校准来校准表情，使用摄像头捕捉需要注意摄像头尽量正对自己且采光良好。</p><p>这个时候你就会发现你的表情和人物模型的表情和动作映射到一起了。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321150846987.png" alt="image-20220321150846987" style="zoom:70%;" /></p><h3 id="虚拟摄像头安装"><a href="#虚拟摄像头安装" class="headerlink" title="虚拟摄像头安装"></a>虚拟摄像头安装</h3><p>在完成人物模型动作表情映射绑定后，现在进行虚拟摄像头的安装，选择【摄像捕捉设置】，滑倒最下面，点击虚拟摄像头安装帮助，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321151332392.png" alt="image-20220321151332392" style="zoom:67%;" /></p><p>然后根据提示选择【打开文件夹】，在文件夹中寻找到<code>Install.bat</code>双击运行，等待安装完成后，关闭控制台即可，如果需要安装失败或者其他错误，可以尝试右键以管理员身份运行<code>Install.bat</code>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321151421727.png" alt="image-20220321151421727" style="zoom:70%;" /></p><p>安装完成后，就可以在【摄像捕捉设置】里【激活虚拟摄像头】，到这一步，所有的<code>VTube studio</code>基本设置已经完成，下面的微调可以跳过。</p><h3 id="其他调整"><a href="#其他调整" class="headerlink" title="其他调整"></a>其他调整</h3><p>对于带眼睛的伙伴来说，会发现模型眨眼的映射和人物模型的眨眼不是很对的上，这个时候就可以在【摄像捕捉设置】中，找到面部配置，将眨眼灵敏度设置到 30 左右即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321151927907.png" alt="image-20220321151927907" style="zoom:67%;" /></p><h1 id="腾讯会议"><a href="#腾讯会议" class="headerlink" title="腾讯会议"></a>腾讯会议</h1><h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><p>腾讯会议安装，运行不再赘述，打开腾讯会议后，进入【设置】，选择【视频】，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321152437211.png" alt="image-20220321152437211" style="zoom:67%;" /></p><p>然后点击【选择设备】，找到<code>VTubeStudioCam</code>，选择该摄像头，就会出现我们在<code>VTubeStudio</code>的模型环境，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321152605977.png" alt="image-20220321152605977" style="zoom:80%;" /></p><p>在上图中，我框出了蓝色的部分，是需要将其关闭的，默认我记得是打开的，你可以选择将【眼神接触】和【暗场景增强】关闭，或者可以和我一样将其全部关闭。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321152913107.png" alt="image-20220321152913107" style="zoom:67%;" /></p><p>如果你发现该虚拟摄像头的内容曝光过度或者色彩不正之类的问题，则需要选择左侧【虚拟背景和美颜】，将其中的【虚拟背景】【美颜】【滤镜】全部关闭即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321165212823.png" alt="image-20220321165212823" style="zoom:80%;" /></p><p>这样你进入会议的时候开启摄像头就是使用的该虚拟摄像头，虚拟场景中人物映射你的动作和表情，到现在为止，基本的虚拟设置已经完成了，你已经实现了将嘉然带入到课堂中，可以停止阅读关闭本文即可。</p><p>如果你希望探索进阶玩法，请继续向下阅读操作。</p><h1 id="OBS-Studio"><a href="#OBS-Studio" class="headerlink" title="OBS Studio"></a><code>OBS Studio</code></h1><h2 id="前期配置"><a href="#前期配置" class="headerlink" title="前期配置"></a>前期配置</h2><p>在使用<code>OBS Studio</code>之前，需要在<code>VTube studio</code>中将背景替换为<code>Background_8</code>，即绿幕背景，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321162517367.png" alt="image-20220321162517367" style="zoom: 67%;" /></p><p>因为我们后续的进阶操作需要将人物从绿幕中抠出来，然后配合<code>OBS Studio</code>来使用。</p><h2 id="OBS-Studio的使用"><a href="#OBS-Studio的使用" class="headerlink" title="OBS Studio的使用"></a><code>OBS Studio</code>的使用</h2><h3 id="环境基础配置"><a href="#环境基础配置" class="headerlink" title="环境基础配置"></a>环境基础配置</h3><p>关于OBS的下载和安装可以选择<a href="https://obsproject.com/">单击我</a>，进入官网，选择自己的对应的系统下载安装，或者在文本最后我会提供我所使用的版本的安装包，安装完成后，运行，它会弹出一个提醒，如下图，如果你是<code>VTube</code>主播且采用串流推送的方式进行直播，则选择默认第一个【优先优化串流，其次为录像】，如果你是上网课玩玩，则选择第三个【我只使用虚拟摄像机】，然后点击【下一步】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321153523000.png" alt="image-20220321153523000" style="zoom: 80%;" /></p><p>然后，选择【应用设置】即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321160604329.png" alt="image-20220321160604329" style="zoom: 80%;" /></p><p>然后进入了默认的软件设置界面：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321160904649.png" alt="image-20220321160904649" style="zoom: 60%;" /></p><p>现在在【来源框】中，点击【+】（加号），选择【视频采集设备】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321161318916.png" alt="image-20220321161318916" style="zoom:80%;" /></p><p>然后在弹出的选择框可以给该组件重命名或者直接点击【确定】即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321161420013.png" alt="image-20220321161420013" style="zoom:67%;" /></p><p>在弹出的组件设置中，选择【设备】找到【<code>VTubeStudioCam</code>】，选择即可，然后点击【确认】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321161541927.png" alt="image-20220321161541927" style="zoom:80%;" /></p><p>然后这个时候就可以在<code>OBS Studio</code>中看到我们在<code>VTube Studio</code>中的虚拟场景，如下图，接下来扣除绿幕</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321162916135.png" alt="image-20220321162916135" style="zoom: 50%;" /></p><h3 id="绿幕扣除"><a href="#绿幕扣除" class="headerlink" title="绿幕扣除"></a>绿幕扣除</h3><p>选中我们导入的【视频采集设备】，然后点击【滤镜】，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321163301537.png" alt="image-20220321163301537" style="zoom:80%;" /></p><p>然后在弹出的弹窗中，选择【+】增加【色度键】，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321163631717.png" alt="image-20220321163631717" style="zoom: 67%;" /></p><p>然后在弹出弹窗中给该色度键重命名或者直接使用默认确认即可，如下图，软件默认扣除绿色背景，如果需要设置则自行设置更改，目前为止，我们已经完成了绿幕抠图。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321163847606.png" alt="image-20220321163847606" style="zoom: 67%;" /></p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>现在我们来增加一张背景图片和文本来实现简单效果，此处添加不做过多赘述。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321164010737.png" alt="image-20220321164010737" style="zoom: 50%;" /></p><p>添加完成后的效果如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321164246312.png" alt="image-20220321164246312" style="zoom: 50%;" /></p><p>如果你发现你添加图片或者内容挡住了一些你不想挡住的内容，如果你学过<code>PS``PR``AE</code>或者<code>PPT</code>的话应该对图层很熟悉，在来源框中，最前面的表示在图层的最上方，根据自己的需求来调整图层位置。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321164441105.png" alt="image-20220321164441105" style="zoom: 80%;" /></p><p>最后一步就是点击右下角的【启动虚拟摄像机】，完成<code>OBS</code>虚拟摄像机配置。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321164538058.png" alt="image-20220321164538058" style="zoom:80%;" /></p><h2 id="腾讯会议-1"><a href="#腾讯会议-1" class="headerlink" title="腾讯会议"></a>腾讯会议</h2><p>现在和前面<code>VTube Studio</code>类似，只需要将【设备】，切换成【<code>OBS Virtual Camera</code>】即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321164730520.png" alt="image-20220321164730520" style="zoom:80%;" /></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>我的电脑左侧屏幕放置运行环境，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321165403144.png" alt="image-20220321165403144" style="zoom: 45%;" /></p><p>右侧屏幕会议效果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321165458686.png" alt="image-20220321165458686" style="zoom: 45%;" /></p><p>别人视角：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220321141443653.png" alt="image-20220321141443653" style="zoom: 50%;" /></p><blockquote><p>再次感谢林某爹提高的图片</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整活 </tag>
            
            <tag> 虚拟摄像头 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全方位榨干大疆MINI-SE</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%A8%E6%96%B9%E4%BD%8D%E6%A6%A8%E5%B9%B2%E5%A4%A7%E7%96%86MINI-SE/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%A8%E6%96%B9%E4%BD%8D%E6%A6%A8%E5%B9%B2%E5%A4%A7%E7%96%86MINI-SE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的无人机到手了，但是购买的是大疆MINI-SE，有些功能想用但是没有办法实现怎么办？我开启了榨干MINI之路。</p><p>基本榨干功能：<strong>全景模式，视觉跟踪，正射影像，倾斜摄影建模，航线规划，环绕摄影</strong>。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>如下是准备的基本工作，无人机型号同我或者以之上皆可，软件设备等同理。</p><ul><li><strong>无人机型号：大疆MINI-SE</strong></li><li><strong>手机设备：华为P30（HarmonyOS 2.0）</strong></li><li><strong>航点规划软件：Rainbow无人机控制飞行软件（V3.6）</strong></li><li><strong>电脑：Win10（20H2）</strong></li><li><strong>后期软件：Pix4Dmapper（V4.4.12），PS（CC 2018），AE（CC 2018）</strong></li></ul><h1 id="全景模式"><a href="#全景模式" class="headerlink" title="全景模式"></a>全景模式</h1><p>对于<strong>全景模式大疆支持是MINI2及以上才支持一键全景，而MINI-SE是不支持全景的</strong>，但是我们又很想要全景的效果，这个时候就需要手动全景合成了，两种方法：</p><blockquote><p>注：此处全景模式特指的是<strong>球形全景</strong></p></blockquote><h2 id="手动全景合成"><a href="#手动全景合成" class="headerlink" title="手动全景合成"></a>手动全景合成</h2><p>关于手动全景合成可以看这个视频，<a href="https://www.bilibili.com/video/BV1TE411N7SG">【教程】Mini也能做全景图？</a>，此处不做过多说明。</p><p>就我个人认为手动全景可以，但是工作量相对较大，而且不是很精准，<strong>我个人更推荐下面的软件合成+人工后期处理</strong>。</p><h2 id="使用软件来合成"><a href="#使用软件来合成" class="headerlink" title="使用软件来合成"></a>使用软件来合成</h2><p><strong>打开【Rainbow无人机控制飞行软件】，选择全景</strong>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416105915979.png" alt="image-20220416105915979" style="zoom: 50%;" /></p><p><strong>然后选择【全景设置】，在全景设置中，选择【球形】，在下面的参数中，将【全景清晰度】设置为【高】</strong>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416110203581.png" alt="image-20220416110203581" style="zoom: 50%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416110452010.png" alt="image-20220416110452010" style="zoom:50%;" /></p><p>然后，点<strong>击左侧【开始】，等待无人机拍摄，结束完成后，点击【下载】，选择要合成的全景图，等待合成</strong>，一般要3-5分钟，因手机和图片质量以及合成参数而异。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416110723305.png" alt="image-20220416110723305" style="zoom:50%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416110757610.png" alt="image-20220416110757610" style="zoom:50%;" /></p><p>下载完成后，可以在软件中浏览全景图片，如下为在软件中预览效果：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/SVID_20220416_110842_1.mp4" width="100%"></video><p>你会发现部分地方有些模糊，头顶更是黑了一片，<strong>关于模糊的部分是因为镜头拍摄的时候曝光问题</strong>，需要在拍摄的时候注意曝光，而<strong>头顶黑了一片是因为MINI-SE没办法拍摄头顶图片，这个时候就需要手动“补天”</strong>。如下图为软件初步合成的全景图片：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416111648908.png" alt="image-20220416111648908" style="zoom:80%;" /></p><p>将图片使用PS来手动补天，<strong>补天后的图片输出如下</strong>，可以通过<a href="https://720yun.com/t/9fvkb7pmd1h?scene_id=92363395">点我来预览</a>，所有归属归山东农业大学所有，此处仅做演示说明，<strong>未经授权不可它用</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416111833860.png" alt="image-20220416111833860" style="zoom:80%;" /></p><p>这样就基本实现了一张球形的全景图片，<strong>如果你想要纯手动制作一张全景图片或者希望分享给别人自己拍的全景图片，可以使用<a href="https://720yun.com/">720云</a>网站来制作和分享</strong>。</p><h1 id="正射影像"><a href="#正射影像" class="headerlink" title="正射影像"></a>正射影像</h1><h2 id="什么是正射影像"><a href="#什么是正射影像" class="headerlink" title="什么是正射影像"></a>什么是正射影像</h2><p>正射影像顾名思义：<strong>即通过将无人机的云台成 -90° 方向（镜头正下方）来进行连续拍摄，保证一定的航向重叠率情况下，完成航线拍摄，然后通过后期软件来处理成一张航拍的地区正射影像</strong>。可以想象成地图的样子就是呈现结果。</p><h2 id="开始航拍工作"><a href="#开始航拍工作" class="headerlink" title="开始航拍工作"></a>开始航拍工作</h2><p>首先找一个地方，<strong>选择一片需要正射影像</strong>的地方，此处<strong>示例以山东农业大学南校区正南门一片区域</strong>为正射影像为例，<strong>因为正射影像涉及航测方面的问题，所以示例会做模糊和水印处理</strong>。</p><p>我在早上大概7点20左右拍摄的正射影像，拍摄地区如下卫星图（高德地图）：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416103259680.png" alt="image-20220416103259680" style="zoom:80%;" /></p><p>飞行航线如下图，<strong>具体飞行航线和航拍点是根据飞行高度，即航拍高度决定的</strong>。因为我的MINI-SE只有1200万的像素，所以<strong>我通过降低航拍飞行高度来让我的正射影像结果更清晰一些</strong>，同样的，<strong>随着航拍高度的降低航线和航点，拍摄的正射图片也会增加，也就是说正射完成的耗时更长</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416103403378.png" alt="image-20220416103403378" style="zoom: 50%;" /></p><p>我一共拍摄了130张正射影像，然后<strong>将图像导入到Pix4Dmapper软件中</strong>，进行处理，<strong>如果没有特殊需求，一路默认下去，然后在如下选择中选择第一个【3D Maps】，点击下一步即可，然后等待漫长解析</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416112830021.png" alt="image-20220416112830021" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416113020209.png" alt="image-20220416113020209" style="zoom:80%;" /></p><p>解析完成后，<strong>会在相关的项目文件夹中生成相关文件以及质量报告</strong>，项目文件如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416113134308.png" alt="image-20220416113134308" style="zoom:80%;" /></p><ul><li><strong>1_initial：包含质量报告和相关图像基本信息</strong></li><li><strong>2_densification：包含3D点云以及相关3D模型</strong></li><li><strong>3_dsm_ortho：包含正射影像文件和DSM文件等</strong></li><li><strong>temp：临时文件（不需要管）</strong></li><li><strong>Test.log：项目日志（不需要管）</strong></li></ul><p>在如下路径可以找到<strong>项目生成的质量报告</strong>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416113953015.png" alt="image-20220416113953015" style="zoom:80%;" /></p><p>在如下路径可以找到<strong>正射影像文件和DSM文件</strong>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416114128730.png" alt="image-20220416114128730" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416114051155.png" alt="image-20220416114051155" style="zoom:80%;" /></p><p>在如下路径可以找到生成的<strong>模型文件</strong>：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416114217754.png" alt="image-20220416114217754" style="zoom:80%;" /></p><p>如下为我拍摄最后生成的正射影像和DSM图像，最终归属为山东农业大学，未经允许不可它用。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416114919521.png" alt="image-20220416114919521" style="zoom:80%;" /></p><h1 id="倾斜摄影"><a href="#倾斜摄影" class="headerlink" title="倾斜摄影"></a>倾斜摄影</h1><p>倾斜摄影和正射影像同理，也需要<strong>使用Pix4Dmapper</strong>，将相关倾斜摄影图片导入项目中，在遇到下列选项中<strong>选择【3D Models】</strong>，然后等待解析生成质量报告。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416164918800.png" alt="image-20220416164918800" style="zoom:80%;" /></p><p>如下是我倾斜摄影的航线，我选择了很小的一块地方，所以相对图片和时间上少很多。可以看到，<strong>倾斜摄影会飞5条航线，分别是上下左右（东南西北）的倾斜摄影和一条中间的正射影像</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416165051015.png" alt="image-20220416165051015" style="zoom: 67%;" /></p><p>等待质量报告出来，解析完成后，<strong>在文件夹【1_initial】中可以找到质量报告，在文件夹【2_densification】中可以找到相关的3D模型</strong>。如下是相关模型的GIF：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/_001.gif" alt="image-20220416165051015" style="zoom: 80%;" /></p><p>因为大疆MINI-SE的像素只有1200万，所以可以尝试将飞行高度降低，来增加航点来提升最终模型质量。</p><h1 id="视觉跟踪"><a href="#视觉跟踪" class="headerlink" title="视觉跟踪"></a>视觉跟踪</h1><p>因为大疆MINI-SE没有内置硬件图形加速相关，所以<strong>此处的视觉跟踪是基于软件的图像识别，使用<code>Rainbow无人机控制软件</code>，选择【视觉跟踪】</strong>，然后框选需要跟踪的对象，剩下的交给图像识别。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416174154442.png" alt="image-20220416174154442" style="zoom:50%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416174214906.png" alt="image-20220416174214906" style="zoom:50%;" /></p><p>需要注意的是，<strong>因为是基于图像识别的，所以它对于控制的手机有一定的性能要求</strong>，当然你也可以在其设置中选择低精度识别，不过同理识别精度会差很多。另外还需要注意的是，这个功能更加建议在空旷的场景或者有人看着的情况下使用，<strong>因为大疆MINI-SE没有视觉避障，所以存在炸机的风险</strong>。</p><p>视觉跟踪效果如下：</p><video controls="controls" src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/DJI_0908.mp4" width="100%"></video><h1 id="环绕摄影"><a href="#环绕摄影" class="headerlink" title="环绕摄影"></a>环绕摄影</h1><p>环绕摄影通俗理解就是无人机围绕某个点画圆，由于新手很难画出一个比较完整的圆形，又需要这个功能，这个时候就需要<code>Rainbow无人机控制软件</code>来使用【环绕】功能。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416181900530.png" alt="image-20220416181900530" style="zoom:50%;" /></p><p>具体使用方法不多解释，举一反三。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>最后的想法是可以利用无人机摄影+后期来实现如右侧的同款赛博朋克效果<a href="https://www.bilibili.com/video/BV1F54y1y78E/?spm_id_from=333.788.recommend_more_video.1">长安大学【赛博朋克】</a>。看我有没有的时间来弄吧。就这样。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220416182427906.png" alt="image-20220416182427906" style="zoom: 67%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正射影像 </tag>
            
            <tag> 倾斜摄影 </tag>
            
            <tag> 全景模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我人生第一台无人机</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E5%8F%B0%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E5%8F%B0%E6%97%A0%E4%BA%BA%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我快忘记我什么时候有了买无人机的念头了，我记得最近思考这个问题是今年过年的时候，也就是寒假的时候，我也快忘记我当时想的什么了，在4月1日下单购买了<strong>我人生中第一台无人机——大疆MINI SE</strong>，如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412205834391.png" alt="image-20220412205834391" style="zoom:80%;" /></p><h1 id="关于购买和使用感受"><a href="#关于购买和使用感受" class="headerlink" title="关于购买和使用感受"></a>关于购买和使用感受</h1><p>我买的是大疆截至目前写文章时最便宜的无人机，单机只需要1999，它采用的是增强WIFI图传，1200万像素，不支持变焦，从价格角度来说这是一个相对便宜的入门级无人机，从使用感官来说，WIFI图传的确不是很友好，不过对于这个价格来说，2000块钱要什么自行车。</p><p>综合来说在这个价位作为一款入门级大疆无人机，已经是非常不错了，我本人在校园测试，如果高度在100m及以上，水平可以拉锯500m起步，我拉了500m就没有再拉距。</p><p>一些无人机的问题：</p><p>【无人机FCC是什么？要不要弄】</p><p>如下图，图片内容版权归原作者所有，此处仅作引用说明，侵删。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412212716380.png" alt="image-20220412212716380" style="zoom:67%;" /></p><p>通俗来说就是一种不同国家对于信号频率的限制，而FCC，即美国的标准可以让我们的无人机图传信号和距离更远更稳定，相对来说会增加一定的耗电量，关于要不要弄，我目前人是很懒的，能不动手就不动手，所以我没弄。</p><p>【WIFI图传怎么样？】</p><p>我只能说郊区效果还可以，市区我见过100m没信号的，市内干扰太大了，所以我个人建议预算充足的情况下，加1000买mini 2吧。</p><p>【有没有什么办法增强信号？】</p><p>要么改遥控器和无人机，要么购买相关增强天线，至于相关增强天线是否真的有用，我持有保留意见，因为我买的还在路上，不知道，他们飞友说是有一定的用的。</p><h1 id="关于一些我随手拍的图片"><a href="#关于一些我随手拍的图片" class="headerlink" title="关于一些我随手拍的图片"></a>关于一些我随手拍的图片</h1><p>最近人也变懒了，图片就传一些，其他带宽有限，我也不想通过这种方式来呈现所有图片，所以就看看吧。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213339393.png" alt="image-20220412213339393" style="zoom: 80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213407831.png" alt="image-20220412213407831" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213426277.png" alt="image-20220412213426277" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213440238.png" alt="image-20220412213440238" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213456454.png" alt="image-20220412213456454" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213511286.png" alt="image-20220412213511286" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213528566.png" alt="image-20220412213528566" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213543998.png" alt="image-20220412213543998" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213559702.png" alt="image-20220412213559702" style="zoom:80%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412213614440.png" alt="image-20220412213614440" style="zoom:80%;" /></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p><strong>卡密萨马，给我再多一点时间让我掌握最后的正射拍摄和倾斜摄影吧！！！</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220412212559668.png" alt="image-20220412212559668" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于网站搭建那些事（下）</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分是建立在网站服务器搭建完成的基础上改造而来的，如果不知道如何网站搭建，可以查看<a href="https://helloseraphine.top/index.php/archives/168.html">关于网站搭建那些事（上）</a>。</p><p>这部分就是<strong>SSL部署，对象存储和CDN加速，WAF以及小部分代码改造</strong>部分的指南了，前面网站搭建的文章里解释了<strong>DNS，IP，域名以及服务器的搭建</strong>的相关内容，此处不做赘述。</p><p><strong>关于所有内容都是在我当前博客实现或者实现过的功能，该博客建立——以此纪念我的大学生活</strong></p><h1 id="SSL部署"><a href="#SSL部署" class="headerlink" title="SSL部署"></a>SSL部署</h1><h2 id="什么是SSL？"><a href="#什么是SSL？" class="headerlink" title="什么是SSL？"></a>什么是SSL？</h2><p>老规矩先解释这是个什么东西，以下斜体定义引用自百度百科：</p><p><em>SSL(Secure Sockets Layer <a href="https://baike.baidu.com/item/安全套接字协议">安全套接字协议</a>),及其继任者<a href="https://baike.baidu.com/item/传输层安全">传输层安全</a>（Transport Layer Security，TLS）是为<a href="https://baike.baidu.com/item/网络通信/9636548">网络通信</a>提供安全及<a href="https://baike.baidu.com/item/数据完整性/110071">数据完整性</a>的一种安全协议。TLS与SSL在<a href="https://baike.baidu.com/item/传输层/4329536">传输层</a>与<a href="https://baike.baidu.com/item/应用层/16412033">应用层</a>之间对网络连接进行加密。</em></p><p>定义依旧很学术，<strong>通俗来理解：SSL提供了安全访问保护</strong>。对于成功部署SSL的网站，在网站网址左侧会有一把小锁表示安全，如下图（图示浏览器为谷歌浏览器）：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224212715945.png" alt="image-20220224212715945" style="zoom:150%;" /></p><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><h3 id="SSL证书提供商"><a href="#SSL证书提供商" class="headerlink" title="SSL证书提供商"></a>SSL证书提供商</h3><p>SSL有收费的和免费，此处仅演示免费版，SSL证书分为单域名SSL证书，和泛域名SSL证书，关于两者的区别，可以参考这个文章<a href="https://jingyan.baidu.com/article/ad310e80992f5a5849f49ed6.html">单域名SSL证书和泛域名SSL证书之间的区别</a></p><p>因为是免费的，没得挑，就是单域名SSL证书，申请服务商：</p><ul><li><a href="https://console.cloud.tencent.com/certoverview">腾讯云SSL证书</a></li><li><a href="https://yundun.console.aliyun.com/?spm=5176.12818093.ProductAndService--ali--widget-home-product-recent.dre9.12d216d0yYAj17&amp;p=cas#/overview/cn-hangzhou">阿里云SSL证书</a></li></ul><ol><li><p><a href="https://console.cloud.tencent.com/certoverview">腾讯云SSL证书</a></p><p>我网站使用的SSL证书就是腾讯云免费申请的，有效期一年，SSL到期了再来申请即可，SSL申请部署以腾讯云为实例，其他服务商类比</p></li><li><p><a href="https://yundun.console.aliyun.com/?spm=5176.12818093.ProductAndService--ali--widget-home-product-recent.dre9.12d216d0yYAj17&amp;p=cas#/overview/cn-hangzhou">阿里云SSL证书</a></p><p>没申请过，不清楚</p></li></ol><h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><ol><li><p><strong>进入腾讯云SSL证书控制台</strong>，在左侧选择<strong>我的证书</strong>，然后<strong>【选择 申请免费证书】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224213634777.png" alt="image-20220224213634777" style="zoom:67%;" /></p></li><li><p>然后弹出证书选择，选择默认即可</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224213816184.png" alt="image-20220224213816184" style="zoom:50%;" /></p></li><li><p>然后<strong>进入证书申请</strong>页面，填写相关域名和资料，按自己需求和内容填写即可</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224213906041.png" alt="image-20220224213906041" style="zoom:67%;" /></p></li><li><p>最后提交等待审核即可，审核一般隔天吧，记不太清楚了，审核通过之后，就可以在<strong>我的证书</strong>页面中看到审核通过的SSL证书，到这里SSL证书申请完成。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224214047022.png" alt="image-20220224214047022" style="zoom:150%;" /></p></li></ol><h3 id="部署SSL证书"><a href="#部署SSL证书" class="headerlink" title="部署SSL证书"></a>部署SSL证书</h3><p>我在<a href="https://helloseraphine.top/index.php/archives/168.html">关于网站搭建那些事（上）</a>中说明了我的网站服务器使用的是阿里云的轻量应用服务器。它是基于<strong>LNMP</strong>网站架构，关于LNMP的说明，以下斜体内容引用百度百科：</p><p><strong>*LNMP</strong>是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写。L指Linux，N指Nginx，M一般指MySQL，也可以指MariaDB，P一般指PHP，也可以指Perl或Python。*</p><p>所以，这部分部署步骤实例，是基于Nginx服务器的，其他服务器自行查询部署方法：</p><ol><li><p>首先下载之前申请的SSL证书到本地，<strong>下载的时候，选择对应的服务器</strong>，此处选择 Nginx</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224214942925.png" alt="image-20220224214942925" style="zoom:67%;" /></p></li><li><p>下载完成后，解压到本地，会得到如下的文件</p><p><strong>.crt：证书文件（公钥）</strong></p><p><strong>.pem：证书文件（安装时可忽略）</strong></p><p><strong>.key：私钥</strong></p><p><strong>.csr：CSR文件（安装时可忽略）</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224215121684.png" alt="image-20220224215121684" style="zoom:80%;" /></p></li><li><p>使用远程登录工具，例如WinSCP，<strong>将证书文件（公钥）和私钥文件上传到 Nginx 服务器的 <code>/usr/local/nginx/conf</code> 目录（一般 Nginx 默认安装目录）下</strong>。</p><p><strong>需要注意的是：阿里云轻量应用服务器，起码我这个它的服务器文件目录十分杂乱（ <code>:(</code> 差评），所以你往往找不到这个目录，或者该目录不存在</strong>，如果出现了我说的这两种情况请使用如下方法：</p><ul><li><p>使用其他远程工具或者阿里云轻量应用服务器网页版的控制台，输入如下Linux命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224220455104.png" alt="image-20220224220455104" style="zoom:150%;" /></p><p>然后根据命令查找到的目录，使用WinSCP工具，<strong>查找文件目录下是否含有<code>nginx.conf</code>文件，如果存在，则是该目录</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224220941410.png" alt="image-20220224220941410" style="zoom:67%;" /></p></li></ul></li><li><p><strong>然后在该目录下，创建名称为<code>cert</code>的文件，将下载的证书文件上传到该文件夹中。</strong></p></li><li><p>然后打开<code>nginx.conf</code>文件，里面最下面一部分的代码内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Settings <span class="keyword">for</span> a TLS enabled server.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#    server &#123;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       listen       443 ssl http2;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       listen       [::]:443 ssl http2;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       server_name  _;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       root         xxxx这里是你网站的根目录;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_certificate_key <span class="string">&quot;/etc/pki/nginx/private/server.key&quot;</span>;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_session_timeout  10m;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_ciphers PROFILE=SYSTEM;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        # Load configuration files for the default server block.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        error_page 404 /404.html;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           location = /40x.html &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       &#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           location = /50x.html &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       &#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   &#125;</span></span><br></pre></td></tr></table></figure><p>可以使用下面的代码示例来替换上面代码的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       443 ssl http2;</span><br><span class="line">listen       [::]:443 ssl http2;</span><br><span class="line">server_name  这里填绑定证书的域名;</span><br><span class="line">root         这里填你网站的根目录;</span><br><span class="line"></span><br><span class="line">ssl_certificate &quot;这里填写SSL证书文件里的.scr文件的路径&quot;;</span><br><span class="line">ssl_certificate_key &quot;这里填写SSL证书文件里.key路径&quot;;</span><br><span class="line">ssl_session_cache shared:SSL:1m;</span><br><span class="line">ssl_session_timeout  10m;</span><br><span class="line">ssl_ciphers PROFILE=SYSTEM;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Load configuration files <span class="keyword">for</span> the default server block.</span></span><br><span class="line">include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location = /40x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果你希望<strong>设置强制HTTP请求自动跳转HTTPS</strong>。则在上述代码前面添加如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 这里写你证书绑定的域名;</span><br><span class="line">    rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试，访问，网址栏左侧出现一把小锁，则配置成功</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224223553931.png" alt="image-20220224223553931" style="zoom:150%;" /></p></li></ol><h1 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h1><h2 id="什么是对象存储？"><a href="#什么是对象存储？" class="headerlink" title="什么是对象存储？"></a>什么是对象存储？</h2><p>老规矩先解释这是个什么东西。以下斜体定义引自百度百科：</p><p><em>对象存储是用来描述解决和处理离散单元的方法的通用术语。对象在一个层结构中不会再有层级结构，是以扩展元数据为特征的。</em></p><p>很不幸，这个定义说的很学术，看的人云里雾里，通俗来说就是：<strong>对象存储可以实现将指定文件生成对应直链</strong>。举一个例子，我想要在文章里插入一个图片，这个时候，就需要给文章的图片指定一个地址，这个地址就是图片的直链，借用HTML代码来展示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//图片语法格式示例</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;some_text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>url</code>：就是需要提高图片的地址</li><li><code>alt</code>：是对这张图片的描述</li></ul><p>可以看到，这个图片的地址，就是需要提供图片的直链<strong>，类似于我们在Word里插入图片也要提供图片位置，唯一不同的是文件的地址表现形式不同，在网络上文件的地址表示是<code>url</code>的形式</strong>。</p><h2 id="对象存储有什么用？"><a href="#对象存储有什么用？" class="headerlink" title="对象存储有什么用？"></a>对象存储有什么用？</h2><p>一般情况下，对于入门级或者一些配置低的服务器会存在带宽低的问题，低带宽带来的致命缺陷就是超长的加载时间，对于常规的文本可以忽略不记，有句话叫做：代码是最不占空间的东西，网站提供的服务中，多媒体图片，音频，视频的资源往往是带宽的瓶颈。例如腾讯云的学生优惠服务器：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224171200715.png" alt="image-20220224171200715" style="zoom:60%;" /></p><p>这个是我弄服务器的时候的套餐了，现在似乎是不支持了，有新版的套餐了。我记得当时是 99/年，可以续费三次，价格很便宜，可以明显的看到这个套餐的配置，属于是入门级别的，可以稍微玩玩，要命的是它的带宽只有 1Mbps，这是一个什么概念呢，$1/8 = 0.125$（MB），这是计算的理论速度，由于路由分发和各种问题，实际速度80k左右大概。对于一个图片，如果图片大小是 0.8 （MB），那么预计8秒才可以加载完成，或许这个速度放在20年前没有任何问题，但是对于现在来说，超过3秒的加载以及足以让人有些焦灼了。</p><p>国内服务器现状，空间不值钱，但是带宽翻一倍，价格翻两倍，所以带宽由贵由重要，有没有什么更好的解决方案？那就是对象存储，在早期的网站是将所有资源放在网站服务器上，所有资源文件同网站共享一个带宽，很容易被带宽掐脖子，对象存储提供了自定义文件的直链，就可以跳出网站服务器的限制，因为你的资源（图片，音频，视频）放在了对象存储的库中了，使用的是对象存储提供商提供的带宽。</p><p>这样将你网站的图片，视频，音频上传到对象存储上，获取文件对应的直链，直接在博客网站中引用，就实现了资源分离，也解决了加载的带宽问题。</p><p>使用对象存储可以解决：</p><ol><li>图片加载问题，图片可以很快加载</li><li>音频播放问题，音频歌曲可以顺畅播放</li><li>视频播放问题，甚至4K+的流媒体在线播放</li></ol><h2 id="对象存储的使用示例"><a href="#对象存储的使用示例" class="headerlink" title="对象存储的使用示例"></a>对象存储的使用示例</h2><h3 id="对象存储服务商推荐-amp-个人见解"><a href="#对象存储服务商推荐-amp-个人见解" class="headerlink" title="对象存储服务商推荐&amp;个人见解"></a>对象存储服务商推荐&amp;个人见解</h3><ul><li><a href="https://cloud.tencent.com/product/cos">腾讯云的COS</a></li><li><a href="https://www.aliyun.com/product/oss?spm=5176.19720258.J_8058803260.33.e9392c4a8qw2OR">阿里云的OSS</a></li><li><a href="https://www.upyun.com/products/file-storage">又拍云的USS</a></li><li><a href="https://www.huaweicloud.com/product/obs.html">华为云的OBS</a></li></ul><p>当然还有移动云，电信云，联通云等等的对象存储产品。</p><blockquote><p>关于它们提供的对象存储服务的名字不一样，但是用法都是通用的</p></blockquote><ol><li><p><a href="https://cloud.tencent.com/product/cos">腾讯云的COS</a></p><p>我目前用的就是腾讯云的COS，你可以通过体验我的网站视频，音频，图片的加载速度和相关体验来对腾讯云的对象存储有大概的了解。</p><p>腾讯云的优点：老牌稳定，带宽可以，价格很可以接受。</p><p>【需要付费】关于价格我大概如下说明一下：</p><p>腾讯云定期搞活动，全年活动无休，无非是优惠力度大小问题，对于学生和新用户优惠力度更大，建议购买前先去腾云最新活动页面看看属于新用户的优惠，很值的，我就是错过了这个新用户活动。关于具体的优惠活动不做多解释。</p><p>COS 的收费可以分为：存储空间和外网下行流量。</p><blockquote><p>该收费标准是通用的，阿里云，又拍云等对象存储服务商大致是这个收费标准</p></blockquote><p>存储空间很容易理解，花钱买空间，外围下行流量的意思是文件生成的直链，被别人访问的时候（也就是加载文件）所消耗的流量，例如：上面说的图片，如果图片30KB，则在对象存储上占用30KB的存储空间，如果别人访问网站需要加载这个图片，则消耗对应大小的外网下行流量来实现加载。</p><p>我的存储空间白嫖的活动，【1元/1年】50GB的存储空间，外网下行流量是单买的流量包，价格我记得大概是【3.6元/10 GB/月】，当然也有优惠活动，对于老用户过年的时候有个活动是【84元/100GB/月】，100GB对于个人博客而言，属于那种往死里用都管够的那种，还是很值的。</p></li><li><p><a href="https://www.aliyun.com/product/oss?spm=5176.19720258.J_8058803260.33.e9392c4a8qw2OR">阿里云的OSS</a></p><p>阿里云我没用过，但是我看过它们的收费标准，阿里云的对象存储外网下行流量包最低起步是 100GB/月，这样价格就起来了，100GB太多了对于一般网站，所以有些多余，自行根据需求选择。</p><p>至于阿里云OSS的使用效果如何，请自行体验</p></li><li><p><a href="https://www.upyun.com/products/file-storage">又拍云的USS</a></p><p>又拍云有个好处，它提供开发者又拍云联盟计划，你需要在你的网站下面引用又拍云提供对象存储技术支持相关文字和链接，这样它每月提供15GB的流量和10GB的存储空间。</p><p>通俗来说，就是稍微在你的网站打一下广告，你可以获得每月15GB的流量和一共10GB的存储空间，这真的很诱人，一度让我尝试去申请，不过，由于我以及使用了COS，转移数据过于麻烦等一系列原因，最终没有选择使用，对于想要白嫖的玩家来说，这是个很不错的选择。</p><blockquote><p>点击查看<a href="https://www.upyun.com/league">又拍云联盟计划活动</a></p></blockquote><p>至于又拍云的使用效果如何，可以参考这个博客<a href="https://keymoe.com/">Sanakeyの小站</a></p></li><li><p><a href="https://www.huaweicloud.com/product/obs.html">华为云的OBS</a></p><p>华为云没用过，我也没看过它的收费标准和使用效果，只是一己私利支持一下华为（狗是不是该给我广告费）</p></li></ol><h3 id="腾讯云对象存储（COS）使用指南"><a href="#腾讯云对象存储（COS）使用指南" class="headerlink" title="腾讯云对象存储（COS）使用指南"></a>腾讯云对象存储（COS）使用指南</h3><p>因为我目前使用的就是腾讯云的对象存储，所以只提供腾讯云的对象存储的使用指南，其他服务商的对象存储服务，自行查找或者参考相关文档。</p><h4 id="存储桶的创建"><a href="#存储桶的创建" class="headerlink" title="存储桶的创建"></a>存储桶的创建</h4><ol><li><p>首先<strong>【进入<a href="https://console.cloud.tencent.com/cos">腾讯云对象存储的控制台</a>】</strong>，在<strong>左侧</strong>一栏<strong>【选择存储桶列表】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224185119735.png" alt="image-20220224185119735" style="zoom:67%;" /></p></li><li><p><strong>选择【创建存储桶】</strong>，然后弹出来存储桶创建的窗口，根据下面的选择自己的需求，然后<strong>【点击下一步】</strong></p><p><strong>所在地域</strong>：可以默认，也可以选择一共距离自己目前位置较近的位置。如果想要访问的快一些，就选择距离自己近一些的地域。</p><p><strong>名称</strong>：自定义名称，随意</p><p><strong>访问权限</strong>：默认私有读写即可，特殊需求除外</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224185334651.png" alt="image-20220224185334651" style="zoom:67%;" /></p></li><li><p>在<strong>高级可选配置</strong>中，没特殊需求，默认即可，<strong>然后【点击下一步】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224192106362.png" alt="image-20220224192106362" style="zoom:67%;" /></p></li><li><p>最后在<strong>确认配置页面</strong>，<strong>【点击创建】</strong>即可，这就完成了存储桶的创建（即存储空间，可以理解为云硬盘）</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224192251443.png" alt="image-20220224192251443" style="zoom:67%;" /></p></li><li><p>创建完成后，就可以在<strong>存储桶列表</strong>中看见自己刚刚创建的存储桶了</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224192414204.png" alt="image-20220224192414204" style="zoom:67%;" /></p></li></ol><h4 id="对象存储基本使用"><a href="#对象存储基本使用" class="headerlink" title="对象存储基本使用"></a>对象存储基本使用</h4><p>在创建完成存储桶之后，就可以上传指定文件到存储桶中，生成对应的文件直链了，此处举例如下图，我上传了张图片：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224192738882.png" alt="image-20220224192738882" style="zoom:150%;" /></p><p>然后点击图片的详情，进入文件的详情页面，就可以看到该文件的直链了：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224192916835.png" alt="image-20220224192916835" style="zoom:80%;" /></p><p>有了这个直链你就可以直接在网络引用该图片，同样的音频，视频也同理。</p><blockquote><p>需要注意的是，默认腾讯云存储桶存在一个生命周期规则，将其删除即可，具体原因我后面再专门写一部分对象存储的内容，基本的对象存储使用到这里就完成了。</p></blockquote><h4 id="对象存储的第三方调用和开发"><a href="#对象存储的第三方调用和开发" class="headerlink" title="对象存储的第三方调用和开发"></a>对象存储的第三方调用和开发</h4><p>如果需要使用对象存储进行软件开发或者其他需要对接的接口等，参考文档：腾讯云提供的<a href="https://cloud.tencent.com/document/product/436/6474">对象存储文档</a>。</p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><h2 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a>什么是CDN？</h2><p>老规矩先解释定义，斜体引用百度百科的定义：</p><p><em>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/内容分发网络/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</em></p><p>依旧是比较学术的定义，看的人一头雾水，<strong>通俗理解为：CDN通过多个加速节点来实现网站访问加速</strong>。虽然看起来我解释的不是很通俗易懂，这里需要插播一下 CDN 技术原理，推荐这个视频</p><ul><li><a href="https://www.bilibili.com/video/av211739167">CDN:一定要会用的网站加速方法</a></li></ul><p>或者看我的简单描述：</p><p>首先，要明白网站是怎么访问的，简述来说：用户通过域名访问网站服务器，网站服务器将网站的相关文件发送给你（或者理解为你下载了网站的相关文件），然后通过你本地的浏览器，将接受（下载）的网站相关文件解析，呈现出来的过程。</p><p>在有了上述的理解之后，需要明白，每个访问网站的用户的实际地理位置是不同的，而网站服务器的位置是固定的，也就是说，存在着如果访问的用户地理位置距离服务器地理位置很近则访问速度会更快的情况，因为距离越远，路由中继转发也就越多，耗时越长。</p><p>所以，为了提高访问速度，CDN提供了一套解决方案：在全国不同位置建立 N 个结点，将网站服务器的静态资源文件拷贝到对应的不同结点上，在用户访问的时候，优先将距离用户最近的结点的网站静态文件传输过去，这样提高了网站的加载速度和访问速度。</p><blockquote><p>关于啥是静态资源文件，理解为基本不会改变的资源文件，例如图片，音频，相关文件等我们上传了就基本不会再做二次修改了（主要是看你怎么理解这个基本不修改）</p></blockquote><h2 id="CDN的使用示例"><a href="#CDN的使用示例" class="headerlink" title="CDN的使用示例"></a>CDN的使用示例</h2><p>老规矩，先看看有那些服务商提供CDN服务，并挑选一个</p><h3 id="CDN服务商推荐-amp-个人见解"><a href="#CDN服务商推荐-amp-个人见解" class="headerlink" title="CDN服务商推荐&amp;个人见解"></a>CDN服务商推荐&amp;个人见解</h3><ul><li><a href="https://console.cloud.tencent.com/cdn">腾讯云CDN</a></li><li><a href="https://cdn.console.aliyun.com/overview">阿里云CDN</a></li><li><a href="https://www.upyun.com/products/cdn">又拍云CDN</a></li><li><a href="https://www.huaweicloud.com/product/cdn.html">华为云CDN</a></li></ul><ol><li><p><a href="https://console.cloud.tencent.com/cdn">腾讯云CDN</a></p><p>我没用过，大致看了一下，我很喜欢腾讯云活动的频繁程度和优惠程度相比于阿里云好一些，价格两者CDN差不多，但是腾讯云的活动稍微多一些，但是从CDN的结点数量和分发能力上来说，稍微弱于阿里云CDN，具体效果的自行查找相关网站或者文档</p></li><li><p><a href="https://cdn.console.aliyun.com/overview">阿里云CDN</a></p><p>我目前使用的就是阿里云CDN，阿里云的产品有个好处就是有客服，纯小白也可以靠客服的指引来学习和配置。阿里云CDN的结点目前应该是国内最多也是最大的了，因为我的服务器也在阿里云，所以就购买并配置了阿里云CDN。具体效果，你通过访问<a href="https://helloseraphine.top/">Seraphineの小窝</a>来体验。</p></li><li><p><a href="https://www.upyun.com/products/cdn">又拍云CDN</a></p><p>又拍云的CDN也是比较有名的，不过我没用过，也不了解，具体价格和使用方法自行查看官网，使用效果查看这个网站：<a href="https://keymoe.com/">Sanakeyの小站</a></p></li><li><p><a href="https://www.huaweicloud.com/product/cdn.html">华为云CDN</a></p><p>老规矩，又是我的一己私利，个人放着推荐</p></li></ol><h3 id="阿里云-DCDN-使用指南"><a href="#阿里云-DCDN-使用指南" class="headerlink" title="阿里云 DCDN 使用指南"></a>阿里云 DCDN 使用指南</h3><p>如果你足够细心，会发现这里变成了DCDN，是我打错了吗？NO，CDN的变种：CDN、SCDN、DCDN。具体区别：可以参考这个文章<a href="https://www.vpsss.net/12947.html">SLB CDN SCDN DCDN区别在哪？如何选择？</a>。</p><blockquote><p>配置CDN前提，要有网站且已备案（国内）</p></blockquote><p>DCDN中文名称：全站加速，你可以理解为CDN的升级版，如此理解即可。</p><ol><li><p>首先<strong>访问<a href="https://dcdn.console.aliyun.com/?spm=5176.11785003.app_menu.5.6402142fYmRp9f#/overview">阿里云全站加速控制台</a></strong>，在<strong>右侧，域名数量处，选择【管理】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224201618935.png" alt="image-20220224201618935" style="zoom:67%;" /></p></li><li><p>在<strong>域名管理页面</strong>，<strong>选择【添加域名】</strong>，进入域名添加页面</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224201735577.png" alt="image-20220224201735577" style="zoom:80%;" /></p></li><li><p>进入<strong>添加域名</strong>页面，配置内容如下，添加完成后，<strong>【选择下一步】</strong></p><p><strong>加速域名</strong>：你要加速的域名，例如我希望别通过www.域名访问的时候CDN加速访问，就填www.域名</p><p><strong>资源分组</strong>：默认分组即可</p><p><strong>加速区域</strong>：中国内地即可</p><p><strong>源站信息</strong>：<strong>【点击新增源站信息】</strong>，根据弹出窗口内容提示填写，类型：我使用的IP：填写服务器的公网IP即可；没有多个服务器源站优先级：默认【主】即可；权重同理默认即可；<strong>端口需要注意一下：如果网站配置了SSL证书，就选择443端口，反之，则默认80端口即可</strong>（划重点）。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224204608796.png" alt="image-20220224204608796" style="zoom: 67%;" /></p></li><li><p>完成后弹出添加成功提醒，然后<strong>【点击 配置CNAME】</strong></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224205429744.png" alt="image-20220224205429744" style="zoom:67%;" /></p></li><li><p>然后在<strong>域名管理</strong>页面，查看创建的加速域名并复制其CNAME</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224205655913.png" alt="image-20220224205655913" style="zoom:150%;" /></p></li><li><p><strong>复制对应CNAME后，找到你购买域名时的服务商，进入域名解析页面设置</strong>，例如我使用的腾讯云的DNSPod；</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224210022432.png" alt="image-20220224210022432" style="zoom:80%;" /></p><blockquote><p>需要注意的是，添加解析的时候，需要先将原有的对应的 A 记录解析暂停或者删除，例如：我的加速域名是www.域名，而我之前存在对应的 www 记录的其他记录（一般是 A 记录），那么就需要将该记录暂停或者删除</p></blockquote></li><li><p><strong>【点击 添加记录后】</strong>，需要做以下修改填写，然后保存即可</p><p><strong>主机记录</strong>：添加你加速域名的主机记录，例如我加速的www.域名，则主机记录为<code>wwww</code></p><p><strong>记录类型</strong>：<strong>选择<code>CNAME</code>(必须是)</strong></p><p><strong>记录值</strong>：就是之前在阿里云DCDN控制台生成的<code>CNAME</code>值，复制粘贴进入即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224210347736.png" alt="image-20220224210347736" style="zoom:150%;" /></p><blockquote><p>需要注意的是修改DNS解析，因为TTL默认设置是600秒，即10分钟，所以有时候需要等待5-10分钟才会设置成功</p></blockquote></li><li><p>完成上述DNS解析配置后，返回DCDN控制台，<strong>稍微等待一下，刷新一下或者鼠标放在等待配置的叹号上，打开配置向导，手动检测CNAME配置状态</strong>。配置成功后如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224211104663.png" alt="image-20220224211104663" style="zoom: 67%;" /></p></li><li><p><strong>到这步，如果你的网站没有配置SSL就结束了</strong>。你<strong>可以使用Win系统的<code>CMD</code> <code>Ping</code>一下你的加速域名</strong>，<strong>如果返回的值不是你的公网IP而是一个含有<code>kunlun.com</code>的字符串就说明配置完成了</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224211412580.png" alt="image-20220224211412580" style="zoom:67%;" /></p></li><li><p><strong>如果你的网站部署了SSL，那么你需要注意的是：你的源站信息里的端口一定要是 443 之前强调过的。然后在左侧栏找到【HTTPS配置点击进入】</strong>，开启HTTPS安全加速</p><p><strong>HTTPS安全加速</strong>：开启的时候因为是收费的，所以会询问你是否开启，自行选择，如果不开启，则没必要看下去了</p><p><strong>证书来源</strong>：根据实际情况选择，我的证书是腾讯云免费申请的SSL证书，所以我选择的是自定义上传</p><p><strong>证书（公钥）/（私钥）</strong>：根据申请的SSL证书，找到相关文件，以<code>txt</code>格式打开，复制内容粘贴即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224211759797.png" alt="image-20220224211759797" style="zoom:67%;" /></p><p>HTTPS配置完成后，可以在强制跳转中选择，是否强制跳转访问方式，例如强制HTTPS访问。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220224212153850.png" alt="image-20220224212153850" style="zoom:67%;" /></p></li></ol><p>到现在，基本上DCDN基本配置完成了，剩下的就是根据需求设置和调整了。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>部分内容写的相对捡漏，还有一些后续的配置调试等没有细写，关于一些原理实现等也没有细写，主要是写下如何正确配置步骤，一来可以给新入门的伙伴帮助，二来给我自己记一份笔记，以备不时之需。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 对象存储 </tag>
            
            <tag> SSL </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于网站搭建那些事（上）</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>文章最后更新于 2021-11-19 21:01:31 星期五 ，部分内容可能与现在不符，请自行判断</p></blockquote><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前购买的服务器商说是要给我们提供长期免费的带宽和服务器，但是我感觉它要跑路了，再加上该服务器商数据的不稳定性，综合决定要网站搬迁，前排踩坑提醒（<strong>不要轻易购买零度空间的服务器或者其他产品</strong>）,当时购买的时候是看上了它的香港IP，这样我就可以免去国内备案的麻烦事。</p><p>如今不得不购买国内的相关服务器来进行网站搬迁，新网站域名 <a href="http://helloseraphine.top/">helloseraphine.top</a>,暂时还在备案中，无法通过域名访问,可以通过公网IP来访问 <a href="http://120.76.134.66/">120.76.134.66</a></p><p>目前服务器和数据库在阿里云，对象存储域名解析在腾讯云，年维护费用100左右（排除人工成本）</p><p>为了避免更多的小伙伴踩坑，写下个人博客网站建设教程来帮助后面的小伙伴</p><h1 id="网站基础知识"><a href="#网站基础知识" class="headerlink" title="网站基础知识"></a>网站基础知识</h1><p>在开始建站之前需要了解一些基础知识：</p><ol><li><strong>带宽：带宽可以通俗的理解为网速，即别人访问你的网站，你的网站能和它互动的网速</strong></li><li><strong>服务器：可以通俗理解为功能偏向于大规模计算应用方面的电脑，记住它也是电脑，不要觉得服务器和电脑差异很大</strong></li><li><strong>数据库：存储数据的地方，类似于Excel，但是功能强大与其，可以理解为加强强强强版Excel，其他感兴趣的去学习数据库基础</strong></li><li><strong>公网IP：只有公网IP才可以被外界直接访问到，平时用到的网络都是局域网，这也就是为什么计算机网络讨论IP不够用了，但是我们依旧用的很好，不够用是因为公网IP是有限的，其他的详细知识感兴趣去学习计算机网络</strong></li></ol><p>网站可以分为<strong>静态网站</strong>和<strong>动态网站</strong>两种，静态网站顾名思义是静态的，它一般是HTML直接静态加载，通俗来讲上面有什么内容就是什么内容，没有所谓的评论，登录，更新文章之类的，就是不存在后期部分内容更新的，当然要更新也可以，需要更新HTML文件，覆盖源文件来实现，成本最低，但是不能直接用作个人博客，这部分内容不涉及静态网站如果建设，后面会新开一个文章来说明</p><p>绝大部分情况下，我们所见到的网站都是动态网站，一个动态网站需要服务器，数据库和一个公网IP，服务器来存放网站文件和各种计算处理，数据库调用存储写入各种网站数据，公网IP是供外界访问。</p><h1 id="服务商选择"><a href="#服务商选择" class="headerlink" title="服务商选择"></a>服务商选择</h1><p>目前只建议三种选择：<strong>1.<a href="https://www.aliyun.com/">阿里云</a> 2.<a href="https://cloud.tencent.com/">腾讯云</a> 3.自己手动从硬件搭建</strong></p><p>其他选择例如：华为云，移动云等从长远和费用来考虑，建议不要轻易选择<br>该教程目前使用阿里云来示例建站，腾讯云同理，两者相同</p><h2 id="【1】产品选择以及购买"><a href="#【1】产品选择以及购买" class="headerlink" title="【1】产品选择以及购买"></a>【1】产品选择以及购买</h2><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211117204019.png" width="100%"><p>打开阿里云首页后，会有很多选择,目前仅推荐两个，云服务器ECS和轻量应用服务器，概念普及：</p><p><strong>云服务器ECS：标准的服务器，购买的价格相对较贵（有学生优惠，我记得是99/年），买的是一整个服务器实例</strong></p><p><strong>轻量应用服务器：轻量级，价格相对便宜（一般活动价格例如双十一也就60左右/年），买的是一个直接给搭建好镜像的系统，只能干些小事情，例建站等</strong></p><p>此处选择轻量应用服务器，轻量应用服务器建站优点：</p><ol><li>便宜，比云服务器便宜很多</li><li>快速上手，该产品已经提前按照我们购买的选择，搭建好了相关镜像，省去了云服务器需要手动搭建各种网站数据库等的环境</li><li>带宽高，性能相对好同价格下，对于轻量级应用服务器的带宽5M起步，而学生价的云服务器才1M</li></ol><blockquote><p>带宽计算规则，带宽/8=网速，例如1M/8约等于128kb的网速，这还只是理论速度</p></blockquote><p>然后，通过相关活动专场购买，例如现在的 <a href="https://www.aliyun.com/activity/1111/ecs?spm=5176.161059.J_5253785160.2.2c07a505OUI2nx">双十一服务器专场</a></p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-17_20-52-32.jpg" width="90%"><p>然后进入专场，选择对应的产品</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-17_20-56-13.jpg" width="90%"><p>地区选择距离自己目前所在地近一点的，当然默认的也可以，国内基本不影响</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-17_21-01-09.jpg" width="90%"><p>镜像可以选择，WordPress或者Typecho，两个都是博客框架，<strong>个人更加推荐WordPress</strong></p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-17_21-03-56.jpg" width="90%"><p>剩下的都是默认的就好，选择购买，支付，然后返回轻量应用服务器的控制台即可</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-17_21-07-56.jpg" width="90%"><h2 id="【2】轻量级服务器控制台"><a href="#【2】轻量级服务器控制台" class="headerlink" title="【2】轻量级服务器控制台"></a>【2】轻量级服务器控制台</h2><p>选择购买的轻量服务器，进入控制台管理页面.</p><p>在该页面可以看到服务器流量，内存，CPU情况，续费情况，服务器镜像，公网IP等等一系列重要的信息，其中最直接有用的信息是：</p><ul><li><strong>流量：每个月1000GB的流量，如果超出是会按量计费，不过对于个人博客这个流量足够足够用了</strong></li><li><strong>公网IP：这个是我们后面连接服务器，访问服务器的直接IP</strong></li></ul><p>如果是刚刚购买的轻量级服务器，那么域名部分，你是没有绑定的，你需要购买域名并解析域名到你的公网IP上。在国内建站还需要进行备案，<strong>国内除了服务器在香港地区的无须备案，其他都需要备案。</strong></p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_20-12-42.jpg" width="100%"><h2 id="【3】域名注册与解析"><a href="#【3】域名注册与解析" class="headerlink" title="【3】域名注册与解析"></a>【3】域名注册与解析</h2><p>首先需要解释一下什么是域名，为什么要域名。</p><ul><li>什么是域名？<br>例如：<a href="https://www.baidu.com/">baidu.com</a> 就是一个域名，<a href="https://www.bilibili.com/">bilibili.com</a> 也是一个域名</li><li>为什么要域名？<br>在一开始互联网通信，每个参与通信的电脑需要具备一个公网IP这样就可以被其他计算机访问到，网站的原理就是别人通过你的公网IP来访问你服务器（电脑）的网页文件，他访问你的网页实际上是从你服务器（电脑）上下载你的网页文件，然后在本地浏览器上解析显示来的。<br>在知道这些后，那么别人想要访问你的网站，就需要输入你的公网IP来直接访问，但是有一个问题，公网IP是一串无规律的数字，总不能让每个上网的人记住每一个网站的数字吧，这样的体验是灾难性的。为了解决这个问题，引入了一个中间服务器，在该服务器上专门记录了一列按照一定格式自定义的域名和一列对应的公网IP地址，这样人们访问网站的时候只需要记住相对好记的域名，而后面的工作则是计算机访问DNS来获取公网IP，然后浏览器再通过公网IP来访问网站。只不过这些都在后台被计算机隐藏了，让用户更加专注于网上冲浪。</li></ul><p><strong>域名注册，就是自定义域名的方法，而域名解析就是将你购买的域名映射到你的公网IP的过程。</strong></p><p>国内域名购买，目前综合考虑也是只在这里推荐两个：<strong><a href="https://dnspod.cloud.tencent.com/domain/buy">腾讯云域名注册</a> 或者 <a href="https://wanwang.aliyun.com/domain/yumingheji">阿里云域名注册</a></strong><br>此处举例：腾讯云域名注册</p><ol><li><p>首先进入<a href="https://dnspod.cloud.tencent.com/domain/buy">腾讯云域名注册</a>页面，例如：</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_20-34-58.jpg" width="100%"></li><li><p>然后将自己给自己网站起的域名输入并点击搜索，例如我现在起个名字叫：SDAUceshi,然后点击查询</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_20-37-56.jpg" width="100%"></li><li><p>然后在里面挑选价格和域名合适的，自己顺眼的也可以，加入购物车，支付，此处不做演示你可以很清楚的了解到，<strong>域名可以大致拆分为分为 <code>域名+后缀</code>，不过不要误解，域名是这个整合的整体，此处拆分是便于理解</strong></p></li><li><p>在域名注册（购买）完成后，进入域名控制台，可以看到你购买的域名</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_20-43-38.jpg" width="100%"></li><li><p>然后选择需要解析的域名，点击 <code>解析</code>，进入域名解析页面</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_20-48-05.jpg" width="100%"><p>上图中，红框部分是一开始默认存在的，蓝框部分我自己后来添加的解析，如果是刚刚购买的域名，则只有上面两个红框部分</p></li><li><p>添加解析，点击添加解析，弹出一行如下图:</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_20-52-03.jpg" width="100%"><p>主机记录，常见的值：</p></li></ol><ul><li><p><strong><code>www</code>：常见主机记录，将域名解析为 www.自定义域名.后缀</strong></p></li><li><p><strong><code>@</code>：直接解析主域名 自定义域名.后缀</strong></p></li><li><p><strong><code>mail</code>：将域名解析为 mail.自定义域名.后缀，通常用于邮件服务</strong></p></li><li><p><strong><code>*</code>：泛解析，匹配其他所有域名 *.自定义域名.后缀</strong><br>上面的综合来理解就是，在你输入域名访问的时候，如果你添加了www解析，那么你在输入www.自定义域名.后缀 就可以直接访问到你的网站，而输入sss.自定义域名.后缀 就访问不了你的网站，因为你没有添加sss解析，同理@解析的意思是，你可以不输入前缀，例如我直接不输入www，直接输入自定义域名.后缀 也是可以解析到网站的，综上所述，以此类推<br>记录值为，你服务器的公网IP。<br>其余不了解一律默认即可<br>如果觉得自己不能自主选择解析方式，那么你可以就添加我的两种解析，如下如图：</p></li></ul><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-00-25.jpg" width="100%"><p>在添加完域名解析后，这样就完成了域名注册和解析，这个时候就可以通过域名来访问网站了，而不是通过输入一串难记的数字来访问，因为国内建站需要备案，所以还需要备案这一步，这一步暂时不做说明，自行百度或者看腾讯云/阿里云的相关文档</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-03-37.jpg" width="90%"><h2 id="【4】网站搭建"><a href="#【4】网站搭建" class="headerlink" title="【4】网站搭建"></a>【4】网站搭建</h2><p>现在回到轻量级应用服务器控制台，选择应用详情,按照阿里云给的提示一步一步走下去</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-08-11.jpg" width="80%"><p>其中重要的是三个地方，一个是镜像的账户密码，一个是数据库的账户密码，这两个可以根据阿里云的提示自行获取，如下图：</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-14-46.jpg" width="100%"><p>第三个重要的地方是在 服务器运维-&gt;远程连接，设置服务器SSH连接的密码</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-17-07.jpg" width="80%"><p>在完成上面的账户密码获取和设置后，我们需要做两个事情，第一个事情是访问服务器，即直接访问服务器的文件，这样我们可以完成对服务器的文件的删除上传等操作，第二个事情是访问数据库，这样我们可以对数据库后期操作，或者之前有网站的，通过将备份的数据导入数据库来实现网站搬迁。</p><h3 id="服务器远程连接"><a href="#服务器远程连接" class="headerlink" title="服务器远程连接"></a>服务器远程连接</h3><ol><li><p>我们需要一个软件，这里推荐 <strong><a href="https://winscp.net/eng/docs/lang:chs">WinSCP</a></strong> ,选择自己的系统平台，下载，安装。运行后是这个样子：</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-29-52.jpg" width="100%"></li><li><p>输入对应的账户密码后点击登录</p><p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-31-26.jpg" width="40%"></p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-32-14.jpg" width="90%"></li><li><p>找到我之前说的网站目录文件位置，这就是你的网站根目录，后期你需要在网站调试，插件上传，附件操作，模板上传等等一系列文件操作都需要先找到网站目录，即网站在服务器中的位置</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-34-41.jpg" width="90%"><p>好的，现在实现了对服务器的远程连接，后续可以通过这个方法来实现对服务器文件的操作</p></li></ol><h3 id="数据库远程连接"><a href="#数据库远程连接" class="headerlink" title="数据库远程连接"></a>数据库远程连接</h3><p>一般来说，如果你是第一次建站，是不需要进行这一步的，因为在你建站完成的时候，数据库自动和网站建立连接了，无须你手动调试或者更改，但是如果你需要导入你之前网站的数据，则需要连接数据库，对数据库进行操作。如果第一次建站可以忽略这一步，或者后面需要连接数据库再回来看该方法。</p><ol><li>连接数据库，我们也需要一个软件，这里推荐 <strong><a href="https://www.navicat.com.cn/">Navicat</a></strong>,下载，安装，运行后如下图：</li></ol><blockquote><p>注：该软件收费，所以自行下载破解版，破解教程自行百度</p></blockquote><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-45-21.jpg" width="100%"><ol><li><p>现在来新建一个MySQL连接，选择如图：</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-47-35.jpg" width="30%"></li><li><p>点击新建MySql连接后，如下图：</p><image src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-18_21-50-57.jpg" width="70%" ></li></ol><ul><li>连接名：可以随意起，起一个能让你知道这个连接是连接哪个数据库的名称</li><li>主机：可以使用默认的 <code>localhost</code> ，也可以使用前面阿里云给的数据库地址 <code>127.0.0.1</code> ，注意，阿里云提供的地址，加上了端口，即有个 <code>:3306</code>，</li></ul><blockquote><p>localhost 和 <code>127.0.0.1</code> 都是表示本地数据库的地址，两者不同在于localhost不会进过网卡，而127.0.0.1会经过网卡，再回到本地数据库</p></blockquote><ul><li>端口：使用默认的3306即可</li><li><p>用户名：就是你数据库的用户名</p></li><li><p>密码：数据库的密码</p></li></ul><p>1.然后选择SSH，进入SSH配置页面</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-19_20-38-38.jpg" width="70%" style="zoom:50%;" ></p><ul><li><strong>主机：即轻量级应用服务器的公网IP地址</strong></li><li>端口：使用默认的22</li><li>用户名&amp;密码：就是你设置的用户名和密码</li></ul><p>2.然后测试连接，弹出连接成功，则完成数据库的远程连接，剩下就是数据库的操作不做说明<br><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/Seraphine_All/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E9%82%A3%E4%BA%9B%E4%BA%8B/Snipaste_2021-11-19_20-47-57.jpg" width="50%"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过上面的操作，就对轻量级应用服务器的连接操作和基本配置完成了。</p><p>对于一般的网站来说，网页内容和网站框架是分开来存放的，举一个简单的例子，网站的基础框架是放在我们的 <code>www</code> 根目录下的，但是我们在网站上面的发布的博客文章和相关的图片，文件等一般情况下是要放在另一个地方。这样可以让功能分离，也不会要求网站服务器的带宽过高。</p><p>对于附件，文件，图片等的存放地址，网站一般会额外购买对象存储来满足带宽，管理等的综合要求。</p><p>关于对象存储，博客框架的调试等，我会再出一个教程来说明。</p><blockquote><p><a href="https://helloseraphine.top/index.php/archives/487.html">关于网站搭建那些事（下）</a>已更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则表达式是去年夏天我就想说明的东西了，不过一直鸽到现在，这部分将会记录正则表达式的基本语法以及一个C#应用实例。</p><p>关于正则表达式学习个人的相关推荐：</p><ul><li><a href="https://github.com/ziishaned/learn-regex">learn-regex</a></li><li><a href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 - 教程</a></li><li><a href="https://www.bilibili.com/video/BV1da4y1p7iZ">10分钟快速掌握正则表达式</a></li></ul><p>关于正则表达式测试的网站：</p><ul><li><a href="https://regexr.com/">RegExr</a></li><li><a href="https://regex101.com/">Regulex</a></li></ul><p>关于正则表达式在线生成工具（1/2不表示排名）：</p><ul><li><a href="http://tools.jb51.net/regex/create_reg">正则表达式在线生成工具1</a></li><li><a href="https://tool.chinaz.com/tools/regexgenerate">正则表达式在线生成工具2</a></li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>关于正则表达式百度百科的定义如下</p><p><strong>*正则表达式</strong>，又称规则表达式<strong>。</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），<a href="https://baike.baidu.com/item/计算机科学/9132">计算机科学</a>的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。*</p><p>通俗来说，就是我们常用的Word搜索功能的加强版，它可以通过特定的语法格式来实现文本搜索（匹配），来满足我们期望找到的文本。</p><blockquote><p> Regular expression（正则表达式）这个词比较拗口，常使用缩写的术语“regex”或“regexp”</p></blockquote><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p><strong>正则表达式的基本匹配是我们常规的搜索类型，即所见即所得</strong>，例如：输入<code>love</code>，则匹配到所有包含该字符的字符串。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227183506406.png" alt="image-20220227183506406" style="zoom: 80%;" /></p><p><strong>正则表达式是大小写敏感的</strong>，所以，如果输入<code>Love</code>，它不会匹配上图结果</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227183634232.png" alt="image-20220227183634232" style="zoom:80%;" /></p><blockquote><p>关于图中在输入表达式前面<code>/</code>符号的意义，后面会解释，默认我们输入正则表达式的格式为<code>/这里是我们输入的正则表达式/g</code>。</p></blockquote><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式由元字符构成。元字符可以理解为正则表达式控制查找字符串规则的字符，它们具有一定的含义，类似于代码中<code>if</code>表示的是如果的意思。关于一些常规元字符的解释：</p><div class="table-container"><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td><code>[]</code></td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td><code>[^]</code></td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td><code>*</code></td><td>匹配 $\geq 0$个重复的在<code>*</code>号之前的字符。</td></tr><tr><td><code>+</code></td><td>匹配 $\geq 1$个重复的<code>+</code>号前的字符。</td></tr><tr><td><code>?</code></td><td>标记<code>?</code>之前的字符为可选.</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配 num个大括号之前的字符或字符集 ( $n \leq num \leq m$ ).</td></tr><tr><td><code>(xyz)</code></td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>`</td><td>`</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td><code>\</code></td><td>转义字符，用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td><td>`</td></tr><tr><td><code>^</code></td><td>从开始行开始匹配.</td></tr><tr><td><code>$</code></td><td>从末端开始匹配.</td></tr></tbody></table></div><h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符."></a>点运算符<code>.</code></h3><p><strong><code>.</code>运算符是一个任意字符的占位符（除换行符）</strong>，例如：<code>.ve</code>表示匹配三个字符（<code>.</code>表示任意字符的占位符），以任意字符开头的且后面跟着<code>ve</code>字符的字符。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227185302789.png" alt="image-20220227185302789" style="zoom:80%;" /></p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集表示的是字符的集合，它通过使用方括号(<code>[]</code>)来表示一个字符集。通过在<code>[]</code>中输入字符来表示匹配字符范围，需要注意的是：方括号中不关心其字符顺序，例如：<code>[a-z]</code>表示的意思是匹配字符集中小写字母<code>a</code>到<code>z</code>的所有字符。如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227185650629.png" alt="image-20220227185650629" style="zoom:80%;" /></p><p><code>-</code>表示两者的区间，同样的你也可以使用<code>[A-Z]</code>表示所有大写字母<code>A</code>到<code>z</code>的所有字符，或者<code>[0-9]</code>表示所有数值。再例如：<code>[Ll]ove</code>，表示的匹配<code>Love</code>或者<code>love</code>字符，因为<code>l</code>和<code>L</code>字符在字符集中，所以结果：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227185956260.png" alt="image-20220227185956260" style="zoom:80%;" /></p><h3 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h3><p>否定字符集的意思可以通过<code>^</code>来表示不包含字符集中某些字符，例如：<code>[^L]ove</code>表示的意思是不匹配以大写字符<code>L</code>开头且其后跟着字符<code>ove</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227190249907.png" alt="image-20220227190249907" style="zoom:80%;" /></p><blockquote><p>需要注意的是字符<code>^</code>如果包含在字符集<code>[]</code>中，则其含义是不同的，例如：<code>[^L]</code>和<code>^L</code>的含义是不同的。</p></blockquote><h3 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h3><p>元字符<code>*</code>，<code>?</code>，<code>+</code>表示的是对字符出现次数的限制。</p><ul><li><p><strong>元字符<code>*</code></strong></p><p><strong><code>*</code>表示的是匹配在<code>*</code>号之前的字符的出现次数大于等于0次的字符</strong>。例如：<code>a*love</code>表示的意思匹配所有<code>a</code>字符开头且其出现次数大于等于0次，且后面跟着<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227191311560.png" alt="image-20220227191311560" style="zoom:80%;" /></p></li><li><p><strong>元字符<code>+</code></strong></p><p><strong><code>+</code>表示的是匹配在<code>+</code>号之前的字符出现次数大于或者等于1次的字符</strong>。例如：<code>a+love</code>表示的意思是匹配所有以<code>a</code>字符开头的且<code>a</code>字符的出现次数大于等于1次，且后面跟着<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227192149840.png" alt="image-20220227192149840" style="zoom:80%;" /></p></li><li><p><strong>元字符<code>?</code></strong></p><p><strong><code>?</code>表示的是匹配在<code>?</code>之前的字符出现的次数为 1 次或者 0 次的字符</strong>。例如：<code>a?love</code>表示的意思是匹配所有以字符<code>a</code>出现次数为 0 或者 1 次开头的，且其后面跟随<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227192412963.png" alt="image-20220227192412963" style="zoom:80%;" /></p></li></ul><h3 id=""><a href="#" class="headerlink" title="{}"></a><code>&#123;&#125;</code></h3><p><strong><code>&#123;&#125;</code>表示的是匹配其前面字符指定的出现次数</strong>。例如：<code>a&#123;1,2&#125;love</code>表示的意思是匹配以<code>a</code>字符开始的且<code>a</code>字符的出现次数为 1 次或者 2次的，且其后面跟着<code>love</code>字符的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227192708702.png" alt="image-20220227192708702" style="zoom:80%;" /></p><h3 id="特征标记群"><a href="#特征标记群" class="headerlink" title="(...)特征标记群"></a><code>(...)</code>特征标记群</h3><p><strong><code>()</code>表示的是在<code>()</code>里的字符是一个组合</strong>。这样描述不是很直观，如上述示例：<code>a&#123;1,2&#125;love</code>，表示的<code>a</code>字符的出现次数是 1 次或者 2次，但是如果我们希望<code>ab</code>字符出现的次数是 1 次或者 2次就会很棘手，或许有的伙伴认为可以这样：<code>a&#123;1,2&#125;b&#123;1,2&#125;love</code>，示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227193247291.png" alt="image-20220227193247291" style="zoom:80%;" /></p><p>实际上，可以看到第三行的字符<code>abablove</code>也是我们想要匹配的字符，而不是第四行的<code>aabblove</code>字符。这个时候就需要使用特征标记群，例如：<code>(ab)&#123;1,2&#125;love</code>，表示的意思是以字符群<code>ab</code>开始的且其出现次数为 1 次或者 2 次，且其后面跟着字符<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227193510915.png" alt="image-20220227193510915" style="zoom:80%;" /></p><h3 id="或运算符"><a href="#或运算符" class="headerlink" title="|或运算符"></a><code>|</code>或运算符</h3><p>同一般的计算机语言，<strong><code>|</code>表示或者</strong>。例如：<code>(L|l)ove</code>表示匹配以<code>L</code>或者<code>l</code>开头的，且其后跟着<code>ove</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227193812583.png" alt="image-20220227193812583" style="zoom:80%;" /></p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>有的时候我们希望匹配的特殊字符是正则表达式的元字符之类的字符，例如我们希望匹配<code>.</code>字符，如果不使用转义字符，则默认被识别为正则表达式的<code>.</code>元字符来处理。所以<strong>我们需要使用<code>\</code>来表示转义字符，其后面跟的字符表示转义我们要使用的字符</strong>。例如：<code>\.love</code>表示匹配以<code>.</code>开始且后跟着<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227194152045.png" alt="image-20220227194152045" style="zoom:80%;" /></p><p>同理，其他字符也是，例如：<code>\[</code>表示匹配字符<code>[</code>，<code>\+</code>表示匹配字符<code>+</code>等等。</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p><strong>如果我们希望专门匹配一段文字的开头和末尾的特定字符就离不开锚点</strong>。</p><ul><li><p><strong><code>^</code>开头锚点</strong></p><p><code>^</code>表示开头锚点。例如：<code>^(T|l)ove</code>表示匹配在一段文字的开头其字符为<code>Love</code>或者<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227194902124.png" alt="image-20220227194902124" style="zoom:80%;" /></p><p>需要注意的是<strong>锚点，在不改变匹配规则的情况下，默认只匹配一段文字的开头和末尾字符串</strong>。例如下图，即使第一个字符不匹配，也不会匹配到第二个字符</p><blockquote><p>关于什么是匹配规则，下面的部分会说明</p></blockquote><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227195118609.png" alt="image-20220227195118609" style="zoom:80%;" /></p></li><li><p><strong><code>$</code>结尾锚点</strong></p><p>结尾锚点也同理，<strong>只匹配$$`前面字符与一段文字的最后一个字符串比较</strong>。例如：<code>love$$，表示匹配一段位置最后一个字符串是否包含</code>love`字符。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227195516194.png" alt="image-20220227195516194" style="zoom:80%;" /></p></li></ul><h3 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h3><p>对于一些常用的字符集，例如<code>[a-z]</code>，<code>[A-Z]</code>，<code>[0-9]</code>等字符集，官方做了整合，使用如下简单字符表达式来表示该公式：</p><div class="table-container"><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>除换行符外的所有字符</td></tr><tr><td><code>\w</code></td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td><code>\d</code></td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td><code>\s</code></td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td><code>\S</code></td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td><code>\f</code></td><td>匹配一个换页符</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符</td></tr><tr><td><code>\p</code></td><td>匹配 CRLF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table></div><h2 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h2><p>关于零宽断言的定义，如下斜体引用自百度百科：</p><p><em>零宽断言是<a href="https://baike.baidu.com/item/正则表达式/1700215">正则表达式</a>中的一种方法，正则表达式在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</em></p><p><strong>我个人理解为是一种筛选字符串的规则，当我们规则某个字符出现为真或者假时则执行的正则表达式取值，类似于将基本的真假判断分支不同处理结果，根据结果引入字符筛选的正则表达式</strong>。</p><p><strong>它是另一种形式的占位符，是一种条件零宽度占位符，所谓零宽度是指的是返回的结果中不包含该断言内容</strong>，例如：<code>(?&lt;=\$)[0-9\.]*</code>表示的意思是：判断字符的开头是否存在字符<code>$</code>，且其后面含有 0 到 9 的，且最后跟着字符<code>.</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227201637426.png" alt="image-20220227201637426" style="zoom:80%;" /></p><p>如上示例使用的是 正后发断言，关于零宽度断言的分类：</p><div class="table-container"><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td><code>?=</code></td><td>正先行断言-存在</td></tr><tr><td><code>?!</code></td><td>负先行断言-排除</td></tr><tr><td><code>?&lt;=</code></td><td>正后发断言-存在</td></tr><tr><td><code>?&lt;!</code></td><td>负后发断言-排除</td></tr></tbody></table></div><h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=...正先行断言"></a><code>?=...</code>正先行断言</h3><p><strong><code>?=</code>正先行断言，表示第一部分表达式之后必须跟着<code>?=</code>定义的表达式。返回结果只包含满足条件的第一部分表达式匹配的内容，定义正先行断言需要使用<code>()</code></strong>。例如：<code>love(?=\.)</code>表示满足字符<code>love</code>后面存在字符<code>.</code>匹配的字符串，其匹配字符串不包含正先行断言中的内容，即<code>.</code>。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227203020352.png" alt="image-20220227203020352" style="zoom:80%;" /></p><h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!...负先行断言"></a><code>?!...</code>负先行断言</h3><p><strong><code>?!</code>负先行断言，使用格式参考正先行断言，其作用是匹配不包含负先行断言的内容</strong>，理解为正先行断言的取反。例如：<code>love(?!\.)</code>，表示的意思是匹配不包含字符<code>.</code>的，且其前面的字符为<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227203520175.png" alt="image-20220227203520175" style="zoom:80%;" /></p><h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;=...正后发断言"></a><code>?&lt;=...</code>正后发断言</h3><p><strong><code>?&lt;=</code>正后发断言，与正先行断言的区别是匹配的正则表达式要在断言的后面</strong>，例如：<code>(?&lt;=\.)love</code>表示的意思是匹配目标字符串前面存在字符<code>.</code>且包含<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227203942318.png" alt="image-20220227203942318" style="zoom:80%;" /></p><h3 id="lt-！-负后发断言"><a href="#lt-！-负后发断言" class="headerlink" title="?&lt;！...负后发断言"></a><code>?&lt;！...</code>负后发断言</h3><p><strong><code>?&lt;！</code>正后发断言，与负先行断言的区别是匹配的正则表达式要在断言的后面</strong>，例如：<code>(?&lt;!\.)love</code>表示的意思匹配目标字符串前面不存在字符<code>.</code>且包含字符<code>love</code>的字符。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227204518557.png" alt="image-20220227204518557" style="zoom:80%;" /></p><blockquote><p>Lookarounds 是零宽度断言的英文</p></blockquote><h2 id="匹配规则（标志）"><a href="#匹配规则（标志）" class="headerlink" title="匹配规则（标志）"></a>匹配规则（标志）</h2><p><strong>匹配规则是一种匹配修正符，用来指控匹配的模式，它也是正则表达式的一部分</strong>。例如：</p><div class="table-container"><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>i</code></td><td>忽略大小写。</td></tr><tr><td><code>g</code></td><td>全局搜索。</td></tr><tr><td><code>m</code></td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table></div><p>实际完整的正则表达式的格式为：<code>/这里写正则表达式/匹配规则</code>，一般默认为<code>/我们在这里写正则表达式/g</code>。</p><p>当然实际上对于现在的正则表达式还有很多其他的匹配规则，例如下图，详细的请自行百度或者谷歌查询。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227210030517.png" alt="image-20220227210030517" style="zoom:67%;" /></p><h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><p>可以通过在匹配规则中添加<code>i</code>来表示匹配字符串时忽略大小写。例如：<code>/love/gi</code>表示匹配不区分大小的包含<code>love</code>的字符。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227205116064.png" alt="image-20220227205116064" style="zoom:80%;" /></p><blockquote><p><code>i</code>是 insensitive（不区分大小写）的缩写</p></blockquote><h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><p><code>g</code>表示匹配的返回结果是全部的匹配结果，而不是仅返回第一个匹配的字符。例如：<code>/love/</code>表示仅返回匹配的第一个字符。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227205525750.png" alt="image-20220227205525750" style="zoom:80%;" /></p><p>但是如果使用<code>/love/g</code>，则示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227205603931.png" alt="image-20220227205603931" style="zoom:80%;" /></p><blockquote><p><code>g</code>是 global 的缩写</p></blockquote><h3 id="多行修饰符"><a href="#多行修饰符" class="headerlink" title="多行修饰符"></a>多行修饰符</h3><p><code>m</code>是表示执行多行匹配，这么说可能不直观，如图前面说明的锚点，对于开头或者结尾锚点，仅仅匹配一段文字的最后或者末尾一个字符串，但是如果使用了<code>m</code>，即多行修饰符，则会进行多行的开头和结尾匹配。例如：<code>/^love/gm</code>表示的意思是匹配每一行的开头包含<code>love</code>的字符串。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227205915365.png" alt="image-20220227205915365" style="zoom:80%;" /></p><blockquote><p><code>m</code>是 muti line的缩写</p></blockquote><h2 id="贪婪匹配和惰性匹配（Greedy-vs-lazy-matching）"><a href="#贪婪匹配和惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="贪婪匹配和惰性匹配（Greedy vs lazy matching）"></a>贪婪匹配和惰性匹配（Greedy vs lazy matching）</h2><p>正则表达式默认使用贪婪匹配，即尽可能的匹配更长的字符串，可以通过使用<code>?</code>将贪婪匹配模式转换为惰性匹配模式。例如：<code>.*in</code>表示的意思是：匹配空字符字符出现 0 次或者更多次的且后面包含字符<code>in</code>的字符串，这也是正则表达式默认我贪婪匹配模式。示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227210739332.png" alt="image-20220227210739332" style="zoom:80%;" /></p><p>但是使用<code>.*?in</code>表示尽可能的匹配多段字符，示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227210841149.png" alt="image-20220227210841149" style="zoom:80%;" /></p><p>返回了两个字符段，而不是默认的一段长字符段。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227210900987.png" alt="image-20220227210900987" style="zoom:80%;" /></p><h1 id="正则表达式应用实例"><a href="#正则表达式应用实例" class="headerlink" title="正则表达式应用实例"></a>正则表达式应用实例</h1><p>本实例使用<code>C#</code>代码，基于 Winform 来实现。</p><p>实例内容：利用正则表达式来实现规定用户注册账户的时候，用户名仅限于英文字母和数字以及下划线的组合；而密码仅限于字母和数字的组合。</p><ol><li><p>使用 Winform 简单设计一个如下的注册窗口</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227211623290.png" alt="image-20220227211623290" style="zoom:80%;" /></p></li><li><p>然后在注册按钮的事件中，使用如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> pattern1 = <span class="string">@&quot;^\w+$&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> pattern2 = <span class="string">@&quot;^[A-Za-z0-9]+$&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (textBox1.Text == <span class="string">&quot;&quot;</span> || textBox2.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">&quot;请输入用户名或者密码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Regex.IsMatch(textBox1.Text, pattern1) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;用户名格式不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Regex.IsMatch(textBox2.Text, pattern2) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;密码格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当我们输入包含<code>?</code>字符的用户名时，则弹出错误提醒：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227214041819.png" alt="image-20220227214041819" style="zoom: 67%;" /></p></li><li><p>如果输入含有<code>?</code>字符的密码时，则弹出错误提醒：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227214144302.png" alt="image-20220227214144302" style="zoom:67%;" /></p></li><li><p>只有输入正确的用户名和密码格式，才会注册成功：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220227214245587.png" alt="image-20220227214245587" style="zoom:67%;" /></p></li></ol><h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><ul><li>数字：<strong><code>^[0-9]\*$</code></strong></li><li>n位的数字：<strong><code>^\d&#123;n&#125;$</code></strong></li><li>至少n位的数字：<strong><code>^\d&#123;n,&#125;$</code></strong></li><li>m-n位的数字：<strong><code>^\d&#123;m,n&#125;$</code></strong></li><li>零和非零开头的数字：<strong><code>^(0|[1-9][0-9]\*)$</code></strong></li><li>非零开头的最多带两位小数的数字：<strong><code>^([1-9][0-9]\*)+(\.[0-9]&#123;1,2&#125;)?$</code></strong></li><li>带1-2位小数的正数或负数：<strong><code>^(\-)?\d+(\.\d&#123;1,2&#125;)$</code></strong></li><li>正数、负数、和小数：<strong><code>^(\-|\+)?\d+(\.\d+)?$</code></strong></li><li>有两位小数的正实数：<strong><code>^[0-9]+(\.[0-9]&#123;2&#125;)?$</code></strong></li><li>有1~3位小数的正实数：<strong><code>^[0-9]+(\.[0-9]&#123;1,3&#125;)?$</code></strong></li><li>非零的正整数：<strong><code>^[1-9]\d\*$</code> 或 <code>^([1-9][0-9]\*)&#123;1,3&#125;$</code> 或 <code>^\+?[1-9][0-9]\*$</code></strong></li><li>非零的负整数：<strong><code>^\-[1-9][]0-9&quot;\*$</code> 或 <code>^-[1-9]\d\*$</code></strong></li><li>非负整数：<strong><code>^\d+$</code> 或 <code>^[1-9]\d\*|0$</code></strong></li><li>非正整数：<strong><code>^-[1-9]\d\*|0$</code> 或 <code>^((-\d+)|(0+))$</code></strong></li><li>非负浮点数：<strong><code>^\d+(\.\d+)?$</code> 或 <code>^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0$</code></strong></li><li>非正浮点数：<strong><code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code> 或 <code>^(-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*))|0?\.0+|0$</code></strong></li><li>正浮点数：<strong><code>^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*$</code> 或 <code>^(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*))$</code></strong></li><li>负浮点数：<strong><code>^-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*)$</code> 或 <code>^(-(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*)))$</code></strong></li><li>浮点数：<strong><code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0)$</code></strong></li></ul><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：<strong><code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></strong></li><li>英文和数字：<strong><code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]&#123;4,40&#125;$</code></strong></li><li>长度为3-20的所有字符：<strong><code>^.&#123;3,20&#125;$</code></strong></li><li>由26个英文字母组成的字符串：<strong><code>^[A-Za-z]+$</code></strong></li><li>由26个大写英文字母组成的字符串：<strong><code>^[A-Z]+$</code></strong></li><li>由26个小写英文字母组成的字符串：<strong><code>^[a-z]+$</code></strong></li><li>由数字和26个英文字母组成的字符串：<strong><code>^[A-Za-z0-9]+$</code></strong></li><li>由数字、26个英文字母或者下划线组成的字符串：<strong><code>^\w+$</code> 或 <code>^\w&#123;3,20&#125;$</code></strong></li><li>中文、英文、数字包括下划线：<strong><code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></strong></li><li>中文、英文、数字但不包括下划线等符号：<strong><code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</code></strong></li><li>可以输入含有^%&amp;’,;=? $\”等字符：<strong><code>[^%&amp;&#39;,;=?$\x22]+</code></strong></li><li>禁止输入含有~的字符：<strong><code>[^~\x22]+</code></strong></li></ul><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ul><li>Email地址：<strong><code>^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$</code></strong></li><li>域名：<strong><code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+\.?</code></strong></li><li>InternetURL：<strong><code>[a-zA-z]+://[^\s]\*</code> 或 <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]\*)?$</code></strong></li><li>手机号码：<strong><code>^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</code></strong></li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<strong><code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code></strong></li><li>国内电话号码(0511-4405222、021-87888822)：<strong><code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code></strong></li><li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: <strong><code>((\d&#123;11&#125;)|^((\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;)|(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;))$)</code></strong></li><li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：<strong><code>(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</code></strong></li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<strong><code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></strong></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<strong><code>^[a-zA-Z]\w&#123;5,17&#125;$</code></strong></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong><code>^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z])[a-zA-Z0-9]&#123;8,10&#125;$</code></strong></li><li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：<strong><code>^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).&#123;8,10&#125;$</code></strong></li><li>日期格式：<strong><code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code></strong></li><li>一年的12个月(01～09和1～12)：<strong><code>^(0?[1-9]|1[0-2])$</code></strong></li><li>一个月的31天(01～09和1～31)：<strong><code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></strong></li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<strong><code>^[1-9][0-9]\*$</code></strong></li><li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<strong><code>^(0|[1-9][0-9]\*)$</code></strong></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<strong><code>^(0|-?[1-9][0-9]\*)$</code></strong></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong><code>^[0-9]+(.[0-9]+)?$</code></strong></li><li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<strong><code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></strong></li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong><code>^[0-9]+(.[0-9]&#123;1,2&#125;)?$</code></strong></li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong><code>^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\*(.[0-9]&#123;1,2&#125;)?$</code></strong></li><li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<strong><code>^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\*)(.[0-9]&#123;1,2&#125;)?$</code></strong></li><li>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml文件：<strong><code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></strong></li><li>中文字符的正则表达式：<strong><code>[\u4e00-\u9fa5]</code></strong></li><li>双字节字符：<strong><code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</strong></li><li>空白行的正则表达式：<strong><code>\n\s\*\r</code> (可以用来删除空白行)</strong></li><li>HTML标记的正则表达式：<strong><code>&lt;(\S\*?)[^&gt;]\*&gt;.\*?|&lt;.\*? /&gt;</code> ( 首尾空白字符的正则表达式：<code>^\s\*|\s\*$或(^\s\*)|(\s\*$</code>) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</strong></li><li>腾讯QQ号：<strong><code>[1-9][0-9]&#123;4,&#125;</code> (腾讯QQ号从10000开始)</strong></li><li>中国邮政编码：<strong><code>[1-9]\d&#123;5&#125;(?!\d)</code> (中国邮政编码为6位数字)</strong></li><li>IPv4地址：<strong><code>((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;</code></strong></li></ul><blockquote><p>该常用正则表达式内容来源：<a href="https://c.runoob.com/front-end/854/">点击访问</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> Winform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex基础(上)</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/LaTex%E5%9F%BA%E7%A1%80(%E4%B8%8A)/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/LaTex%E5%9F%BA%E7%A1%80(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从MS Office 到 Markdown 再到 LaTex，每个不同的编辑软件都对不同的文本排列提供了一种解决方案</strong>，可以根据自己的实际需求来合理使用，我尝试记录最基本且简单的语法来说明<code>LaTex</code>的使用语法。</p><p><strong>我使用的 <code>LaTex</code> 编辑器为 <code>TexStudio</code>，<code>Tex</code>的宏包直接安装的 <code>Tex Live</code>。</strong></p><blockquote><p><strong>本文内容是我个人学习自 《简单高效LaTex》以及百度和Bilibili相关网站的学习内容整理笔记</strong></p></blockquote><h1 id="认识LaTex"><a href="#认识LaTex" class="headerlink" title="认识LaTex"></a>认识<code>LaTex</code></h1><blockquote><p>前排提醒：<code>LaTex</code>对大小写敏感，即区分大小写</p></blockquote><h2 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h2><p><strong><code>LaTex</code>中的命令通常是由一个反斜杠加上命令名称，再加上花括号内的参数构成</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br></pre></td></tr></table></figure><p><strong>如果一些选项是有其他可以缺省的参数，一般在花括号前使用<code>[]</code>来指定</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8](ctexart)</span><br></pre></td></tr></table></figure><p><strong>关于<code>LaTex</code>的正文部分，写在一个称为环境的部分</strong>，其格式类似于<code>HTML</code>的<code>body</code>，<strong>需要将内容写在其间</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;environment&#125;</span><br><span class="line">这里是你的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;environment&#125;</span><br></pre></td></tr></table></figure><h2 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h2><p><strong>在<code>LaTex</code>中，有一部分字符被用来作为命令字符，这些字符被称为<code>LaTex</code>的保留字符</strong>，例如下表</p><div class="table-container"><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td><code>#</code></td><td>自定义命令时，用于标明参数序号</td></tr><tr><td><code>$</code></td><td>用于编写数学公式标识符</td></tr><tr><td><code>%</code></td><td>注释符，可以通过在行末添加该注释符，来注释掉后面的空白符</td></tr><tr><td><code>^</code></td><td>数学公式中的上标符</td></tr><tr><td><code>_</code></td><td>数学公司中的下标符</td></tr><tr><td><code>&amp;</code></td><td>表格中的跳列符</td></tr><tr><td><code>&#123;&#125;</code></td><td>在一些命令中填写参数的标识</td></tr><tr><td><code>\</code></td><td>标识<code>LaTex</code>命令的标识符</td></tr></tbody></table></div><p>上述字符，<strong>如果在文中需要使用上述保留字符的话（除<code>\</code>反斜杠）需要在前面加上<code>\</code>，即反斜杠来标识，这样就能够使用该字符</strong>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%表示要使用 # 符号</span></span><br><span class="line"><span class="keyword">\#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%表示要使用 &amp; 符号</span></span><br><span class="line"><span class="keyword">\&amp;</span></span><br></pre></td></tr></table></figure><p>如果想要使用 <code>\</code>（反斜杠）的话，需要使用如下示例命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%表示使用 \ 符号</span></span><br><span class="line"><span class="keyword">\texttt</span>&#123;<span class="keyword">\char</span>92&#125;</span><br></pre></td></tr></table></figure><p><code>\texttt</code>是使用 <code>tt</code> 字体环境，用于输出ASCII码对应的字符，<code>\char92</code>指定的是反斜杠字符，同样的可以使用：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\char</span>`<span class="keyword">\\</span></span><br></pre></td></tr></table></figure><p>来输出<code>\</code>反斜杠。</p><h2 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h2><p>对于任何一份<code>LaTex</code>文档都应该含有如下结构：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[options]&#123;doc-class&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;environment&#125;</span><br><span class="line">你的内容部分</span><br><span class="line"><span class="keyword">\end</span>&#123;environment&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>在<code>\begin&#123;environment&#125;</code>之前的内容被称为导言区。导言区用来对文档进行一些设定，可以通俗理解为调控文档模板的地方</strong>。关于上述<code>options</code>和<code>doc-class</code>的参数如下表：</p><div class="table-container"><table><thead><tr><th>doc-class参数</th><th>说明</th></tr></thead><tbody><tr><td><code>article</code></td><td>科学期刊，演示文档，短报告，邀请函等</td></tr><tr><td><code>proc</code></td><td>基于<code>article</code>的会议论文集</td></tr><tr><td><code>report</code></td><td>多章节的长报告，博士论文，短篇书</td></tr><tr><td><code>book</code></td><td>书籍</td></tr><tr><td><code>slides</code>或<code>beamer</code></td><td>幻灯片</td></tr></tbody></table></div><p><strong>一般来说，对于纯英文的文档，推荐直接使用<code>article</code>，如果是含有中文的文档，则使用<code>ctexart</code>，并且要在前面的缺省参数标明指定的中文编码，例如<code>UTF-8</code>，</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文中所有命令都是在，<code>ctexart</code>格式下进行的，即上述命令示例</p></blockquote><div class="table-container"><table><thead><tr><th>options参数</th><th>说明</th></tr></thead><tbody><tr><td>默认<code>10pt</code>，可选则<code>11pt</code>和<code>12pt</code></td><td>字体大小</td></tr><tr><td>默认<code>portrait</code>（纵向），<code>landscape</code>（横向）</td><td>页面方向</td></tr><tr><td>默认<code>letterpaper</code>，可选<code>a4paper</code>，<code>b5paper</code>等</td><td>纸张大小</td></tr><tr><td>默认<code>onecolumn</code>（单栏），可选<code>twocolumn</code>（两栏）</td><td>分栏</td></tr><tr><td><code>article</code>和<code>report</code>默认单面，可选<code>oneside</code>和<code>twoside</code></td><td>双面打印</td></tr><tr><td>默认任意页，可选<code>openright</code>和<code>openany</code>，决定在奇数页或者任意页开启新页。<br />需要注意的是，<code>article</code>是没有<code>chapter</code>(章)命令的。</td><td>章节分页</td></tr><tr><td>默认居中，可选<code>fleqn</code>（左对齐）<br />默认编号居右，可选<code>leqno</code>（左对齐）</td><td>公式对齐</td></tr><tr><td>默认<code>final</code>，可选<code>draft</code>（使行溢出部分显示为黑块）</td><td>草稿选项</td></tr></tbody></table></div><p><strong>在导言区最常见的是宏包的加载工作，命令形如<code>\usepackage&#123;package&#125;</code></strong>。关于什么是宏包，通俗来说就是提前封装好的一些功能格式，对于一些非原生<code>LaTex</code>的功能格式，可以通过借用第三方宏包的方式来使用，提高效率。</p><blockquote><p>关于宏包文档的查看，可以通过打开Windows系统的<code>CMD</code>，然后输出<code>texdoc+宏包名称</code>就可以查看对应宏包的说明文档，部分文档是汉化的，所以可以任意阅读</p></blockquote><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p><strong>一般情况下，推荐输出<code>pdf</code>格式</strong>，由<code>LaTex</code>直接生成的<code>dvi</code>格式并不推荐。</p><p>你或许会在<code>tex</code>文档的文件夹下看到如下格式类型的文件：</p><ul><li><code>.sty</code>：宏包文件</li><li><code>.cls</code>：文档类文件</li><li><code>.aux</code>：用于存储交叉引用信息的文件，因此，在更新交叉引用（公式编号，大纲级别）后，需要编译两次才能正常显示。</li><li><code>.log</code>：日志，记录上次的编译信息。</li><li><code>.toc</code>：目录文件。</li><li><code>.lof</code>：图形目录</li><li><code>.lot</code>：表格目录</li><li><code>.idx</code>：如果文档中包含索引，该文件用于存储索引信息</li><li><code>.ind</code>：索引记录文件</li><li><code>.ilg</code>：索引日志文件</li><li><code>.bib</code>：<code>BIBTEX</code>参考文献数据文件</li><li><code>.bbl</code>：生成的参考文献记录</li><li><code>.bst</code>：<code>BIBTEX</code>模板</li><li><code>.blg</code>：<code>BIBTEX</code>日志</li><li><code>.out</code>：<code>hyperref</code>宏包生成的<code>pdf</code>书签记录</li></ul><p>例如，我使用的示例<code>tex</code>文档下的文件内容：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220306204837996.png" alt="image-20220306204837996" style="zoom:67%;" /></p><p><strong>有时<code>LaTex</code>编译出现异常时，可以通过删除除了<code>tex</code>文件外的文件再编译</strong>。</p><blockquote><p>还需要注意的时，有时候其他程序占用了以上文件也会出现错误。</p></blockquote><h1 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h1><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p><strong>英文单引号并不是两个<code>&#39;</code>（单引号）符号的组合，而是由左单引号<code>ˋ</code>和右单引号<code>&#39;</code>来实现英文单引号</strong>，示例命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是两个单引号`&#x27;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染结果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220306211513687.png" alt="image-20220306211513687" style="zoom:80%;" /></p><p>如果我们直接使用英文两个<code>&#39;</code>单引号，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是两个单引号&#x27;&#x27;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染结果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220306212022453.png" alt="image-20220306212022453" style="zoom:80%;" /></p><p>同样的，<strong>使用英文双引号，也需要分开左双引号，即两个<code>ˋˋ</code>，然后两个右双引号<code>&#39;&#39;</code></strong>即可。<strong>中文符号的引号直接使用中文即可</strong>。</p><h2 id="短横，省略号与破折号"><a href="#短横，省略号与破折号" class="headerlink" title="短横，省略号与破折号"></a>短横，省略号与破折号</h2><p>英文的短横分为三种：</p><ul><li><strong>连字符：输入一个短横<code>-</code></strong></li><li><strong>数字起止符：输入两个短横<code>--</code></strong></li><li><strong>破折号：输入三个短横<code>---</code></strong></li></ul><p>【渲染效果】<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220306213543194.png" alt="image-20220306213543194" style="zoom:80%;" /></p><p>中文的字符都可以正常使用。<strong>需要注意的是，英文的省略号需要使用<code>\ldots</code>命令</strong>。</p><h2 id="强调：粗体与斜体"><a href="#强调：粗体与斜体" class="headerlink" title="强调：粗体与斜体"></a>强调：粗体与斜体</h2><p><code>LaTex</code>中有个命令<code>\emph&#123;text&#125;</code>，可以强调文本。对于一般的英文字体来说，这个命令的结果是斜体，而如果输入中文，则不会触发斜体，只是给中文应用了某个细字体，例如：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220306214147619.png" alt="image-20220306214147619" style="zoom: 67%;" /></p><p><strong>对于英文来说，是采用斜体的方式进行强调，而不是中文惯用的粗体</strong>。</p><h2 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h2><p><code>LaTex</code>原生提供的下划线命令是<code>\underline</code>，不过原生提供的下划线风评不是很好，可以使用<code>ulem</code>宏包提供的下划线，如下是两个下划线的比较示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220306215057754.png" alt="image-20220306215057754" style="zoom:80%;" /></p><p>同样的<code>ulem</code>宏包还提供了一些其他的命令，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\uline</span>&#123;下划线&#125;</span><br><span class="line"><span class="keyword">\uuline</span>&#123;双下划线&#125;</span><br><span class="line"><span class="keyword">\uwave</span>&#123;下波浪线&#125;</span><br><span class="line"><span class="keyword">\sout</span>&#123;删除线&#125;</span><br><span class="line"><span class="keyword">\xout</span>&#123;删除封禁线&#125;</span><br><span class="line"><span class="keyword">\dashuline</span>&#123;下虚划线&#125;</span><br><span class="line"><span class="keyword">\dotuline</span>&#123;下点线&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220307083136655.png" alt="image-20220307083136655" style="zoom:67%;" /></p><blockquote><p><strong>如果希望<code>LaTex</code>开头不自动缩进的话，可以在开头输入<code>\noindent</code>，来表示首行不缩进</strong></p></blockquote><p>需要注意的是<code>ulem</code>宏包对<code>\emph&#123;text&#125;</code>进行了重定义，之前使用<code>\emph</code>命令会产生斜体，<strong>使用<code>ulem</code>宏包后，它重定义的效果是产生下划线而不是斜体，如果希望取消这个重定义，则在引入宏包的导言区输入如下命令参数</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[normalem]&#123;ulem&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于数学公式，化学公式等，如果你使用过Markdown则会更熟悉，需要使用<script type="math/tex">这里是你的公式内容</script>来包裹你的公式来表示这里要渲染公式。例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 数学公式</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2-2&#125;&#123;x<span class="built_in">^</span>3&#125;+3=y<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 化学苯环</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\chemfig</span>&#123;*6(-=-=-=)&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220307084339540.png" alt="image-20220307084339540" style="zoom: 67%;" /></p><p>关于输出<code>Tex</code>家族标志，可以使用原生命令，例如<code>\LaTex</code>，<code>\Tex</code>等 </p><p>【渲染输出】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220307085001047.png" alt="image-20220307085001047" style="zoom:50%;" /></p><h1 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h1><p>关于<code>LaTex</code>的长度单位：</p><ul><li><strong>pt(point)</strong>：磅</li><li><strong>pc(pica)</strong>：1pc=12pt，四号字</li><li><strong>in(inch)</strong>：英寸，1 in=72.27 pt</li><li><strong>bp(bigpoint)</strong>：大点，1 bp = $\frac{1}{72}$ in</li><li><strong>cm(centimeter)</strong>：厘米，1 cm = $\frac{1}{2.54}$ in</li><li><strong>mm(millimeter)</strong>：毫米，1 mm = $\frac{1}{10}$ cm</li><li><strong>sp(scaled point)</strong>：<code>Tex</code>的基本长度单位，1 sp=$\frac{1}{65536}$ pt</li><li><strong>em</strong>：当前字号下，大写字母 <code>M</code> 的宽度</li><li><strong>ex</strong>：当前字号下，小写字母 <code>x</code> 的高度</li></ul><p>如下是两个常用的长度宏，关于其他的长度宏后面的表格，分栏部分会做详细说明。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 页面上文字的总宽度，即页宽减去两侧边距</span></span><br><span class="line"><span class="keyword">\textwidth</span></span><br><span class="line"><span class="comment">% 当前行允许的行宽</span></span><br><span class="line"><span class="keyword">\linewidth</span></span><br></pre></td></tr></table></figure><h2 id="空格，换行与分段"><a href="#空格，换行与分段" class="headerlink" title="空格，换行与分段"></a>空格，换行与分段</h2><p>关于空格有多种表示方法，如下表格：</p><div class="table-container"><table><thead><tr><th>说明</th><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>两个<code>quad</code>宽度</td><td><code>\qquad</code></td><td>$a \qquad b$</td></tr><tr><td>一个<code>quad</code>宽度</td><td><code>\quad</code></td><td>$a \quad b$</td></tr><tr><td>大空格</td><td><code>\+空格</code></td><td>$a\ b$</td></tr><tr><td>中等空格</td><td><code>\;</code></td><td>$a\;b$</td></tr><tr><td>小空格</td><td><code>\,</code></td><td>$a\,b$</td></tr><tr><td>紧贴（即缩进距离）</td><td><code>\!</code></td><td>$a!b$</td></tr></tbody></table></div><p>换行的方法也非常简单，对于一般的长度来说，<code>LaTex</code>会自动换行，而<strong>如果希望手动换行，只需要在换行处输入两个回车即可完成分段</strong>。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span><span class="comment">%该命令表示开头无缩进</span></span><br><span class="line">测试测试测试测试测试测试测试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220308211214804.png" alt="image-20220308211214804" style="zoom:80%;" /></p><p>如果希望<strong>在两个段之间插入一个空白行，即空白段，则需要先输入两个回车，然后使用命令<code>\mbox&#123;&#125;</code>，最后再输入两个回车即可</strong>。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span></span><br><span class="line">测试测试测试测试测试测试测试</span><br><span class="line"></span><br><span class="line"><span class="keyword">\mbox</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220308211433101.png" alt="image-20220308211433101" style="zoom:80%;" /></p><p>同样的，<strong>也可以使用<code>\per</code>来生成一个带缩进的新段</strong>。</p><p><strong>关于强制换行的命令，即<code>\\</code>，这样会有一个缺点，即换行后的新段首行缩进会消失</strong>，这个命令一般不用在正文中换行。正常使用两个回车换行即可。</p><p>另外，宏包<code>lettrine</code>能够生成首字下沉的效果，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;lettrine&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span></span><br><span class="line"><span class="keyword">\lettrine</span>&#123;测&#125; 试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220308212304346.png" alt="image-20220308212304346" style="zoom:80%;" /></p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><strong>使用<code>\newpage</code>开始新的一页</strong>。</p><p>使用<code>\clearpage</code>命令清空浮动体队列，并开始新的一页。</p><blockquote><p>关于什么事浮动体队列，详情看后面</p></blockquote><p>使用<code>\cleardoublepage</code>情况浮动体队列，并在偶数页开始新的一页。</p><p>需要注意的是，上述命令是基于<code>vfill</code>的，<strong>所以如果需要连续新开两页，需要在中间加上一个空的箱子</strong>，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\newpage</span> <span class="keyword">\mbox</span>&#123;&#125; <span class="keyword">\newpage</span></span><br></pre></td></tr></table></figure><h2 id="缩进，对齐与行距"><a href="#缩进，对齐与行距" class="headerlink" title="缩进，对齐与行距"></a>缩进，对齐与行距</h2><p>关于首行缩进问题，在部分教程和书籍中表示<code>LaTex</code>对中文首行默认不缩进，需要借助宏包<code>indentfirst</code>来完成缩进，我测试过，在我的环境下，即 Win10，Tex Live 2022，Tex Studio 的情况下，已经支持中文默认缩进。<strong>关于取消首行缩进可以通过前面提到过的<code>\noindent</code>来实现</strong>。</p><p>关于其他更复杂的部分详细看后面。</p><h1 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h1><p>这部分只说明文中的字体使用，关于数学公式字体的使用详细看后面。</p><h2 id="字族，字系与字形"><a href="#字族，字系与字形" class="headerlink" title="字族，字系与字形"></a>字族，字系与字形</h2><p>宋体，黑体，楷体属于字族；对应到外文就是罗马体，等宽体等。加粗，加斜属于字系和字形，五号，小四号属于字号。这三者并称为字体。</p><h2 id="中西文“斜体”"><a href="#中西文“斜体”" class="headerlink" title="中西文“斜体”"></a>中西文“斜体”</h2><p>首先需要明确一点：<strong>汉字没有加斜体。平常看到的斜体汉字是通过几何变换得到的结果</strong>，对于排版来说，这种斜体是非常粗糙的，真正的字形是需要精细设计的。</p><p>西文中一般设有加斜，但与“斜体”并不是一回事。加斜是指某种字族的 <code>Italy</code> 字系；而斜体，是指<code>Slant</code>字族。</p><h2 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h2><p><code>LaTex</code>提供了基本的字体命令，如下表</p><div class="table-container"><table><thead><tr><th>字体</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>字族</td><td><code>\rmfamily</code></td><td>设置字体为<code>Roman</code>罗马字族</td></tr><tr><td></td><td><code>\sffamily</code></td><td>把字体设置为<code>Sans Serif</code>无衬线字族</td></tr><tr><td></td><td><code>\ttfamily</code></td><td>把字体设置为<code>Typewriter</code>等宽字族</td></tr><tr><td>字系</td><td><code>\bfseries</code></td><td>粗体<code>BoldSeries</code>字系属性</td></tr><tr><td></td><td><code>\mdseries</code></td><td>中粗体<code>MiddleSeries</code>字系属性</td></tr><tr><td>字形</td><td><code>\upshape</code></td><td>竖直<code>Upright</code>字形</td></tr><tr><td></td><td><code>\slshape</code></td><td>斜体<code>Slant</code>字形</td></tr><tr><td></td><td><code>\itshape</code></td><td>强调体<code>Italic</code>字形</td></tr><tr><td></td><td><code>\scshape</code></td><td>小号大写体<code>SCAP</code>字形</td></tr></tbody></table></div><p>然后就是<strong>关于字号的命令，<code>LaTex</code>给出了一系列“相对字号命令”</strong>，如下表所示，当然你也可以使用宏包<code>ctex</code>的相关字号命令来控制字号，详细文档说明可以使用控制台命令<code>texdoc ctex</code>即可查看。</p><div class="table-container"><table><thead><tr><th>符号</th><th>命令</th><th>符号</th><th>命令</th></tr></thead><tbody><tr><td>超超小</td><td><script type="math/tex">\tiny</script></td><td>其次小</td><td><script type="math/tex">\scriptsize</script></td></tr><tr><td>小一点</td><td><script type="math/tex">\small</script></td><td>默认大小</td><td><script type="math/tex">\normalsize</script></td></tr><tr><td>大一点</td><td><script type="math/tex">\large</script></td><td>大两点</td><td><script type="math/tex">\Large</script></td></tr><tr><td>大三点</td><td><script type="math/tex">\LARGR</script></td><td>巨大</td><td><script type="math/tex">\huge</script></td></tr><tr><td>巨巨大</td><td><script type="math/tex">\Huge</script></td><td></td></tr></tbody></table></div><h2 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h2><p>中文方面，<code>ctex</code>宏包直接定义了新的中文文档类<code>ctexart</code>，<code>ctexrep</code>与<code>ctexbook</code>，以及<code>ctexbeamer</code>幻灯文档类。</p><blockquote><p>关于中文支持方面的更多问题可以查看<code>ctex</code>文档说明</p></blockquote><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>使用<code>xcolor</code>宏包来方便的调用颜色，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\textcolor</span>&#123;red&#125;&#123;试测试测试测试&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309162354001.png" alt="image-20220309162354001" style="zoom:80%;" /></p><blockquote><p>关于更多的颜色说明可以参考宏包<code>xcolor</code>说明文档</p></blockquote><h1 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h1><p>电子文档最大的优点在于可以使用超链接，跳转标签和目录。这些功能的实现都需要“引用”。</p><h2 id="标签和引用"><a href="#标签和引用" class="headerlink" title="标签和引用"></a>标签和引用</h2><p><strong>使用<code>\label</code>命令插入标签（在MS Word中称为“题注”），然后在其他地方使用<code>\ref</code>或者<code>\pageref</code>命令进行引用。</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建标签</span></span><br><span class="line"><span class="keyword">\label</span>&#123;123&#125;</span><br><span class="line"><span class="comment">% 引用标签</span></span><br><span class="line"><span class="keyword">\ref</span>&#123;123&#125;</span><br></pre></td></tr></table></figure><p>另外有个宏包<code>amsmath</code>提供了相关引用的命令，可以自行查看。</p><h2 id="脚注，边注与尾注"><a href="#脚注，边注与尾注" class="headerlink" title="脚注，边注与尾注"></a>脚注，边注与尾注</h2><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是一种简单的标注，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一段测试文本<span class="keyword">\footnote</span>&#123;这是一段脚注&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309164253562.png" alt="image-20220309164253562" style="zoom:80%;" /></p><p><strong>在某些情况下（如表格），脚注无法正常使用，可以通过在需要插入脚注的位置插入命令<code>\footnotemark</code>，然后再在环境外使用<code>\footnotetext</code>来指明脚注内容</strong>，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是一段测试文本<span class="keyword">\footnotemark</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\footnotetext</span>&#123;这是一段脚注内容&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【渲染结果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309165118369.png" alt="image-20220309165118369" style="zoom:80%;" /></p><blockquote><p>行文中切记过多使用脚注，会分散读者的注意力</p></blockquote><h3 id="边注"><a href="#边注" class="headerlink" title="边注"></a>边注</h3><p><code>LaTex</code>的边注命令<code>\marginpar</code>不会进行编号，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 命令格式</span></span><br><span class="line"><span class="keyword">\marginpar</span>&#123;右侧注释内容&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令示例</span></span><br><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是一段测试文本<span class="keyword">\marginpar</span>&#123;这是右侧边注&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309165633332.png" alt="image-20220309165633332" style="zoom:95%;" /></p><h3 id="尾注"><a href="#尾注" class="headerlink" title="尾注"></a>尾注</h3><p>尾注用于注释比较长，无法使用脚注的场合，需要使用宏包<code>endnotes</code>。</p><h2 id="援引环境"><a href="#援引环境" class="headerlink" title="援引环境"></a>援引环境</h2><p><strong>普通的援引环境有<code>quote</code>和<code>quotation</code>两种。前者首行不缩进，后者首行缩进，且支持多段文字</strong>。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\noindent</span> 这是原文内容</span><br><span class="line"><span class="keyword">\begin</span>&#123;quote&#125;</span><br><span class="line">这是一段援引内容</span><br><span class="line"><span class="keyword">\end</span>&#123;quote&#125;</span><br><span class="line">这是后面的内容</span><br><span class="line"><span class="keyword">\begin</span>&#123;quotation&#125;</span><br><span class="line">这也是一段援引内容</span><br><span class="line"><span class="keyword">\end</span>&#123;quotation&#125;</span><br><span class="line">这也是后面的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309170310170.png" alt="image-20220309170310170" style="zoom: 67%;" /></p><p>另外一个诗歌援引环境叫<code>verse</code>，是悬挂缩进的，一般很少用。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>部分文档类环境支持摘要，如果使用摘要，这需要在<code>\maketitle</code>命令之后才可以使用<code>abstract</code>环境来完成摘要。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;这是文章标题&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line">这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。这部分是摘要。</span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br><span class="line"></span><br><span class="line">这是正文内容</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309172432967.png" alt="image-20220309172432967" style="zoom: 80%;" /></p><blockquote><p>需要注意的是命令要放在<code>document</code>环境内</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><strong>参考文献注意使用的命令是<code>\cite</code>。</strong></p><p>如果想要将参考文献章节正常编号，并加入到目录中，可以使用<code>tocbibind</code>宏包。</p><h1 id="正式排版：封面，大纲与目录"><a href="#正式排版：封面，大纲与目录" class="headerlink" title="正式排版：封面，大纲与目录"></a>正式排版：封面，大纲与目录</h1><h2 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h2><p>封面的内容在导言区进行定义，一般写在所有宏包，自定义命令之后，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;文章标题&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;作者名字&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;<span class="comment">%\today命令表示获取当前时间</span></span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309180826184.png" alt="image-20220309180826184" style="zoom:80%;" /></p><p><strong>然后在<code>document</code>环境内第一行写上<code>\maketitle</code></strong>，这样就形成了一个简易的封面。<strong>其中，<code>\title</code>和<code>author</code>是必须定义的</strong>。<code>\date</code>省略会自动编译当天的日期为准。<strong>如果不想显示日期，这使用<code>\data&#123;&#125;</code></strong>即可。</p><p>标题页的脚注用<code>\thanks</code>命令完成。</p><h2 id="大纲与章节"><a href="#大纲与章节" class="headerlink" title="大纲与章节"></a>大纲与章节</h2><p><code>LaTex</code>中，文档分为若干大纲级别，分别包括如下内容：</p><ul><li><strong><code>\part</code>：部分，这个大纲不会打段<code>chapter</code>的编号</strong></li><li><strong><code>\chapter</code>：章，<code>article</code>的文档类不包含该大纲级别</strong></li><li><strong><code>\section</code>：节。</strong></li><li><strong><code>\subsection</code>：次节。</strong></li><li><strong><code>\subsubsection</code>：次节。</strong></li><li><strong><code>\paragraph</code>：段，很少使用</strong></li><li><strong><code>\subparagraph</code>：段，很少使用</strong></li></ul><p>book文档类还提供了以下命令：</p><ul><li><strong><code>\frontmatter</code>：前言。页码为小写罗马字母，其后章节不编号，但是生成页眉页脚和目录项</strong></li><li><strong><code>\mainmatter</code>：正文。页码为阿拉伯数字，其后章节编号，页眉页脚和目录项正常生成</strong></li><li><strong><code>\backmatter</code>：后记。页码格式不变，章节不编号，但生成页眉页脚和目录项</strong></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>目录在大纲的基础上生成，使用命令<code>\tableofcontents</code>既可插入目录。</strong></p><p>在加入宏包<code>hyperref</code>，目录可以实现点击跳转。关于更多高级目录自定义需要借助<code>titletoc</code>宏包。</p><h1 id="计数器与列表"><a href="#计数器与列表" class="headerlink" title="计数器与列表"></a>计数器与列表</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p><code>LaTex</code>中的自动编号都借助内部的计数器来完成，计数器包括如下几种：</p><ul><li><strong>章节</strong>：part，chapter，section，subsection，subsubsection，paragraph，subparagraph</li><li><strong>编号列表</strong>：enumi，enumii，enumiii和enumiv</li><li><strong>公式和图表</strong>：equation，figure 与 table</li><li><strong>其他</strong>：page，footnote 与 mpfootnote</li></ul><p>可以通过<code>\the</code>接上计数器的名称来调用计数器，例如：<code>\thepart</code>。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong><code>LaTex</code>支持的预定义列表有三种，分别是无须列表<code>itemize</code>，自动编号列表<code>enumerate</code>，以及描述列表<code>description</code></strong>。</p><p><strong>无须列表</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一项</span><br><span class="line"><span class="keyword">\item</span>[-] 第二项</span><br><span class="line"><span class="keyword">\item</span>[*] 第三项</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309185733983.png" alt="image-20220309185733983" style="zoom:80%;" /></p><p><strong>有序列表</strong>命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一项</span><br><span class="line"><span class="keyword">\item</span> 第二项</span><br><span class="line"><span class="keyword">\item</span> 第三项</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309185946504.png" alt="image-20220309185946504" style="zoom: 80%;" /></p><p><strong>描述列表</strong>（自定义列表）命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;description&#125;</span><br><span class="line"><span class="keyword">\item</span>[LaTex] 第一项</span><br><span class="line"><span class="keyword">\item</span>[Tex] 第二项</span><br><span class="line"><span class="keyword">\item</span>[MarkDown] 第三项</span><br><span class="line"><span class="keyword">\end</span>&#123;description&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309190154869.png" alt="image-20220309190154869" style="zoom:80%;" /></p><h1 id="浮动体与图表"><a href="#浮动体与图表" class="headerlink" title="浮动体与图表"></a>浮动体与图表</h1><h2 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h2><p>浮动体将图或者表及其标题定义为整体，可以动态排版，以解决图，表在换页处造成的过长留白问题。</p><p><strong>图片的浮动体是<code>figure</code>环境，表格的浮动体是<code>table</code>环境。</strong></p><p>如果希望浮动体不要跨过<code>section</code>，可以使用如下命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[section]&#123;placeins&#125;</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的插入需要使用宏包<code>graphicx</code>和<code>\includegraphics</code>命令。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">这是正文内容，我是长长的内容，我真的很长并且有很多内容，我企图扩展到第二行，甚至第三行。</span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[width=0.8<span class="keyword">\linewidth</span>]&#123;1.jpg&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309192047201.png" alt="image-20220309192047201" style="zoom:80%;" /></p><p>其中，可选参数可以指定其宽高等，类似地，也可以使<code>height</code>（高），<code>scale</code>（图片缩放倍数），<code>angle</code>（图片逆时针旋转角度），<code>origin</code>（图片选中中心）等命令。</p><blockquote><p>前三个命令不建议同时使用，旋转的图片基线会变化，所以一般使用<code>totalheight</code>代替<code>height</code></p></blockquote><p>至于<code>&#123;&#125;</code>里的参数的写法，<code>LaTex</code>支持<code>pdf</code>,<code>eps</code>,<code>png</code>与<code>jpg</code>格式，所以可以选择带有图片拓展名的表示方式，也可以不带拓展名，如果不带拓展名，则会按照上述格式顺序搜索图片。</p><blockquote><p>默认图片需要在<code>.tex</code>文件放在同一个文件夹下</p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>懒得解释了，就看一个简单的命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span> 2<span class="built_in">&amp;</span>9<span class="built_in">&amp;</span>4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> 7<span class="built_in">&amp;</span>5<span class="built_in">&amp;</span>3<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> 6<span class="built_in">&amp;</span>1<span class="built_in">&amp;</span>8<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309194713871.png" alt="image-20220309194713871" style="zoom:80%;" /></p><h1 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h1><h2 id="纸张，方向和边距"><a href="#纸张，方向和边距" class="headerlink" title="纸张，方向和边距"></a>纸张，方向和边距</h2><p>详情参考宏包<code>geometry</code>。</p><h2 id="页眉和页脚"><a href="#页眉和页脚" class="headerlink" title="页眉和页脚"></a>页眉和页脚</h2><p>详情参考宏包<code>fancyhdr</code>。</p><h1 id="抄录与代码环境"><a href="#抄录与代码环境" class="headerlink" title="抄录与代码环境"></a>抄录与代码环境</h1><p>如果你希望直接输出相关内容而不经过<code>Tex</code>解释，可以使用<code>\verb</code>命令。命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;color&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\textcolor</span>&#123;red&#125;&#123;text&#125;</span><br><span class="line"><span class="keyword">\verb</span>*<span class="string">|\textcolor&#123;red&#125;&#123;text&#125;|</span></span><br><span class="line"><span class="string">\end&#123;document&#125;</span></span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309195249437.png" alt="image-20220309195249437" style="zoom:80%;" /></p><h1 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h1><p>分栏需要使用<code>multicol</code>宏包，命令示例：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;multicol&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;multicols&#125;&#123;2&#125;</span><br><span class="line">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line"><span class="keyword">\end</span>&#123;multicols&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>【渲染效果】</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220309195831024.png" alt="image-20220309195831024" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git与GitHub(上)</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A)/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分写于寒假，之前学过<code>git</code>一些基本操作，属于学个开始就由于别的事情暂时耽搁了，现在是大三寒假，我决定把它补上。</p><p>此处推荐两个网站，一个是git官方的书籍教程，一个是GitHub上比较有名的可视化git教程</p><ul><li><a href="https://learngitbranching.js.org/?locale=zh_CN">玩游戏学习git网站</a></li><li><a href="https://git-scm.com/book/zh/v2">特别好的git书籍</a></li></ul><h1 id="Git与GitHub简要"><a href="#Git与GitHub简要" class="headerlink" title="Git与GitHub简要"></a>Git与GitHub简要</h1><h2 id="关于GitHub"><a href="#关于GitHub" class="headerlink" title="关于GitHub"></a>关于<a href="https://github.com/">GitHub</a></h2><p><a href="https://github.com/">GitHub</a>作为最大的同性交友网站(雾)，<strong><a href="https://github.com/">GitHub</a>为开发者提供<code>Git</code>仓库的托管服务，可以让开发者及其相关人员共享代码的场所</strong>。可以暂时通俗理解为代码的仓库。</p><h2 id="关于Git"><a href="#关于Git" class="headerlink" title="关于Git"></a>关于Git</h2><p><strong>Git属于分散型版本管理系统，是为版本管理而设计的软件</strong>。</p><p>Linux的创始人Linus Torvalds在2005年开发了Git的原型程序，当时是为了更好的维护Linux系统。</p><p>关于这里有一个故事：一开始Linux之父是个人在开源做Linux，随着参与项目的人越来越多，Linux项目越来越复杂，Linux之父不得不在代码整理，纠错，审核，检查，发布的过程中耗费大量的时间，这样就严重影响了开发，于使Linux之父使用了当时的版本管理系统，虽然这样解决相关问题，当时由于技术宅的爱好，就把提供Linux之父版本控制厂商研发的版本管理系统给破解研究了，这样就违背了使用该软件的相关原则，于使Linux之父一生气，憋了一个月，开发出来了Git</p><h3 id="什么是版本管理"><a href="#什么是版本管理" class="headerlink" title="什么是版本管理"></a>什么是版本管理</h3><p>版本就是管理更新的历史记录。它为我们提供了一些在软件开发过程中必不可少的功能，例如记录一款软件添加或者更改源代码的过程，回滚到特定阶段，恢复误删除的文件等。</p><p>在Git出现以前，人们普遍采用Subversion(SVN)等集中型版本管理系统，而现在Git已经成为了主流。</p><h3 id="集中型与分散型"><a href="#集中型与分散型" class="headerlink" title="集中型与分散型"></a>集中型与分散型</h3><p>刚才说到的版本管理系统分为Subversion(SVN)这类集中型的与Git这类分散型的</p><ul><li><p><strong>集中型</strong></p><p>以Subversion为代表的集中型，会将如下图所示的仓库集中存放在服务器之中，所以只存在一个仓库，这就是为什么会被称为集中型。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202165523166.png" alt="image-20220202165523166" style="zoom:80%;" /></p><p>集中型将所有数据集中存放在服务器当中，有便于管理的优点。但是一旦开发者所处的环境不能连接服务器，就无法获取最新的源代码，开发也就几乎无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据消失，恐怕开发者就再也见不到代码了。</p></li><li><p><strong>分散型</strong></p><p>如下图为GitHub分散型示意图。如图中所示，GitHub将仓库<code>Fork</code>给了每一个用户。<code>Fork</code>就是将GitHub的某个特定仓库复制到自己的账户下。<code>Fork</code>出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。</p><p>​    <img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202171024187.png" alt="image-20220202171024187" style="zoom:80%;" /></p><p>分散型拥有多个仓库，相对而言稍显复杂。不过，由于本地的开发环境中就有仓库，所以开发者不必远程连接仓库就可以进行开发。</p></li></ul><h3 id="集中型和分散型哪个更好？"><a href="#集中型和分散型哪个更好？" class="headerlink" title="集中型和分散型哪个更好？"></a>集中型和分散型哪个更好？</h3><p>各有优缺点，根据具体情况而定，不存在绝对的“好”。</p><h2 id="GitHub与Git的区别"><a href="#GitHub与Git的区别" class="headerlink" title="GitHub与Git的区别"></a>GitHub与Git的区别</h2><p><strong>GitHub与Git完全是两个东西。在Git中，开发者将源代码存放进“Git仓库”的资料库中并加以使用和操作。而GitHub则是网络上提供Git仓库的一项服务。</strong></p><p>也就是说，GitHub上公开的软件源代码全部都由Git进行管理，所以理解Git，是熟练运用GitHub的关键。</p><h1 id="开始Git与GitHub之旅"><a href="#开始Git与GitHub之旅" class="headerlink" title="开始Git与GitHub之旅"></a>开始Git与GitHub之旅</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul><li><p>Mac与Linux</p><p>无Mac系统，自行百度，Linux都以软件包(Package)的形式提供了，可以直接使用。</p></li><li><p>Windows</p><p>百度Git查找官网下载，或者点击这里<a href="https://git-scm.com/">Git官网</a>，然后选择Windows平台，或者直接在这里下载<a href="https://gitforwindows.org/">msysGit</a>，这两个是一个软件，选择一个合适的位数，下载，完成后双击运行，按照引导安装即可。</p><blockquote><p>说明：我使用的Git版本是<code>2.32.0.windows.2</code>，也是文章各种Git代码示例的演示版本</p></blockquote><ol><li><p>双击运行，选择下一步（Next）</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202213937370.png" alt="image-20220202213937370" style="zoom:80%;" /></p></li><li><p>选择安装位置，点击Next</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202214123824.png" alt="image-20220202214123824" style="zoom:80%;" /></p></li><li><p>根据需要选择相应组件，或者直接默认即可，点击Next</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202214851363.png" alt="image-20220202214851363" style="zoom:50%;" /></p></li><li><p>选择Win菜单中Git相关文件目录，无需求的可以选择默认，点击Next</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202215753488.png" alt="image-20220202215753488" style="zoom:80%;" /></p><p>如果选择默认，则在开始菜单中可以找到git相关文件如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202215946572.png" alt="image-20220202215946572" style="zoom:80%;" /></p></li><li><p>选择Git默认编辑器，无特殊需求默认即可，有特殊需求的需要另行安装编辑器，并在安装时指定编辑器，并配置相关环境变量。默认则直接点击Next即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202220139702.png" alt="image-20220202220139702" style="zoom:80%;" /></p></li><li><p>选择初始化仓库的主干名称，默认为第一项，即让Git选择，名称为<code>master</code>，未来可能会改名。第二项是我们可以自定义名称，下面附注的翻译为：<em>很多团队已经重命名他们的默认主干名，常见的选择为 main，trunk 以及 development，你可以修改你的主干名称为：</em></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202220739690.png" alt="image-20220202220739690" style="zoom:80%;" /></p></li><li><p>选择修改Path环境变量，无特殊需求可以直接默认，点击Next即可<br><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202221014355.png" alt="image-20220202221014355" style="zoom:80%;" /><br>翻译：<br><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202221903449.png" alt="image-20220202221903449" style="zoom:70%;" /></p></li><li><p>选择HTTPS后端传输规则，同理无特殊需求默认即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202222429285.png" alt="image-20220202222429285" style="zoom:80%;" /></p><blockquote><p>关于两个选项的区别可以参考[<a href="https://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr">What’s the difference between OpenSSL and the native windows Secure Channel library</a>]</p></blockquote></li><li><p>末尾换行符的处理，同理无特殊需求，默认即可</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202222547719.png" alt="image-20220202222547719" style="zoom:80%;" /></p><p>GitHub中公开的代码大部分都是以Mac或Linux中的LF(Line Feed)换行。然而，由于Windows中是以CRLF(Carriage Return + Line Feed)换行的，所以在非对应的编辑器中将不能正常显示。</p><p>Git可以通过设置自动转换这些换行符。对于使用Windows环境的用户来说，直接选择默认的”Checkout Windows-style,commit Unix-style line endings”选项。换行符在<code>checkout</code>时会自动转换为CRLF，在提交时则会自动转换为LF。</p><blockquote><p>相关说明：<a href="https://zhuanlan.zhihu.com/p/380574688">关于CRLF和LF的差异</a></p></blockquote></li><li><p>配置终端模拟器与Git Bash一起使用，同理无特殊需求默认即可，点击Next。<img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202225251266.png" alt="image-20220202225251266" style="zoom:80%;" /></p><p>翻译：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202230152589.png" alt="image-20220202230152589" style="zoom:70%;" /></p></li><li><p>选择默认的<code>git pull</code>行为，无特殊需求默认即可，点击Next。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202230311097.png" alt="image-20220202230311097" style="zoom:80%;" /></p></li><li><p>选择一个凭证帮助管理，无特殊需求无须配置，点击Next即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202230538736.png" alt="image-20220202230538736" style="zoom:80%;" /></p></li><li><p>其他配置，无特殊需求默认即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202230710959.png" alt="image-20220202230710959" style="zoom:80%;" /></p><p>翻译：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202231151069.png" alt="image-20220202231151069" style="zoom:70%;" /></p></li><li><p>实验性功能选项，无特殊需求默认即可，然后选择<code>Install</code>等待安装即可。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202231220516.png" alt="image-20220202231220516" style="zoom:80%;" /></p></li><li><p>安装成功后可以通过鼠标右键查看到如下快捷导航：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202231356420.png" alt="image-20220202231356420" style="zoom:67%;" /></p></li></ol></li></ul><h2 id="Git初始设置"><a href="#Git初始设置" class="headerlink" title="Git初始设置"></a>Git初始设置</h2><p>在随便一个位置，右键鼠标，选择<code>Git Bash Here</code>，在之后弹出的程序控制台中进行操作。</p><blockquote><ol><li><code>Git GUI Here</code>是Git提供的GUI图形化界面，但是用处不大，可以不用考虑</li><li>关于<a href="https://baike.baidu.com/item/Bash/6367661?fr=aladdin"><code>Bash</code>出处由来(点击查看)</a></li></ol></blockquote><ul><li><p><strong>设置姓名和邮箱地址</strong></p><p>使用如下代码来设置使用Git时的姓名和邮箱地址，名称使用英文输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置名称和邮箱地址</span></span><br><span class="line">git config --global user.name &quot;你自定义的名称&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱地址&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前名称和邮箱地址</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202233416626.png" alt="image-20220202233416626" style="zoom:67%;" /></p><p><strong>这里设置的姓名和邮箱地址会用在Git的提交日志中。由于GitHub上公开仓库时，这里的姓名和邮箱也会随着提交日志一同被公开，所以注意不要使用隐私信息</strong>。</p></li><li><p><strong>提高命令输出的可读性</strong></p><p>可以通过将<code>color.ui</code>设置为<code>auto</code>来让命令的输出有更高的可读性。代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui auto</span><br></pre></td></tr></table></figure></li></ul><h2 id="GitHub的相关准备"><a href="#GitHub的相关准备" class="headerlink" title="GitHub的相关准备"></a>GitHub的相关准备</h2><p>访问GitHub网页，或者<a href="https://github.com/">单击这里</a>，进行GitHub的相关准备。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202234926203.png" alt="image-20220202234926203" style="zoom:80%;" /></p><ul><li><p><strong>创建账户</strong></p><p>进入如下类似界面创建账户，需要注意的是Username设置好后，个人公开页面URL即（<a href="https://github.com/+username），其他项目根据提示完成填写并创建账户。">https://github.com/+username），其他项目根据提示完成填写并创建账户。</a></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220202235255910.png" alt="image-20220202235255910" style="zoom:67%;" /></p></li><li><p><strong>设置头像</strong></p><p>在GitHub上随处可见的头像是通过<a href="http://cn.gravatar.org/">Gravatar</a>服务显示的。使用过<code>WordPress</code>的玩家可能会对它有所了解。</p><p>当然现在，可以直接点击我的头像，进入设置，上传自定义头像。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203000017875.png" alt="image-20220203000017875" style="zoom:80%;" /></p></li><li><p><strong>设置SSH Key</strong></p><p><strong>GitHub上链接已有仓库时的认证，是通过SSH公开密钥认证方式进行的。现在需要来创建公开密钥认证所需要的SSH Key，并将其添加到GitHub上</strong>。运行下面的命令来创建SSH Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里添你的邮箱&quot; </span><br></pre></td></tr></table></figure><p>输入后会弹出一行提醒：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/c/Users/电脑用户文件夹/.ssh/id_rsa):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里是告诉你SSH key保存在哪个路径下，只需要按下回车确认就可以</span></span><br></pre></td></tr></table></figure><p>剩下的如下图所示，根据提示设置密码：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203122043906.png" alt="image-20220203122043906" style="zoom:80%;" /></p><blockquote><p>需要注意的是，<strong>密码输入后会不显示在控制台上</strong>，所以不要误认为控制台失灵了</p></blockquote><p>设置成功会弹出如下提醒：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203124607435.png" alt="image-20220203124607435" style="zoom:80%;" /></p><p>同样的，你可以在它保存的路径下找到相关公钥和密钥文件：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203123240917.png" alt="image-20220203123240917" style="zoom:80%;" /></p><blockquote><p>关于<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">SSH密钥的官方说明</a></p></blockquote></li><li><p>在GitHub上<strong>添加公开密钥</strong></p><p>在GitHub上添加公开密钥，今后就可以使用私有密钥进行认证了。</p><p>进入GitHub网站，登录你的账户，单击头像，选择<code>Settings</code>（设置）</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203123809744.png" alt="image-20220203123809744" style="zoom:90%;" /></p><p>进入设置页面，在左栏找到<code>SSH and GPG keys</code>，单击进入，在<code>SSH keys</code>栏选择<code>New SSH keys</code>（创建新的公钥）</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203124044881.png" alt="image-20220203124044881" style="zoom:80%;" /></p><p><strong><code>Title</code>部分可以自定义，<code>Key</code>需要填写公钥文件里的内容</strong>，可以通过找到路径文件，选择以记事本格式打开，或者通过下面的命令来查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203124502974.png" alt="image-20220203124502974" style="zoom:80%;" /></p><p>点击添加，输入密码二次确认，添加成功后，可以在<code>SSH keys</code>栏看到刚刚添加的公钥，并且创建账户时所用的邮箱也会收到一封“公钥添加完成”的邮件提醒。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203124944367.png" alt="image-20220203124944367" style="zoom:80%;" /></p><p><strong>在添加完成后，现在可以尝试使用手中的私钥与GitHub进行认证和通信了</strong>。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现如下提示，则表示连接成功。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203125551594.png" alt="image-20220203125551594" style="zoom:80%;" /></p><blockquote><p>同理，这里输入密码，也是不可见的</p></blockquote></li><li><p><strong>使用社区功能</strong></p><p>你可以通过<code>Follow</code>来关注某人，这样一来，你关注的对象（用户）的活动就会在你的控制面板中显示出来，你可以看到该用户在GitHub上做了什么，可以通俗理解为微博关注了某人，某人的动态你就可以看到了。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203130013684.png" alt="image-20220203130013684" style="zoom:80%;" /></p></li></ul><h2 id="GitHub实操上手"><a href="#GitHub实操上手" class="headerlink" title="GitHub实操上手"></a>GitHub实操上手</h2><ul><li><p><strong>创建仓库</strong></p><p>在GitHub右上角，点击加号，选择<code>New repository</code>来创建新仓库。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203132232745.png" alt="image-20220203132232745" style="zoom:80%;" /></p><ol><li><p><strong>Repository template(存储库模板)</strong></p><p>可以选择自定义存储卡模板，无特殊需求可以不用管。</p></li><li><p><strong>Repository name(仓库名称)</strong></p><p>为你创建的仓库自定义一个名称。</p></li><li><p><strong>Description(仓库描述)</strong></p><p>为你仓库添加一个描述，可以为空</p></li><li><p><strong>Public/Private(仓库类型)</strong></p><p>仓库的类型，<strong>Public</strong>或者<strong>Private</strong>：</p><ul><li><strong>Public：公开/公有，即别人可以看到你的代码</strong></li><li><strong>Private：私有，即别人看不到，只有自己或者授权的人才可以访问</strong></li></ul><p>私有仓库收费的，不过被微软爸爸收购后，可以免费提供最多3人协助私有仓库支持。</p><p>目前示例，创建公有即可</p></li><li><p><strong>Initializa this repository with(初始化命令/文件)</strong></p><ul><li><p><strong>Add a README file(创建一个ReadMe文件)</strong>：即仓库创建后，里面附带一个ReadMe文件。</p><p>ReadMe文件本质是一个记事本，不过其后缀为<code>.md</code>，如果熟悉<code>Markdown</code>的会了解这个文件，一般用来说明仓库包含软件的概要，使用流程，许可协议等信息，可以理解为仓库的说明文档，即使用手册和相关说明。</p><blockquote><p>关于<code>Markdown</code>语法格式及其相关教程可以点击这里<a href="https://helloseraphine.top/index.php/archives/57.html">浅谈MarkDown基础</a></p></blockquote></li><li><p><strong>Add .gitignore(创建.gitignore文件)</strong>：即仓库创建后，附带.gitignore文件。</p><p>这个我没用过，以下内容出自作者: <a href="https://book.douban.com/search/大塚弘记">[日] 大塚弘记</a>的《GitHub入门与实践》</p><p><em>这个设定会帮我们把不需要在Git仓库中进行版本管理的文件记录在<code>.gitignore</code>文件中，省去了每次根据框架进行设置的麻烦，选择后下拉菜单包含主要的语言及框架，选择今后将要使用的即可。</em></p></li><li><p><strong>Add a license(创建许可协议文件)</strong>：即仓库创建后，附带LICENSE协议文件。</p><p>选择后，可以根据下拉菜单来选择许可协议，仓库创建后会自动生成许可协议的LICENSE文件，用来表明仓库的许可协议。</p></li></ul></li><li><p>全部选择完成后，点击创建即可创建一个新的仓库。</p></li></ol><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203132947022.png" alt="image-20220203132947022" style="zoom:80%;" /></p></li><li><p><strong>仓库初始页面</strong></p><p>如下为创建的新仓库页面示例：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203140859991.png" alt="image-20220203140859991" style="zoom:100%;" /></p><p>我们可以通过示例连接来<code>Clone</code>仓库，或者其他方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/L-Seraphine/Test.git</span><br></pre></td></tr></table></figure><ul><li><p>ReadMe：可以看到我们在ReadMe中的内容会被直接显示在仓库的最下面，所以一般会在该文件中注明仓库包含的文件说明，使用说明，许可协议，支持等信息。可以使用普通文本，或者使用<code>Markdown</code>语法实现其他效果，来提高可读性。</p></li><li><p><strong>GitHub Flavored Markdown(GitHub 风格的 Markdown)</strong>：在GitHub上进行交流时使用的Issue，评论，Wiki等都可以使用<code>Markdown</code>语法表述。准确的来说是GitHub Flavored Markdown（GFM）语法，该语法是在<code>Markdown</code>语法的基础上扩充来的，一般情况下，使用原本的<code>Markdown</code>语法即可。</p><blockquote><p>关于<a href="https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">GFM语法的官方文档说明</a></p></blockquote></li></ul></li><li><p><strong>使用Git对仓库的基本操作</strong></p><ul><li><p><strong><code>Clone</code>仓库</strong></p><p>选择一个要克隆的文件夹，对着空白处右键，选择<code>Git Bash here</code>，然后在控制台输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 这里是仓库的地址</span><br></pre></td></tr></table></figure><p>仓库地址可以在GitHub SSH选项下复制：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203142932527.png" alt="image-20220203142932527" style="zoom:67%;" /></p><p>然后输入设置密钥时的密码即可<code>Clone</code>该仓库到指定的本地文件夹：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203143317515.png" alt="image-20220203143317515" style="zoom:77%;" /></p></li><li><p><strong>编写代码</strong></p><p>现在在<code>Clone</code>的本地文件夹下，创建文件<code>1.txt</code>，随便写些内容。例如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><p>然后通过输入以下命令来查看文件状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203151755689.png" alt="image-20220203151755689" style="zoom:80%;" /></p></li><li><p><strong>提交</strong></p><p>然后将<code>1.txt</code>提交到仓库，这样，这个文件就进入了版本管理系统的管理之下。今后的更改管理都交给Git进行。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 1.txt</span><br></pre></td></tr></table></figure><p><strong>通过<code>git add</code>命令将文件加入暂存区，再通过<code>git commit</code>命令提交。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;update 1.txt&quot;</span><br></pre></td></tr></table></figure><p><strong>添加成功后可以使用<code>git log</code>命令来查看提交日志。</strong></p></li><li><p><strong>进行<code>Push</code></strong></p><p>之后只需要执行<code>push</code>命令，就可以将GitHub上的仓库进行更新。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203152218078.png" alt="image-20220203152218078" style="zoom:80%;" /></p><p>这样一来，我们更新的操作就会在GitHub上面公开了。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203152310838.png" alt="image-20220203152310838" style="zoom:80%;" /></p></li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这是基本的Git和GitHub的基础和交互基础，对于Git和GitHub连接提交等命令看不懂目前没问题，只需要跟着操作熟悉一下环境和命令即可，后面的部分会详细讲述git相关命令。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git与GitHub(中)</title>
      <link href="/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%AD)/"/>
      <url>/2022/05/22/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Git%E4%B8%8EGitHub(%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分将讲述Git相关的基本知识和操作方法。</p><p>各种Git命令操作，需要鼠标右键选择，<code>Git Bash here</code>来开始。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li><p><strong><code>git init</code>——初始化仓库</strong></p><p><strong>要使用Git进行版本管理，必须先初始化仓库。</strong>Git是使用<code>git init</code>命令进行初始化的。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203172122036.png" alt="image-20220203172122036" style="zoom:80%;" /></p><p><strong>如果初始化成功，执行了<code>git init</code>命令的目录下就会生成<code>.git</code>目录。这个目录里存储着管理当前目录内容所需的仓库数据</strong>。</p><blockquote><p><code>.git</code>目录默认隐藏，需要开启查看隐藏文件才可以查看到</p></blockquote><p>在Git中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。开发者可以通过这种方式来获取以往的文件，具体的操作指令后面会说明。</p></li><li><p><strong><code>git status</code>——查看仓库状态</strong></p><p><strong><code>git status</code>命令用于显示Git仓库的状态。</strong></p><p>工作树和仓库在被操作的过程中，状态会不断发生变化。在Git操作的过程中，要常看仓库状态。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>结果显示我当前处于<code>master</code>分支下。关于分支我们会在后面讲到。接着还显示了没有可提交的内容。所谓提交(Commit)，是指“记录工作树中所有文件的当前状态”。</p><p>没有可提交内容，就是说明我们当前建立这个仓库中还没有记录任何文件的任何状态。这里，创建一共Readme文件作为示例，为第一次提交做前期准备。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220203184854865.png" alt="image-20220203184854865" style="zoom:80%;" /></p><p>可以看到在Untracked files中显示了Readme.md文件。类似地只要对Git的工作树或仓库进行操作，<code>git status</code>命令的显示结果就会发生变化。</p></li><li><p><strong><code>git add</code>——向暂存区中添加文件</strong></p><p>如果只是用Git仓库的工作树创建了文件，那么该文件并不会被计入Git仓库的版本管理对象当中。因此我们使用<code>git status</code>命令查看ReadMe.md文件时，它会显示在Untracked files里。</p><p><strong>要想让文件成为Git仓库的管理对象，就需要用<code>git add</code>命令将其加入暂存区（Stage或者Index）中</strong>。<strong>暂存区是提交之前的一个临时区域</strong>。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205105924838.png" alt="image-20220205105924838" style="zoom:80%;" /></p><p>将ReadMe.md文件加入暂存区后，<code>git status</code>命令的显示结果发生了变化。可以看到，ReadMe.md文件显示在Changes to be committed中了。</p></li><li><p><strong><code>git commit</code>——保存仓库的历史记录</strong></p><p><strong><code>git commit</code>命令可以将当前暂存区中的文件实际保存到仓库的历史记录中</strong>。通过这些记录，我们就可以在工作树中复原文件。</p><ol><li><p><strong>记录一行提交信息</strong></p><p>命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;这里是提交信息，是对提交的描述&quot;</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205110529770.png" alt="image-20220205110529770" style="zoom:80%;" /></p></li><li><p><strong>记录详细的提交信息</strong></p><p>上述命令示例，提交了一行简单的提交信息，如果希望更加详细的描述提交信息，就不需要加<code>-m</code>，直接执行<code>git commit</code>命令。如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不需要加-m了</span></span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>执行后编辑器会启动显示如下效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># On branch master</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">new file:   ReadMe.md</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下（可以不用遵守这个格式，此格式只是提高可读性）：</p><ul><li>第一行：用一行文字简要描述提交信息</li><li>第二行：空行</li><li>第三行以后：记录更改的原因和详细的内容</li></ul><p>只要按照上面的格式输入，今后便可以通过确认日志命令或者工具看到这些记录。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是一行注释</span><br><span class="line"></span><br><span class="line">这是详细的注释信息，可以一直写，都是文件更改注释描述</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># On branch master</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">new file:   ReadMe.md</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>在以<code>#</code>标为注释的Changes to be committed（要提交的更改）栏中，可以查看本次提交中包含的文件。将要提交信息按格式记录完毕后，保存然后关闭编辑器，以<code>#</code>标注为注释的行不必删除，随后，刚才记录的提交信息就会被提交。</p></li><li><p><strong>中止提交</strong></p><p>如果在编辑器启动后想中止提交，直接将提交信息留空关闭编辑器即可。</p></li><li><p><strong>查看提交后的状态</strong></p><p>执行完毕<code>git commit</code>命令后再来查看当前状态：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205113345688.png" alt="image-20220205113345688" style="zoom:80%;" /></p></li></ol></li><li><p><strong><code>git log</code>——查看提交日志</strong></p><p><strong><code>git log</code>命令可以查看以往仓库中的提交日志。</strong>包括什么人在什么时候进行了提交和合并，以及操作前后的差别等。现在来查看之前<code>git commit</code>的命令是否被记录了：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205113611232.png" alt="image-20220205113611232" style="zoom:80%;" /></p><p>可以看到已经记录了我们的提交记录。<strong><code>commit</code>后面显示的“4b68….”，是指向这个提交的哈希值。<code>Git</code>的其他命令中，在指向提交时也会用到这个哈希值。<code>Author</code>是提交人的用户名和邮箱地址。<code>Date</code>栏显示的提交时间，然后后面就是提交的信息。</strong></p><ol><li><p><strong>只显示提交信息的第一行</strong></p><p>如果只想让程序显示第一行简述信息，可以在<code>git log</code>命令后加上<code>--pretty=short</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=short</span><br></pre></td></tr></table></figure></li><li><p><strong>只显示指定目录，文件的日志</strong></p><p>只要在<code>git log</code>命令后面加上目录名或者文件名就可以显示于该目录或者文件相关的记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令示例：</span></span><br><span class="line">git log ReadMe.md</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205114741582.png" alt="image-20220205114741582" style="zoom:80%;" /></p></li><li><p><strong>显示文件的改动</strong></p><p>如果想查看文件提交所带来的改动，可以加上<code>-p</code>参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>如果只想查看某文件的提交日志以及前后差异可以使用如下格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令格式：</span></span><br><span class="line">git log -p 文件名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令示例：</span></span><br><span class="line">git log -p ReadMe.md</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong><code>git diff</code>——查看更改前后的差别</strong></p><p><code>git diff</code>命令可以查看工作树，暂存区，最新提交之间的差别。</p><p>现在我们在之前提交的ReadMe.md中写点东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是新写的东西</span><br></pre></td></tr></table></figure><ol><li><p><strong>查看工作树和暂存区的区别</strong></p><p>执行<code>git diff</code>命令，查看工作树与暂存区的差别。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205125519560.png" alt="image-20220205125519560" style="zoom:80%;" /></p><p>因为我们并没有使用<code>git add</code>命令将工作树的文件添加到暂存区，所以程序只显示工作树与最新提交状态之间的差别。</p><p><strong><code>+</code>号标出的是新添加的行，被删除的行用<code>-</code>标出</strong>，由此可以看出只添加了一行。</p><p>现在使用<code>git add</code>将修改后的文件添加到暂存区</p></li><li><p><strong>查看工作树和最新提交的差别</strong></p><p>如果我们现在执行<code>git diff</code>命令，由于工作树和暂存区的状态没有差别，结果是什么也不会显示。要查看与最新提交的差别，需要执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205125900504.png" alt="image-20220205125900504" style="zoom:80%;" /></p><p>然后我们就可以直接进行提交<code>git commit</code>了，提交完毕后使用<code>git log</code>命令检查一下提交是否被记录。</p></li></ol></li></ul><blockquote><p>如果进入<code>git log</code>日志最后发现了<code>&lt;End&gt;</code>，说明进入日志文件，这个时候按<code>q</code>就可以退出</p></blockquote><h1 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h1><p><strong>在进行多个并行作业时，我们会用到分支</strong>。在这类并行开发的过程中，往往同时存在多个最新代码状态。如下图所示，从<code>master</code>分支创建分支A和分支B后，每个分支中都拥有自己的最新代码。<code>master</code>分支是Git默认创建的分支，因此基本上所有开发都是以这个分支为中心进行的。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205131656707.png" alt="image-20220205131656707" style="zoom:80%;" /></p><p><strong>不同的分支中，可以同时进行完全不同的作业。等该分支的作业完成之后再与<code>master</code>分支合并</strong>。比如A分支的作业结束后再与<code>master</code>合并。如下图：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205131939324.png" alt="image-20220205131939324" style="zoom: 67%;" /></p><ul><li><p><strong><code>git branch</code>——显示分支一览表</strong></p><p><code>git branch</code>命令可以将分支名列表显示，同时可以确认当前所在的分支。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205132950335.png" alt="image-20220205132950335" style="zoom:80%;" /></p><p><strong>可以看到<code>master</code>分支左侧有<code>*</code>号，表示这是我们当前所在的分支</strong>。也就是说，我们正在<code>master</code>分支下进行开发。<strong>结果中没有显示其他分支名，表示本地仓库中只存在<code>master</code>一个分支</strong>。</p></li><li><p><strong><code>git checkout -b</code>——创建，切换分支</strong></p><p>如果想以当前的<code>master</code>分支为基础创建新的分支，需要用到<code>git checkout -b</code>命令。命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 需要创建的分支名称</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205145339982.png" alt="image-20220205145339982" style="zoom: 67%;" /></p><p>实际上<code>git checkout -b</code>命令，是下面的命令合并效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建分支<span class="built_in">test</span></span></span><br><span class="line">git branch test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指针切换到分支<span class="built_in">test</span>，之前一直默认在主分支即master上</span></span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p><strong>如果在<code>test</code>分支的左边有<code>*</code>号，则表示目前指针指向该分支，如果这个时候正常开发修改代码，再提交的话，代码就会提交到<code>test</code>分支下</strong>。像这样不断对一个分支进行提交的操作，称为“培育分支”。</p><p><strong>如果我们想要快速切换回上一个分支，可以使用<code>-</code>代替分支名</strong>，命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205151438821.png" alt="image-20220205151438821" style="zoom:67%;" /></p></li><li><p><strong>特性分支</strong></p><p>Git与SVN等集中型版本管理系统不同，创建分支不需要连接中央仓库，所以能够轻松创建分支。因此，当今大部分工作流程中都用到了特性(Topic)分支。</p><p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常快开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色同时由<code>master</code>分支担当。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205154334634.png" alt="image-20220205154334634" style="zoom:80%;" /></p><p>例如之前创建的分支A，这一分支主要实现A需求，除A需求之外不进行任何作业，即便在开发过程中发现了BUG，也需要创建新的分支，在新的分支中进行。</p><p>基于特定主题的作业在特性分支中进行，主题完成后再与<code>master</code>分支合并。只要保持这样一个开发流程，就能保证<code>master</code>分支可以随时供人查看。这样一来，其他开发者也可以放心大胆的从<code>master</code>分支创建新的特性分支。</p></li><li><p><strong>主干分支</strong></p><p>主干分支是特性分支的原点，同时也是合并的终点。一般来说是以<code>master</code>分支作为主干分支。</p></li><li><p><strong><code>git merge</code>合并分支</strong></p><p>现在假设我们前面创建的<code>test</code>分支以及实现完毕了，想要将它合并到主干分支<code>master</code>中，首先切换到<code>master</code>分支上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>然后合并<code>test</code>分支。为了在历史记录记录下来本次分支合并，需要创建合并提交。<strong>因此，在合并时加上<code>--no-ff参数</code></strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff test</span><br></pre></td></tr></table></figure><p>然后编辑器弹出，添加一定的描述，关闭编辑器后，就完成分支合并了。</p></li><li><p><strong><code>git log --graph</code>——以图表形式查看分支</strong></p><p>用<code>git log --graph</code>命令查看，能很清楚地看到很多信息。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205160840715.png" alt="image-20220205160840715" style="zoom: 67%;" /></p></li></ul><h1 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h1><h2 id="git-reset——回溯历史版本"><a href="#git-reset——回溯历史版本" class="headerlink" title="git reset——回溯历史版本"></a><strong><code>git reset</code>——回溯历史版本</strong></h2><p>在前面基础操作，以及可以在实现功能后进行提交，累积提交日志作为历史记录，借此不断培育一款软件。</p><p>Git的另一特性是可以灵活的操作历史版本，借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。</p><p>现在进行版本回溯，然后再创建一个<code>B</code>特性分支，Git目前结构如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205165541460.png" alt="image-20220205165541460" style="zoom:67%;" /></p><p>我们需要先回溯到分支<code>A</code>的之前的分支节点，然后创建一个名为<code>B</code>的特性分支。要让仓库的HEAD，暂存区，当前工作树回溯到指定状态，需要使用<code>git reset --hard</code>命令。只要提高目标时间点的哈希值。就可以完全恢复到该时间点状态。命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要注意的是，每个哈希值不一样，操作的时候看自己的哈希值</span></span><br><span class="line">git reset --hard a369bfe343a6ce72d75b39db804da6f46769be2d</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205171050472.png" alt="image-20220205171050472" style="zoom:67%;" /></p><p>现在来创建新分支B，并且在新分支中，在ReadMe.md文件中添加一些文字，然后提交ReadMe.md文件。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205171518879.png" alt="image-20220205171518879" style="zoom:67%;" /></p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205171548568.png" alt="image-20220205171548568" style="zoom:67%;" /></p><p>现在分支状态如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205171825806.png" alt="image-20220205171825806" style="zoom:67%;" /></p><p>现在需要恢复到分支<code>A</code>合并后的状态，使用<code>git log</code>只能查看当前状态为终点的历史记录。所以需要使用<code>git reflog</code>命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，然后通过<code>git reset --hard</code>命令回溯到历史之前的状态。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205172249850.png" alt="image-20220205172249850" style="zoom: 50%;" /></p><p>从日志里可以看到我们所有的操作，只要不进行Git的GC（Garbage Colloection，垃圾回收）就可以通过日志随意调取历史状态。可以了解到我们要恢复的时间点哈希值为：7092c19b410daac6937a906966b78565e6432771，其实我们只需要输入前面的7092c19即可执行恢复。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205172957748.png" alt="image-20220205172957748" style="zoom:67%;" /></p><p>恢复后的状态：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205173422425.png" alt="image-20220205173422425" style="zoom:70%;" /></p><h2 id="消除冲突"><a href="#消除冲突" class="headerlink" title="消除冲突"></a><strong>消除冲突</strong></h2><p>现在只需要合并分支<code>B</code>就可以满足我们想要的状态：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205173630138.png" alt="image-20220205173630138" style="zoom: 67%;" /></p><p>执行合并后：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205174155577.png" alt="image-20220205174155577" style="zoom:67%;" /></p><p>这是，系统告诉我们ReadMe.md合并过程中发生冲突(Conflict)。系统在合并ReadMe.md文件时，分支A更改的部分和分支B更改的部分发生了冲突。</p><p>所以需要解决冲突来完成合并。</p><ul><li><p><strong>查看冲突部分并将其解决</strong></p><p>使用编辑器打开ReadMe.md查看文件，会发现文件的内容变成如下示例类似样子：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205174526571.png" alt="image-20220205174526571" style="zoom:60%;" /></p><p><code>==========</code>以上的部分是当前HEAD的内容，以下的内容是要合并的分支B中的内容，现在将其该成我们想要的样子</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205174715520.png" alt="image-20220205174715520" style="zoom:60%;" /></p><p>现在内容被修改成了我们想要保存的样子，冲突解决</p></li><li><p><strong>提交最后的解决方案</strong></p><p>现在来执行<code>git add</code>命令和<code>git commit</code>命令来完成提交</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205174916848.png" alt="image-20220205174916848" style="zoom:67%;" /></p></li></ul><h2 id="git-commit-amend——修改提交信息"><a href="#git-commit-amend——修改提交信息" class="headerlink" title="git commit --amend——修改提交信息"></a><strong><code>git commit --amend</code>——修改提交信息</strong></h2><p>要修改上一条提交信息，可以使用<code>git commit --amend</code>命令，执行该命令后，会弹出编辑器，对内容进行修改后，关闭编辑器即可完成修改。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205181447963.png" alt="image-20220205181447963" style="zoom:60%;" /></p><h2 id="git-rebase-i——压缩历史"><a href="#git-rebase-i——压缩历史" class="headerlink" title="git rebase -i——压缩历史"></a><strong><code>git rebase -i</code>——压缩历史</strong></h2><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。</p><p>现在我们新开一个分支<code>C</code>并且修改其中的内容来作为后面修正。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205183834327.png" alt="image-20220205183834327" style="zoom:67%;" /></p><p>然后提交故意修改错误的内容，可以通过如下命令来一次执行到暂存区再到<code>commit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am</span><br></pre></td></tr></table></figure><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205184112266.png" alt="image-20220205184112266" style="zoom:67%;" /></p><ul><li><p><strong>修正拼写错误</strong></p><p>现在来修正刚刚的错误，修正完毕后查看修正前后的差别。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205184435866.png" alt="image-20220205184435866" style="zoom:67%;" /></p><p>然后进行提交</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205184620781.png" alt="image-20220205184620781" style="zoom:67%;" /></p><p>这种后来进行修正的错误，我们不希望在历史记录中看到这类提交，因为健全的历史记录不需要它们。如果在第一次合并中就发现并修正这些错误，也就不会出现这类提交了。</p></li><li><p><strong>更改历史</strong></p><p>因此，我们需要来更改历史。将修正的内容与之前的提交合并，在历史记录合并为一次完美的提交。因此，我们需要使用<code>git rebase</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>用上述命令，可以选定当前分支包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205193525354.png" alt="image-20220205193525354" style="zoom:67%;" /></p><p>将6aca246的修正错误历史记录压缩到92d473d的ReadMe.md中，按照下述的方法，将6aca246左侧的<code>pick</code>部分删除，改为<code>fixup</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 92d473d ReadMe.md</span><br><span class="line">fixup 6aca246 修正了部分错误</span><br></pre></td></tr></table></figure><p>修改完成后，关闭编辑器，系统提示<code>Rebase</code>成功：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205193849481.png" alt="image-20220205193849481" style="zoom:57%;" /></p><p>也就是说将两个提交作为对象，合并到了第一次提交的时候成了一个新的提交。</p><p>现在再查看提交日志会发现最新的提交日志已经合并一个切之前写的描述信息也已经不见了，这证明提交已经被修改了。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205194109469.png" alt="image-20220205194109469" style="zoom:67%;" /></p></li><li><p><strong>合并到<code>master</code>分支</strong></p><p>现在将分支<code>C</code>可以合并到主分支<code>master</code>了。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205194338635.png" alt="image-20220205194338635" style="zoom:57%;" /></p></li></ul><h1 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h1><p>Git是分散型版本管理系统，前面的操作都是针对单一本地仓库的操作。现在来尝试对远程仓库进行操作。现在首先在GitHub上创建一个仓库，不需要勾选<code>README</code>选项。仓库名称随意，此处演示远程仓库名称为TestGit。</p><h2 id="git-remote-add——添加远程仓库"><a href="#git-remote-add——添加远程仓库" class="headerlink" title="git remote add——添加远程仓库"></a><strong><code>git remote add</code>——添加远程仓库</strong></h2><p><strong>在GitHub上创建的仓库路径为”git@github.com:用户名/仓库名称.git”</strong>。现在来使用<code>git remote add</code>命令将其设置成本地仓库的远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式：</span></span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令示例：</span></span><br><span class="line">git remote add test git@github.com:L-Seraphine/TestGit.git</span><br></pre></td></tr></table></figure><p><strong>根据上述命令，将地址为：git@github.com:L-Seraphine/TestGit.git远程仓库的名称设置为：test（标识符）。可以通过标识符快速表示该地址的远程仓库</strong>。</p><h2 id="git-push——推送至远程仓库"><a href="#git-push——推送至远程仓库" class="headerlink" title="git push——推送至远程仓库"></a><strong><code>git push</code>——推送至远程仓库</strong></h2><ul><li><p><strong>推送至<code>master</code>分支</strong></p><p>如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到<code>git push</code>命令。现在假定我们在<code>master</code>分支下进行操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u test master</span><br></pre></td></tr></table></figure><p>执行如上命令，当前分支的内容会被推送给远程仓库TestGit的<code>mastet</code>分支。<code>-u</code>参数可以在推送时，将远程仓库的<code>master</code>分支设置为本地仓库当前分支的upstream(上游)。添加这个参数，将来运行<code>git pull</code>命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从远程仓库的<code>master</code>分支获取内容，省去了另外添加参数的麻烦。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205205105145.png" alt="image-20220205205105145" style="zoom:67%;" /></p><p>执行该操作后，当前本地仓库的<code>master</code>分支的内容就会被推送到GitHub的远程仓库中。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205205151846.png" alt="image-20220205205151846" style="zoom:67%;" /></p></li><li><p><strong>推送至<code>master</code>以外的分支</strong></p><p>除了<code>master</code>分支之外，远程仓库也可以创建其他分支。现在我们在本地仓库创建分支<code>D</code>,并将它推送至远程的同名分支。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205205512167.png" alt="image-20220205205512167" style="zoom:67%;" /></p><p>现在，在远程仓库的GitHub页面就可以看到分支<code>D</code>了。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205205548606.png" alt="image-20220205205548606" style="zoom: 80%;" /></p></li></ul><h1 id="从远程仓库获取"><a href="#从远程仓库获取" class="headerlink" title="从远程仓库获取"></a>从远程仓库获取</h1><p>上部分我们将GitHub上的远程仓库<code>push</code>了分支D。现在，所有能够访问这个远程仓库的人都可以获取分支<code>D</code>并加以修改。</p><h2 id="git-clone——获取远程仓库"><a href="#git-clone——获取远程仓库" class="headerlink" title="git clone——获取远程仓库"></a><strong><code>git clone</code>——获取远程仓库</strong></h2><p><code>git clone</code>命令在很早之前就使用过，语法格式和操作方法不再说明。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205210223590.png" alt="image-20220205210223590" style="zoom:67%;" /></p><p><strong>执行<code>git clone</code>命令后默认我们会处于<code>master</code>分支下，同时系统会自动将<code>origin</code>设置为该远程仓库的标识符</strong>。也就是说，当前本地仓库的<code>master</code>分支和远程仓库的<code>master</code>分支的内容是完全一致的。</p><p>我们使用<code>git branch -a</code>命令查看当前分支的相关信息。添加<code>-a</code>参数可以同时显示本地仓库和远程仓库的分支信息。</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205210716346.png" alt="image-20220205210716346" style="zoom:67%;" /></p><h2 id="获取远程仓库的分支D"><a href="#获取远程仓库的分支D" class="headerlink" title="获取远程仓库的分支D"></a>获取远程仓库的分支D</h2><p>使用如下命令将指定获取远程仓库的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b D origin/D</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">D的意思是创建本地分支名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin是默认的远程仓库的标识符</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin/D是远程仓库的分支D的路径</span></span><br></pre></td></tr></table></figure><p>现在假定我们是另一个开发者，需要做一个新的提交。在ReadMe.md文件中添加一行文字，如下：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205211918862.png" alt="image-20220205211918862" style="zoom: 67%;" /></p><p>然后提交即可：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205212058588.png" alt="image-20220205212058588" style="zoom:67%;" /></p><p>然后远程推送即可：</p><p><img src="https://wordpress-serverless-code-ap-beijing-1303234197.cos.ap-beijing.myqcloud.com/PicGo/image-20220205212202257.png" alt="image-20220205212202257" style="zoom: 65%;" /></p><h2 id="git-pull——获取最新的远程仓库分支"><a href="#git-pull——获取最新的远程仓库分支" class="headerlink" title="git pull——获取最新的远程仓库分支"></a><strong><code>git pull</code>——获取最新的远程仓库分支</strong></h2><p>当远程仓库的内容更新了，需要拉取，则可以通过如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 远程仓库标识符 分支名称</span><br></pre></td></tr></table></figure><p>来获取远程仓库，对本地仓库进行更新。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
